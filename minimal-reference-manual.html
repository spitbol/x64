<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
<title>MINIMAL Reference Manual 1.0</title>
</head>


<body>

<h1>Introduction</h1>

<p>The implementation of MACRO SPITBOL is written in three languages:
MINIMAL, C, and assembler.

<p>The SPITBOL compiler and runtime is written in MINIMAL, a
machine-independent portable assembly language.

<p>The runtime is augmented by procedures written in C that
collectively comprise OSINT (Operating System INTerface). These
procedures provides such functions as input and output, system
initialization and termination, management of UNIX pipes, the loading
of external functions, and so forth.

<p> The implementation also includes assembly code. This size of this
code varies according to the target machine. About 1500 lines are
needed for the x86 architecture running UNIX. This code provides such
functions as macros that define the translation of MINIMAL
instructions that take more than a few machine-level instructions,
support for calling C procedures from MINIMAL, for calling MINIMAL
procedures from C, for creating save files and load modules, and for
resuming execution from save files or loand load modules.

<p>To give some idea of the flavor of the code, consider the following simple
SPITBOL program that copies standard input to standard output.

<pre>
loop output = input :s(loop)
end
</pre>

<p>By default, the variable <em>input</em> is input-associated to standard input, so each attempt to get its value results in reading in a line from standard input and returning the line as a string.
The read fails if there are no more lines, and succeeds otherwise.


<p>Similarly, the variable <em>output</em> is output-associated with standard
output, so each assignment to <em>output</em> causes the assigned value to be
written to the standard output file.

<p>The osint procedure for writing a line is <strong>SYSOU</strong>. It is called from within SPITBOL as part of assignment, as shown in the follwing excerpt
from the MINIMAL source:

<pre>
*      here for output association

asg10  bze  kvoup,asg07      ignore output assoc if output off
asg1b  mov  xl,xr            copy trblk pointer
       mov  xr,trnxt(xr)     point to next trblk
       beq  (xr),=b_trt,asg1b loop back if another trblk
       mov  xr,xl            else point back to last trblk
.if    .cnbf
       mov  -(xs),trval(xr)  stack value to output
.else
       mov  xr,trval(xr)     get value to output
       beq  (xr),=b_bct,asg11 branch if buffer
       mov  -(xs),xr         stack value to output
.fi
       jsr  gtstg            convert to string
       ppm  asg12            get datatype name if unconvertible

*      merge with string or buffer to output in xr

asg11  mov  wa,trfpt(xl)     fcblk ptr
       bze  wa,asg13         jump if standard output file

*      here for output to file

asg1a  jsr  sysou            call system output routine
       err  206,output caused file overflow
       err  207,output caused non-recoverable error
       exi                   else all done, return to caller
</pre>

<p>From the OSINT C code (the C procedure name starts with 'z' since there is some
needed intermediate code (shown below) to go from MINIMAL to C at runtime):


<pre>
zysou()
{
    REGISTER struct fcblk *fcb = WA(struct fcblk *);
    REGISTER union block *blk = XR(union block *);
    int result;

    if (blk->scb.typ == type_scl) {
	/* called with string, get length from SCBLK */
	SET_WA(blk->scb.len);
    } else {
	/* called with buffer, get length from BCBLK, and treat BSBLK
	 * like an SCBLK
	 */
	SET_WA(blk->bcb.len);
	SET_XR(blk->bcb.bcbuf);
    }

    if (fcb == (struct fcblk *) 0 || fcb == (struct fcblk *) 1) {
	if (!fcb)
	    result = zyspi();
	else
	    result = zyspr();
	if (result == EXI_0) 
	    return EXI_0;
	else 
	    return EXI_2;
    }

    /* ensure iob is open, fail if unsuccessful */
    if (!(MK_MP(fcb->iob, struct ioblk *)->flg1 & IO_OPN)) {
	 return EXI_1;
    }

    /* write the data, fail if unsuccessful */
    if (oswrite
	(fcb->mode, fcb->rsz, WA(word), MK_MP(fcb->iob, struct ioblk *),
	 XR(struct scblk *)) != 0)
	 return EXI_2;

    /* normal return */
    return EXI_0;
}
</pre>

<p>Here is a fragment of the assembly code that is used to 
call a C procedure from MINIMAL. The code is  for 32-bit X86 
and is written using NASM (Netwide Assembler) syntax.

<pre>
	%macro	mtoc	1
	extern	%1
	; save minimal registers to make their values available to called procedure
	mov     dword [reg_wa],ecx     
        mov     dword [reg_wb],ebx
        mov     dword [reg_wc],edx	; (also reg_ia)
        mov     dword [reg_xr],edi
        mov     dword [reg_xl],esi
        mov     dword [reg_cp],ebp	; Needed in image saved by sysxi
        call    %1			; call c interface function
;       restore minimal registers since called procedure  may have changed them
        mov     ecx, dword [reg_wa]	; restore registers
        mov     ebx, dword [reg_wb]
        mov     edx, dword [reg_wc]	; (also reg_ia)
        mov     edi, dword [reg_xr]
        mov     esi, dword [reg_xl]
        mov     ebp, dword [reg_cp]
;	restore direction flag in (the unlikely) case that it was changed
        cld
;	note that the called procedure must return exi action in eax
	ret
	%endmacro

  ...

	global	sysou			; output record
sysou:
	mtoc	zysou
</pre>

<p>The remainder of this document consists of text that was formerly
part of the source code for the MACRO SPITBOL compiler. It was converted
from plain text to HTML by Dave Shields.

<h1>MINIMAL -- Machine Independent Macro Assembly Language</h1>

<p>

The following sections describe the implementation language originally
developed for SPITBOL but now more widely used. 
MINIMAL (Machine Independent Macro Assembly Language) is an assembly
language for an idealized machine. The following describes the basic
characteristics of this machine.

<h2>Configuration Parameters</h2>

<p>

There are several parameters which may vary with the target machine.
the macro-program is independent of the actual definitions of these
parameters.

<p>
 
The definitions of these parameters are supplied by the translation
program to match the target machine.

<dl>
<dt><strong>cfp$a</strong> 

<dd>Number of distinct characters in internal alphabet in the range 64
le <strong>cfp$a</strong> le <strong>MAXLEN</strong>.

<dt><strong>cfp$b</strong> 

<dd>Number of bytes in a word where a byte is the amount of storage
addressed by the least significant address bit.  

<dt> <strong>cfp$c</strong> 

<dd> Number of characters which can be stored in a single word.

<dt><strong>cfp$f</strong> 

<dd>Byte offset from start of a string block to the first character.
depends both on target machine and string data structure. see
<strong>plc</strong> psc

<dt><strong>cfp$i</strong> 

<dd> Number of words in a signed integer constant

<dt><strong>cfp$l</strong> 

<dd> The largest unsigned integer of form 2**n - 1 which can be stored
in a single word.  n will often be <strong>cfp$n</strong> but need not
be.

<dt><strong>cfp$m</strong> 

<dd>The largest positive signed integer of form 2**n - 1 which can be
stored in a single word.  n will often be <strong>cfp$n</strong> -1
but need not be.

<dt><strong>cfp$n</strong> 

<dd> Number of bits which can be stored in a one word bit string.

<dt><strong>cfp$r</strong> 

<dd> Number of words in a real constant

<dt><strong>cfp$s</strong> 

<dd> 

Number of significant digits to be output in conversion of a real
quantity.  .if .cncr .else the integer consisting of this number of 9s
must not be too large to fit in the integer accum.  .fi

<pre>



.if    .cucf
       <strong>cfp$u</strong>                  realistic upper bound on alphabet.


.fi
       <strong>cfp$x</strong>                  number of digits in real exponent
</pre>

</dl>

<h2>Memory</h2>

<p>

Memory is organized into words which each contain
<strong>cfp$b</strong> bytes. for word machines <strong>cfp$b</strong>
, which is a configuration parameter, may be one in which case words
and bytes are identical. To each word corresponds an address which is
a non-negative quantity which is a multiple of <strong>cfp$b</strong>
.  data is organized into words as follows.


<ol>

   <li>

A signed integer value occupies <strong>cfp$i</strong> consecutive
words (<strong>cfp$i</strong> is a configuration parameter).  The
range may include more negative numbers than positive (e.g. the twos
complement representation).


<li>A signed real value occupies <strong>cfp$r</strong> consecutive
words. (<strong>cfp$r</strong> is a configuration parameter).

<li><strong>cfp$c</strong> characters may be stored in a single word
(<strong>cfp$c</strong> is a configuration parameter).

<li>

A bit string containing <strong>cfp$n</strong> bits can be stored in a
single word (<strong>cfp$n</strong> is a configuration parameter).

<li>

A word can contain a unsigned integer value in the range (0 le n le
<strong>cfp$l</strong> . These integer values may represent addresses
of other words and some of the instructions use this fact to provide
indexing and indirection facilities.  

<li>Program instructions occupy
words in an undefined manner. Depending on the actual implementation,
instructions may occupy several words, or part of a word, or even be
split over word boundaries.

</ol>
</pre>

<p>

The following regions of memory are available to the program. each
region consists of a series of words with consecutive addresses.

<ol>

   <li>constant section ---            assembled constants

<li> working storage section ---    assembled work areas

<li>program section ---            assembled instructions

<li>stack area ---                 allocated stack area

<li>data area ---                  allocated data area


</ol>

<h2>Registers</h2>

<p>

There are three index registers called <strong>XR</strong>
,<strong>XL</strong> ,<strong>XS</strong> . In addition
<strong>XL</strong> may sometimes be referred to by the alias of <strong>xt</strong> -
see section 4. any of the above registers may hold a positive unsigned
integer in the range (0 le n le <strong>cfp$l</strong> ). When the
index register is used for indexing purposes, this must be an
appropriate address.  <strong>XS</strong> is special in that it is
used to point to the top item of a stack in memory. the stack may
build up or down in memory.since it is required that
<strong>XS</strong> points to the stack top but access to items below
the top is permitted, registers <strong>XS</strong> and <strong>xt</strong> may be used
with suitable offsets to index stacked items. only <strong>XS</strong>
and <strong>xt</strong> may be used for this purpose since the direction of the offset
is target machine dependent. <strong>xt</strong> is a synonym for <strong>XL</strong>
which therefore cannot be used in code sequences referencing <strong>xt</strong>.

       <p>

The stack is used for s-r linkage and temporary data storage for which
the stack arrangement is suitable.  <strong>XR</strong>
,<strong>XL</strong> can also contain a character pointer in
conjunction with the character instructions (see description of plc).


       <p>

There are three work registers called <strong>WA</strong>,<strong>WB</strong>
,<strong>WC</strong> which can contain any data item which can be
stored in a single memory word. In fact, the work registers are just
like memory locations except that they have no addresses and are
referenced in a special way by the instructions.

       <p>

Note that registers <strong>WA</strong>,<strong>WB</strong> have special uses in
connection with the <strong>cvd</strong> <strong>cvm</strong>
<strong>mvc</strong> <strong>mvw</strong> <strong>MWB</strong> ,
<strong>cmc</strong> <strong>trc</strong> instructions.

       <p>

Register <strong>WC</strong> may overlap the integer accumulator
(<strong>IA</strong> ) in some implementations. thus any operation
changing the value in <strong>WC</strong> leaves (<strong>IA</strong>
) undefined and vice versa except as noted in the following
restriction on simple dump/restore operations.

       <p>
<pre>
           restriction
           -----------

       if <strong>IA</strong>  and <strong>WC</strong>  overlap then
           <strong>sti</strong>  iasav
           <strong>ldi</strong>  iasav
       does not change <strong>WC</strong> , and
           <strong>mov</strong>  <strong>WC</strong> ,<strong>WC</strong> sav
           <strong>mov</strong>  <strong>WC</strong> sav,<strong>WC</strong> 
       does not change <strong>IA</strong> .
</pre>

<p>

There is an integer accumulator (<strong>IA</strong> ) which is
capable of holding a signed integer value (<strong>cfp$i</strong>
words long).  register <strong>WC</strong> may overlap the integer
accumulator (<strong>IA</strong> ) in some implementations. thus any
operation changing the value in <strong>WC</strong> leaves
(<strong>IA</strong> ) undefined and vice versa except as noted in the
above restriction on simple dump/restore operations.

<p>


There is a single real accumulator (<strong>RA</strong> ) which can
hold any real value and is completely separate from any of the other
registers or program accessible locations.


<p>

The code pointer register (<strong>CP</strong> ) is a special index
register for use in implementations of interpretors.  it is used to
contain a pseudo-code pointer and can only be affected by
i<strong>CP</strong> , <strong>CP</strong> , s<strong>CP</strong> and
<strong>lcw</strong> instructions.

<h2>The Stack</h2>

<p>

The following notes are to guide both implementors of systems written
in MINIMAL and MINIMAL programmers in dealing with stack manipulation.
implementation of a downwards building stack is easiest and in general
is to be preferred, in which case it is merely necessary to consider
<strong>xt</strong> as an alternative name for <strong>XL</strong> .

       <p>

The MINIMAL virtual machine includes a stack and has operand formats
-(<strong>XS</strong> ) and (<strong>XS</strong> )+ for pushing and
popping items with an implication that the stack builds down in memory
(a d-stack). however on some target machines it is better for the
stack to build up (a u-stack).  
<p>~A stack addressed only by push and pop
operations can build in either direction with no complication but such
a pure scheme of stack access proves restrictive.  Hence it is
permitted to access buried items using an integer offset past the
index register pointing to the stack top. on target machines this
offset will be positive/negative for d-stacks/u-stacks and this must
be allowed for in the translation. 
<p> A further restriction is that at
no time may an item be placed above the stack top. For some operations
this makes it convenient to advance the stack pointer and then address
items below it using a second index register.  The problem of signed
offsets past such a register then arises. to distinguish stack
offsets, which in some implementations may be negative, from non-stack
offsets which are invariably positive, <strong>xt</strong>, an alias or synonym for
<strong>XL</strong> is used. 
<p>For a u-stack implementation, the MINIMAL
translator should negate the sign of offsets applied to both
(<strong>XS</strong> ) and (<strong>xt</strong>).  Programmers should note that since
<strong>xt</strong> is not a separate register, <strong>XL</strong> should not be used
in code where <strong>xt</strong> is referenced. Other modifications needed in u-stack
translations are in the <strong>add</strong> <strong>sub</strong>
<strong>ica</strong> <strong>dca</strong> opcodes applied to
<strong>XS</strong> , <strong>xt</strong>. For example

       <pre>
       MINIMAL           d-stack trans.  u-stack trans.

       <strong>mov</strong>  <strong>WA</strong>,-(<strong>XS</strong> )     <strong>sbi</strong>  <strong>XS</strong> ,1       <strong>adi</strong>  <strong>XS</strong> ,1
                         sto  <strong>WA</strong>,(<strong>XS</strong> )    sto  <strong>WA</strong>,(<strong>XS</strong> )
       <strong>mov</strong>  (<strong>xt</strong>)+,<strong>WC</strong>      lod  <strong>WC</strong> ,(<strong>XL</strong> )    lod  <strong>WC</strong> ,(<strong>XL</strong> )
                         <strong>adi</strong>  <strong>XL</strong> ,1       <strong>sbi</strong>  <strong>XL</strong> ,1
       <strong>add</strong>XS</strong>,=seven     <strong>adi</strong>  <strong>XS</strong> ,7       <strong>sbi</strong>  <strong>XS</strong> ,7
       <strong>mov</strong>  2(<strong>xt</strong>),<strong>WA</strong>     lod  <strong>WA</strong>,2(<strong>XL</strong> )   lod  <strong>WA</strong>,-2(<strong>XL</strong> )
       <strong>ica</strong>  <strong>XS</strong>            <strong>adi</strong>  <strong>XS</strong> ,1       <strong>sbi</strong>  <strong>XS</strong> ,1

       note that forms such as
       <strong>mov</strong>  -(<strong>XS</strong> ),<strong>WA</strong>
       <strong>add</strong>  (<strong>XS</strong> ),<strong>WA</strong>
       are illegal, since they assume information storage
       above the stack top.
</pre>

<h2>Internal Character Set</h2>

<p>

The internal character set is represented by a set of contiguous codes
from 0 to <strong>cfp$a</strong> -1. The codes for the digits 0-9 must
be contiguous and in sequence. Other than this, there are no
restraints.

       <p>

The following symbols are automatically defined to have the value of
the corresponding internal character code.

       <pre>
       ch$la                 letter a
       ch$lb                 letter b
       .                     .
       ch$l$                 letter z

       ch$d0                 digit 0
       .                     .
       ch$d9                 digit 9

       ch$am                 ampersand
       ch$as                 asterisk
       ch$at                 at
       ch$bb                 left bracket
       ch$bl                 blank
       ch$br                 vertical bar
       ch$cl                 colon
       ch$cm                 comma
       ch$dl                 dollar sign
       ch$dt                 dot (period)
       ch$dq                 double quote
       ch$eq                 equal sign
       ch$ex                 exclamation mark
       ch$mn                 minus
       ch$nm                 number sign
       ch$nt                 not
       ch$pc                 percent
       ch$pl                 plus
       ch$pp                 left paren
       ch$rb                 right bracket
       ch$rp                 right paren
       ch$qu                 question mark
       ch$sl                 slash
       ch$sm                 semi-colon
       ch$sq                 single quote
       ch$un                 underline
</pre>
<p>

The following optional symbols are incorporated by defining the
conditional assembly symbol named.

<pre>
       26 shifted letters incorporated by defining .casl

       ch$$a                 shifted a
       ch$$b                 shifted b
       .                     .
       ch$$$                 shifted z

       ch$ht                 horizontal tab - define .caht
       ch$vt                 vertical tab   - define .cavt
       ch$ey                 up arrow       - define .caex
</pre>

<h2>Conditional Assembly Features</h2>

<p>

Some features of the interpreter are applicable to only certain target
machines. they may be incorporated or omitted by use of conditional
assembly. The full form of a condition is -

       <pre>
       .if    conditional assembly symbol    (cas)
       .then
              minimal statements1   (ms1)
       .else
              minimal statements2   (ms2)
       .fi
</pre>
       The following rules apply

<ol>
   <li>The directives <strong>.if</strong>   <strong>.then</strong>   <strong>.else</strong>  <strong>.fi</strong> must
            start in column 1.
       <li>The conditional assembly symbol must start with a
            dot in column 8 followed by 4 letters or digits e.g.
<pre>
               .ca$1
</pre>
       <li>.<strong>then</strong> is redundant and may be omitted if wished.

       <li>ms1, ms2 are arbitrary sequences of MINIMAL
            statements either of which may be null or may
            contain further conditions.

<li>If ms2 is omitted, .<strong>else</strong> may also be omitted.

<li>.<strong>fi</strong> is required.

<li>Conditions may be nested to a depth determined
            by the translator (not less than 20, say).
</ol>
<pr>
       Selection of the alternatives ms1, ms2 is by means of the
       define and undefine directives of form -
<pre>
       .<strong>def</strong>   cas
       .<strong>undef</strong> cas
</pre>
<p>

Which obey rules 1. and 2. above and may occur at any point in a
MINIMAL program, including within a condition.  Multiply defining a
symbol is an error.  Undefining a symbol which is not defined is not
an error.

       <p>

The effect is that if a symbol is currently defined,
<strong>then</strong> in any condition depending on it, ms1 will be
processed and ms2 omitted. Conversely if it is undefined, ms1 will be
omitted and ms2 processed.

       <p>

Nesting of conditions is such that conditions in a section not
selected for processing must not be evaluated. nested conditions must
remember their environment whilst being processed. Effectively this
implies use of a scheme based on a stack with if .fi matching by the
condition processor of the translator.

<h2>Operand Formats</h2>
<p>

The following section describes the various possibilities for operands
of instructions and assembly operations.

<p>
The numbers in the above list are used in subsequent description and
in some of the MINIMAL translators.

<p>
The following special symbols refer to a collection of the listed
possibilities

<dl>

<dt><em>val</em>  01,02

<dd>predefined value

<p>

<em>val</em> is used to refer to a predefined one word integer value in the
range 0 le n le <strong>cfp$l</strong> 

<dt>reg  07,08

<dd>register

<p>

<em>reg</em> is used to describe an operand which can be any of the
registers (<strong>XL</strong> , <strong>XR</strong> ,
<strong>XS</strong> ,<strong>XT</strong> , <strong>WA</strong> ,
<strong>WB</strong> , <strong>WC</strong> ). Such an operand can hold
a one word integer (address).

<dt> <em>opc</em>  09,10,11

<dd>                   character

<p>

<em>opc</em> is used to designate a specific character operand for use
in the <strong>lch</strong> and <strong>sch</strong> instructions.
the index register referenced must be either <strong>XR</strong> or
<strong>XL</strong> (not <strong>XS</strong> ,<strong>xt</strong>). see section on
character operations.

<dt> <em>ops</em>  03,04,09,12,13,14,15

<dd>       memory reference

<p>

<em>ops</em> is used to describe an operand which is in memory. the
operand may be one or more words long depending on the data type. In
the case of multiword operands, the address given is the first word.

<dt> <em>opw</em>  as for  <em>ops</em> + 08,10,11

<dd>      full word

<p>

<em>opw</em> is used to refer to an operand whose capacity is that of
a full memory word.  <em>opw</em> includes all the possibilities for
<em>ops</em> (the referenced word is used) plus the use of one of the
three work registers (<strong>WA</strong>,<strong>WB</strong> ,<strong>WC</strong> ).
in addition, the formats (x)+ and -(x) allow indexed operations in
which the index register is popped by one word after the reference
(x)+, or pushed by one word before the reference -(x) these latter two
formats provide a facility for manipulation of stacks. the format does
not imply a particular direction in which stacks must build - it is
used for compactness.
 <p>Note that there is a restriction which disallows
an instruction to use an index register in one of these formats in
some other manner in the same instruction.  e.g.  <strong>mov</strong>
<strong>XL</strong> ,(<strong>XL</strong> )+ is illegal.  The formats
-(x) and (x)+ may also be used in pre-decrementation,
post-incrementation to access the adjacent character of a string.

<dt> <em>opn</em>  as for  <em>opw</em> + 07

<dd>            one word integer

<p>

<em>opn</em> is used to represent an operand location which can
contain a one word integer (e.g. an address).  This includes all the
possibilities for <em>opw</em> plus the use of one of the index
registers (<strong>XL</strong> ,<strong>XR</strong> ,
<strong>XT</strong> , <strong>XS</strong> ). The range of integer
values is 0 le n le <strong>cfp$l</strong> 

<dt> <em>opv</em>  as for  <em>opn</em> + 18-22

<dd>         one word integer value

<p>

<em>opv</em> is used for an operand which can yield a one word integer
value (e.g. an address). It includes all the possibilities for
<em>opn</em> (the current value of the location is used) plus the use
of literals.
<p>Note that although the literal formats are described in
terms of a reference to a location containing an address constant,
This location may not actually exist in some implementations since
only the value is required. A restriction is placed on literals which
may consist only of defined symbols and certain labels. Consequently
small integers to be used as literals must be pre-defined, a
discipline aiding program maintenance and revision.


<dt><em>addr</em> 01,02,03,04,05

<dd>address

<p>

<em>addr</em> is used to describe an explicit address value (one word integer
value) for use with <strong>dac</strong> 

<pre>

            ****************************************************
            *   in the following descriptions the usage --     *
            *      (<strong>XL</strong> ),(<strong>XR</strong> ), ... ,(<strong>IA</strong> )                        *
            *   in the descriptive te<strong>xt</strong> signifies the          +
            *   contents of the stated register.               *
            ****************************************************
</pre>
</dl>

<h2>Instruction Mnemonics</h2>

<p>


The following list includes all instruction and assembly operation
mnemonics in alphabetical order.  The mnemonics are preceded by a
number identifying the following section where the instruction is
described.  A star (*) is appended to the mnemonic if the last operand
may optionally be omitted.  See section -15- for details of statement
format and comment conventions.

<p>
<table>
<tr>
<th>Section</th>
<th>Op</th>
<th>Operands</th>
<th>Description</th>
</tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2.1</td>
<td><strong>add</strong></td>
<td align="left"><em>opn</em>,<em>opv</em></td>
<td>add address <em>opv</em> to <em>opn</em></td>
</tr>
<tr>
<td>4.2</td>
<td><strong>adi</strong></td>
<td align="left"><em>ops</em></td>
<td>add integer</td>
</tr>
<tr>
<td>5.3</td>
<td><strong>adr</strong></td>
<td align="left"><em>ops</em></td>
<td>add real</td>
</tr>
<tr>
<td>7.1</td>
<td><strong>anb</strong></td>
<td align="left"><em>w</em>,<em>opw</em></td>
<td>and bit string</td>
</tr>
<tr>
<td>2.17</td>
<td><strong>aov</strong></td>
<td align="left"><em>opn</em>,<em>opv</em>,<em>plbl</em></td>
<td>add address, fail if overflow</td>
</tr>
<tr>
<td>5.16</td>
<td><strong>atn</strong></td>
<td>arctangent</td>
<td>of real accum</td>
</tr>
<tr>
<td>2.16</td>
<td><strong>bct</strong></td>
<td align="left"><em>w,plbl</em></td>
<td>branch and count</td>
</tr>
<tr>
<td>2.5</td>
<td><strong>beq</strong></td>
<td align="left"><em>opn</em>,<em>opv</em>,<em>plbl</em></td>
<td>branch if address equal</td>
</tr>
<tr>
<td>2.18</td>
<td><strong>bev</strong></td>
<td align="left"><em>opn</em>,<em>plbl</em></td>
<td>branch if address even</td>
</tr>
<tr>
<td>2.8</td>
<td><strong>bge</strong></td>
<td align="left"><em>opn</em>,<em>opv</em>,<em>plbl</em></td>
<td>branch if address greater or equl</td>
</tr>
<tr>
<td>2.7</td>
<td><strong>bgt</strong></td>
<td align="left"><em>opn</em>,<em>opv</em>,<em>plbl</em></td>
<td>branch if address greater</td>
</tr>
<tr>
<td>2.12</td>
<td><strong>bhi</strong></td>
<td align="left"><em>opn</em>,<em>opv</em>,<em>plbl</em></td>
<td>branch if address high</td>
</tr>
<tr>
<td>2.10</td>
<td><strong>ble</strong></td>
<td align="left"><em>opn</em>,<em>opv</em>,<em>plbl</em></td>
<td>branch if address less or equal</td>
</tr>
<tr>
<td>2.11</td>
<td><strong>blo</strong></td>
<td align="left"><em>opn</em>,<em>opv</em>,<em>plbl</em></td>
<td>branch if address low</td>
</tr>
<tr>
<td>2.9</td>
<td><strong>blt</strong></td>
<td align="left"><em>opn</em>,<em>opv</em>,<em>plbl</em></td>
<td>branch if address less than</td>
</tr>
<tr>
<td>2.6</td>
<td><strong>bne</strong></td>
<td align="left"><em>opn</em>,<em>opv</em>,<em>plbl</em></td>
<td>branch if address not equal</td>
</tr>
<tr>
<td>2.13</td>
<td><strong>bnz</strong></td>
<td align="left"><em>opn</em>,<em>plbl</em></td>
<td>branch if address non-zero</td>
</tr>
<tr>
<td>2.19</td>
<td><strong>bod</strong></td>
<td align="left"><em>opn</em>,<em>plbl</em></td>
<td>branch if address odd</td>
</tr>
<tr>
<td>1.2</td>
<td><strong>brn</strong></td>
<td align="left"><em>plbl</em></td>
<td>branch unconditional</td>
</tr>
<tr>
<td>1.7</td>
<td><strong>bri</strong></td>
<td align="left"><em>opn</em></td>
<td>branch indirect</td>
</tr>
<tr>
<td>1.3</td>
<td><strong>bsw*</strong></td>
<td align="left"><em>x,val,plbl</em></td>
<td>branch on switch value</td>
</tr>
<tr>
<td>8.2</td>
<td><strong>btw</strong></td>
<td align="left"><em>reg</em></td>
<td>convert bytes to words</td>
</tr>
<tr>
<td>2.14</td>
<td><strong>bze</strong></td>
<td align="left"><em>opn</em>,<em>plbl</em></td>
<td>branch if address zero</td>
</tr>
<tr>
<td>6.6</td>
<td><strong>ceq</strong></td>
<td>opw,opw,<em>plbl</em></td>
<td>branch if characters equal</td>
</tr>
<tr>
<td>10.1</td>
<td><strong>chk</strong></td>
<td align="left"><em>check</em></td>
<td>stack overflow</td>
</tr>
<tr>
<td>5.17</td>
<td><strong>chp</strong></td>
<td>integer</td>
<td>portion of real accum</td>
</tr>
<tr>
<td>7.4</td>
<td><strong>cmb</strong></td>
<td align="left"><em>w</em></td>
<td>complement bit string</td>
</tr>
<tr>
<td>6.8</td>
<td><strong>cmc</strong></td>
<td align="left"><em>plbl</em>,<em>plbl</em></td>
<td>compare character strings</td>
</tr>
<tr>
<td>6.7</td>
<td><strong>cne</strong></td>
<td>opw,opw,<em>plbl</em></td>
<td>branch if characters not equal</td>
</tr>
<tr>
<td>6.5</td>
<td><strong>csc</strong></td>
<td align="left"><em>x</em></td>
<td>complete store characters</td>
</tr>
<tr>
<td>5.18</td>
<td><strong>cos</strong></td>
<td>cosine</td>
<td>of real accum</td>
</tr>
<tr>
<td>8.8</td>
<td><strong>ctb</strong></td>
<td>w,<em>val</em></td>
<td>convert character count to bytes</td>
</tr>
<tr>
<td>8.7</td>
<td><strong>ctw</strong></td>
<td>w,<em>val</em></td>
<td>convert character count to words</td>
</tr>
<tr>
<td>8.10</td>
<td><strong>cvd</strong></td>
<td>convert</td>
<td>by division</td>
</tr>
<tr>
<td>8.9</td>
<td><strong>cvm</strong></td>
<td align="left"><em>plbl</em></td>
<td>convert by multiplication</td>
</tr>
<tr>
<td>11.1</td>
<td><strong>dac</strong></td>
<td align="left"><em>addr</em></td>
<td>define address constant</td>
</tr>
<tr>
<td>11.5</td>
<td><strong>dbc</strong></td>
<td align="left"><em>val</em></td>
<td>define bit string constant</td>
</tr>
<tr>
<td>2.4</td>
<td><strong>dca</strong></td>
<td align="left"><em>opn</em></td>
<td>decrement address by one word</td>
</tr>
<tr>
<td>1.17</td>
<td><strong>dcv</strong></td>
<td align="left"><em>opn</em></td>
<td>decrement value by one</td>
</tr>
<tr>
<td>11.2</td>
<td><strong>dic</strong></td>
<td align="left"><em>integer</em></td>
<td>define integer constant</td>
</tr>
<tr>
<td>11.3</td>
<td><strong>drc</strong></td>
<td align="left"><em>real</em></td>
<td>define real constant</td>
</tr>
<tr>
<td>11.4</td>
<td><strong>dtc</strong></td>
<td align="left"><em>dtext</em></td>
<td>define text (character) constant</td>
</tr>
<tr>
<td>4.5</td>
<td><strong>dvi</strong></td>
<td align="left"><em>ops</em></td>
<td>divide integer</td>
</tr>
<tr>
<td>5.6</td>
<td><strong>dvr</strong></td>
<td align="left"><em>ops</em></td>
<td>divide real</td>
</tr>
<tr>
<td>13.1</td>
<td><strong>ejc</strong></td>
<td>eject</td>
<td>assembly listing</td>
</tr>
<tr>
<td>14.2</td>
<td><strong>end</strong></td>
<td>end</td>
<td>of assembly</td>
</tr>
<tr>
<td>1.13</td>
<td><strong>enp</strong></td>
<td align="left"><em>define</em></td>
<td>end of procedure</td>
</tr>
<tr>
<td>1.6</td>
<td><strong>ent</strong></td>
<td>*</td>
<td align="left"><em>val</em>          define entry point</td>
</tr>
<tr>
<td>12.1</td>
<td><strong>equ</strong></td>
<td align="left"><em>eqop</em></td>
<td>define symbolic value</td>
</tr>
<tr>
<td>1.15</td>
<td><strong>erb</strong></td>
<td align="left"><em>int,text</em></strong></td>
<td>assemble error code and branch</td>
</tr>
<tr>
<td>1.14</td>
<td><strong>err</strong></td>
<td align="left"><em>int,text</em></td>
<td>assemble error code</td>
</tr>
<tr>
<td>1.5</td>
<td><strong>esw</strong></td>
<td></td>
<td>end of switch list for bsw</td>
</tr>
<tr>
<td>5.19</td>
<td><strong>etx</strong></td>
<td align="left"><em>e</em></td>
<td>to the power in the real accum</td>
</tr>
<tr>
<td>1.12</td>
<td><strong>exi</strong></td>
<td>*</td>
<td>int         exit from procedure</td>
</tr>
<tr>
<td>12.2</td>
<td><strong>exp</strong></td>
<td align="left"><em>define</em></td>
<td>e<strong>xt</strong>ernal procedure</td>
</tr>
<tr>
<td>6.10</td>
<td><strong>flc</strong></td>
<td align="left"><em>w</em></td>
<td>fold character to upper case</td>
</tr>
<tr>
<td>2.3</td>
<td><strong>ica</strong></td>
<td align="left"><em>opn</em></td>
<td>increment address by one word</td>
</tr>
<tr>
<td>3.4</td>
<td><strong>icp</strong></td>
<td align="left"><em>increment</em></td>
<td>code pointer</td>
</tr>
<tr>
<td>1.16</td>
<td><strong>icv</strong></td>
<td align="left"><em>opn</em></td>
<td>increment value by one</td>
</tr>
<tr>
<td>4.11</td>
<td><strong>ieq</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if integer zero</td>
</tr>
<tr>
<td>1.4</td>
<td><strong>iff</strong></td>
<td align="left"><em>val,plbl</em></td>
<td>specify branch for bsw</td>
</tr>
<tr>
<td>4.12</td>
<td><strong>ige</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if integer non-negative</td>
</tr>
<tr>
<td>4.13</td>
<td><strong>igt</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if integer positive</td>
</tr>
<tr>
<td>4.14</td>
<td><strong>ile</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if integer negative or zero</td>
</tr>
<tr>
<td>4.15</td>
<td><strong>ilt</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if integer negative</td>
</tr>
<tr>
<td>4.16</td>
<td><strong>ine</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if integer non-zero</td>
</tr>
<tr>
<td>4.9</td>
<td><strong>ino</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if no integer overflow</td>
</tr>
<tr>
<td>12.3</td>
<td><strong>inp</strong></td>
<td align="left"><em>ptyp</em>,int</td>
<td>internal procedure</td>
</tr>
<tr>
<td>12.4</td>
<td><strong>inr</strong></td>
<td align="left"><em>internal</em></td>
<td>routine</td>
</tr>
<tr>
<td>4.10</td>
<td><strong>iov</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if integer overflow</td>
</tr>
<tr>
<td>8.5</td>
<td><strong>itr</strong></td>
<td align="left"><em>convert</em></td>
<td>integer to real</td>
</tr>
<tr>
<td>1.9</td>
<td><strong>jsr</strong></td>
<td align="left"><em>pnam</em></td>
<td>call procedure</td>
</tr>
<tr>
<td>6.3</td>
<td><strong>lch</strong></td>
<td align="left"><em>reg,opc</em></td>
<td>load character</td>
</tr>
<tr>
<td>2.15</td>
<td><strong>lct</strong></td>
<td align="left"><em>w</em>,<em>opv</em></td>
<td>load counter for loop</td>
</tr>
<tr>
<td>3.1</td>
<td><strong>lcp</strong></td>
<td align="left"><em>reg</em></td>
<td>load code pointer register</td>
</tr>
<tr>
<td>3.3</td>
<td><strong>lcw</strong></td>
<td align="left"><em>reg</em></td>
<td>load ne<strong>xt</strong> code word</td>
</tr>
<tr>
<td>4.1</td>
<td><strong>ldi</strong></td>
<td align="left"><em>ops</em></td>
<td>load integer</td>
</tr>
<tr>
<td>5.1</td>
<td><strong>ldr</strong></td>
<td align="left"><em>ops</em></td>
<td>load real</td>
</tr>
<tr>
<td>1.8</td>
<td><strong>lei</strong></td>
<td align="left"><em>x</em></td>
<td>load entry point id</td>
</tr>
<tr>
<td>5.20</td>
<td><strong>lnf</strong></td>
<td align="left"><em>natural</em></td>
<td>logorithm of real accum</td>
</tr>
<tr>
<td>7.6</td>
<td><strong>lsh</strong></td>
<td align="left"><em>w,val</em></td>
<td>left shift bit string</td>
</tr>
<tr>
<td>7.8</td>
<td><strong>lsx</strong></td>
<td align="left"><em>w,(x)</em></td>
<td>left shift indexed</td>
</tr>
<tr>
<td>9.4</td>
<td><strong>mcb</strong></td>
<td></td>
<td>move characters/words backwards</td>
</tr>
<tr>
<td>8.4</td>
<td><strong>mfi</strong></td>
<td>*</td>
<td align="left"><em>opn</em>,<em>plbl</em>    convert (<strong>IA</strong> ) to address value</td>
</tr>
<tr>
<td>4.3</td>
<td><strong>mli</strong></td>
<td align="left"><em>ops</em></td>
<td>multiply integer</td>
</tr>
<tr>
<td>5.5</td>
<td><strong>mlr</strong></td>
<td align="left"><em>ops</em></td>
<td>multiply real</td>
</tr>
<tr>
<td>1.19</td>
<td><strong>mnz</strong></td>
<td align="left"><em>opn</em></td>
<td>move non-zero</td>
</tr>
<tr>
<td>1.1</td>
<td><strong>mov</strong></td>
<td align="left"><em>opn</em>,<em>opn</em></td>
<td>move <em>ovn</em> to <em>opv</em></td>
</tr>
<tr>
<td>8.3</td>
<td><strong>mti</strong></td>
<td align="left"><em>opn</em></td>
<td>move address value to (<strong>IA</strong> )</td>
</tr>
<tr>
<td>9.1</td>
<td><strong>mvc</strong></td>
<td></td>
<td>move characters</td>
</tr>
<tr>
<td>9.2</td>
<td><strong>mvw</strong></td>
<td></em></td>
<td>move words</td>
</tr>
<tr>
<td>9.3</td>
<td><strong>mwb</strong></td>
<td></td>
<td>move words backwards</td>
</tr>
<tr>
<td>4.8</td>
<td><strong>ngi</strong></td>
<td></td>
<td>negate integer</td>
</tr>
<tr>
<td>5.9</td>
<td><strong>ngr</strong></td>
<td></td>
<td>negate hreal</td>
</tr>
<tr>
<td>7.9</td>
<td><strong>nzb</strong></td>
<td align="left"><em>w,plbl</em></td>
<td>jump if not all zero bits</td>
</tr>
<tr>
<td>7.2</td>
<td><strong>orb</strong></td>
<td align="left"><em>o,opw</em></td>
<td>or bit strings</td>
</tr>
<tr>
<td>6.1</td>
<td><strong>plc*</strong></td>
<td align="left"><em>x</em>,<em>opv</em></td>
<td>prepare To load characters</td>
</tr>
<tr>
<td>1.10</td>
<td><strong>ppm*</strong></td>
<td align="left"><em>plbl</em></td>
<td>provide procedure exit parameter</td>
</tr>
<tr>
<td>1.11</td>
<td><strong>prc</strong></td>
<td align="left"><em>ptyp</em>,<em>val</em></td>
<td>define start of procedure</td>
</tr>
<tr>
<td>6.2</td>
<td><strong>psc</strong></td>
<td>*<em>x</em>,<em>opv</em></td>
<td>prepare to store characters</td>
</tr>
<tr>
<td>5.10</td>
<td><strong>req</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if real zero</td>
</tr>
<tr>
<td>5.11</td>
<td><strong>rge</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if real positive or zero</td>
</tr>
<tr>
<td>5.12</td>
<td><strong>rgt</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if real positive</td>
</tr>
<tr>
<td>5.13</td>
<td><strong>rle</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if real negative or zero</td>
</tr>
<tr>
<td>5.14</td>
<td><strong>rlt</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if real negative</td>
</tr>
<tr>
<td>4.6</td>
<td><strong>rmi</strong></td>
<td align="left"><em>ops</em></td>
<td>remainder integer</td>
</tr>
<tr>
<td>5.15</td>
<td><strong>rne</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if real non-zero</td>
</tr>
<tr>
<td>5.8</td>
<td><strong>rno</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if no real overflow</td>
</tr>
<tr>
<td>5.7</td>
<td><strong>rov</strong></td>
<td align="left"><em>plbl</em></td>
<td>jump if real overflow</td>
</tr>
<tr>
<td>7.5</td>
<td><strong>rsh</strong></td>
<td align="left"><em>w,val</em></td>
<td>right shift bit string</td>
</tr>
<tr>
<td>7.7</td>
<td><strong>rsx</strong></td>
<td align="left"><em>w,(x)</em></td>
<td>right shift indexed</td>
</tr>
<tr>
<td>8.6</td>
<td><strong>rti*</strong></td>
<td align="left"><em>plbl</em></td>
<td>convert real to integer</td>
</tr>
<tr>
<td>1.22</td>
<td><strong>rtn</strong></td>
<td></td>
<td>define start of routine</td>
</tr>
<tr>
<td>4.4</td>
<td><strong>sbi</strong></td>
<td align="left"><em>ops</em></td>
<td>subtract integer</td>
</tr>
<tr>
<td>5.4</td>
<td><strong>sbr</strong></td>
<td align="left"><em>ops</em></td>
<td>subtract reals</td>
</tr>
<tr>
<td>6.4</td>
<td><strong>sch</strong></td>
<td>reg,<em>opc</em></td>
<td>store character</td>
</tr>
<tr>
<td>3.2</td>
<td><strong>scp</strong></td>
<td align="left"><em>reg</em></td>
<td>store code pointer</td>
</tr>
<tr>
<td>14.1</td>
<td><strong>sec</strong></td>
<td></td>
<td>define start of assembly section</td>
</tr>
<tr>
<td>5.21</td>
<td><strong>sin</strong></td>
<td></td>
<td>sine of real accum</td>
</tr>
<tr>
<td>5.22</td>
<td><strong>sqr</strong></td>
<td></td>
<td>square root of real accum</td>
</tr>
<tr>
<td>1.20</td>
<td><strong>ssl</strong></td>
<td><em>opw</em></td>
<td>subroutine stack load</td>
</tr>
<tr>
<td>1.21</td>
<td><strong>sss</strong></td>
<td><em>opw</em></td>
<td>subroutine stack store</td>
</tr>
<tr>
<td>4.7</td>
<td><strong>sti</strong></td>
<td align="left"><em>ops</em></td>
<td>store integer</td>
</tr>
<tr>
<td>5.2</td>
<td><strong>str</strong></td>
<td align="left"><em>ops</em></td>
<td>store real</td>
</tr>
<tr>
<td>2.2</td>
<td><strong>sub</strong></td>
<td align="left"><em>opn</em>,<em>opv</em></td>
<td>subtract address <em>opv</em> from <em>opn</em></td>
</tr>
<tr>
<td>5.23</td>
<td><strong>tan</strong></td>
<td></td>
<td>tangent of real accum</td>
</tr>
<tr>
<td>6.9</td>
<td><strong>trc</strong></td>
<td></td>
<td>translate character string</td>
</tr>
<tr>
<td>13.2</td>
<td><strong>ttl</strong></td>
<td align="left"><em>text</em></td>
<td>supply assembly title</td>
</tr>
<tr>
<td>8.1</td>
<td><strong>wtb</strong></td>
<td align="left"><em>reg</em></td>
<td>convert words to bytes</td>
</tr>
<tr>
<td>7.3</td>
<td><strong>xob</strong></td>
<td align="left"><em>opw,w</em></td>
<td>exclusive or bit strings</td>
</tr>
<tr>
<td>1.18</td>
<td><strong>zer</strong></td>
<td align="left"><em>opn</em></td>
<td>zeroise integer location</td>
</tr>
<tr>
<td>7.11</td>
<td><strong>zgb</strong></td>
<td align="left"><em>opn</em></td>
<td>zeroise garbage bits</td>
</tr>
<tr>
<td>7.10</td>
<td><strong>zrb</strong></td>
<td align="left"><em>w,plbl</em></td>
<td>jump if all zero bits</td>
</tr>
</table>

<h2>MINIMAL Instructions</h2>

<p>

       the following descriptions assume the definitions -

<pre>
       zeroe  <strong>equ</strong>  0
       unity  <strong>equ</strong>  1
</pre>

<h3>1-  Basic Instruction Set</h3>

<dl>1.1  <br><strong>mov</strong>   <em>opn</em>,<em>opn</em>

<dd>     move one word value

   <p>


<strong>mov</strong> causes the value of operand <em>opn</em> to be
set as the new contents of operand location <em>opv</em>. In the case
where <em>opn</em> is not an index register, any value which can
normally occupy a memory word (including a part of a multiword real or
integer value) can be transferred using <strong>mov</strong> if the
target location <em>opn</em> is an index register,
<strong>then</strong> <em>opv</em> must specify an appropriate one
word value or operand containing such an appropriate value.

<dt> 1.2  <strong>brn</strong>  <em>plbl</em>

<dd>        unconditional branch

<p>


<strong>brn</strong> causes control to be passed to the indicated
label in the program section.

<dt>1.3  <strong>bsw</strong>  x,val,<em>plbl</em>

<dd>
branch on switch value

<dt> 1.4  <strong>iff</strong>  val,<em>plbl</em>

<dd>provide branch for switch

<pre>
            <strong>iff</strong>  val,<em>plbl</em>     ...
            ...
            ...
</pre>

<dt>1.5  <strong>esw</strong>

<dd>end of branch switch table

<p>


<strong>bsw</strong> iff,<strong>esw</strong> provide a capability for
a switched branch similar to a fortran computed goto. The <em>val</em> on the
<strong>bsw</strong> instruction is the maximum number of branches.
the value in x ranges from zero up to but not including this maximum.
each <strong>iff</strong> provides a branch. <em>val</em> must be less than
that given on the bsw and control goes to <em>plbl</em> if the value
in x matches.  If the value in x does not correspond to any of the
<strong>iff</strong> entries, <strong>then</strong> control passes to
the <em>plbl</em> on the <strong>bsw</strong>.
<p> This <em>plbl</em>
operand may be omitted if there are no values missing from the list.

	    <p>


<strong>iff</strong> and <strong>esw</strong> may only be used in this
contextxt.  Execution of <strong>bsw</strong> may destroy the contents
of x.  The <strong>iff</strong> entries may be in any order and since
a translator may thus need to store and sort them, the comment field
is restricted in length (sec 11).
	    
<dt>1.6  <strong>ent</strong>  val

<dd>define program entry point

<p>

The symbol appearing in the label field is defined to be a program
entry point which can subsequently be used in conjunction with the
<strong>bri</strong> instruction, which provides the only means of
entering the code. It is illegal to fall into code identified by an
entry point. the entry symbol is assigned an address which need not be
a multiple of <strong>cfp$b</strong> but which must be in the range 0
le <strong>cfp$l</strong> and the address must not lie within the
address range of the allocated data area.  Furthermore, addresses of
successive entry points must be assigned in some ascending sequence so
that the address comparison instructions can be used to test the order
in which two entry points occur. The symbol <em>val</em> gives an identifying
value to the entry point which can be accessed with the
<strong>lei</strong> instruction.

	    <p>

Note - subject to the restriction below, <em>val</em> may be omitted if no such
identification is needed i.e.  
<p>If no <strong>lei</strong> references
the entry point. For this case, a translation optimisation is possible
in which no memory need be reserved for a null identification which is
never to be referenced, but only provided this is done so as not to
interfere with the strictly ascending sequence of entry point
addresses. To simplify this optimisation for all implementors, the
following restriction is observed

	    <blockquote>
                 <em>val</em> may only be omitted if the entry point is
                 separated from a following entry point by a
                 non-null MINIMAL code sequence.
</blockquote>

<p>

Entry point addresses are accessible only by use of literals
(=<em>elbl</em>, section 7) or <strong>dac</strong> constants (section
8-11.1).

<dt>1.7  <strong>bri</strong>   <em>opn</em>

<dd>         branch indirect

<p>

<em>opn</em> contains the address of a program entry point (see ent).
control is passed to the executable code starting at the entry point
address.  <em>opn</em> is left unchanged.

<dt>1.8  <strong>lei</strong>  x

<dd>           load entry point identification

<p>


X contains the address of an entry point for which an identifying
value was given on the the <strong>ent</strong> line.
<strong>lei</strong> replaces the contents of x by this value.

<dt>1.9  <strong>jsr</strong>  <em>pnam</em>

<dd>       call procedure <em>pnam</em>

<dt>1.10 <strong>ppm</strong>  <em>plbl</em>

<dd>        provide exit parameter

<pre>
            <strong>ppm</strong>  <em>plbl</em>         ...
            ...
            <strong>ppm</strong>  <em>plbl</em>         ...
</pre>

<p>


<strong>jsr</strong> causes control to be passed to the named
procedure. <em>pnam</em> is the label on a <strong>prc</strong>
statement elsewhere in the program section (see prc) or has been
defined using an <strong>exp</strong> instruction.  The
<strong>ppm</strong> exit parameters following the call give names of
program locations (<em>plbl</em>-s) to which alternative
<strong>exi</strong> returns of the called procedure may pass control.
They may optionally be replaced by error returns (see err). the number
of exit parameters following a <strong>jsr</strong> must equal the int
in the procedure definition. 

<p>The operand of <strong>ppm</strong> may
be omitted if the corresponding <strong>exi</strong> return is certain
not to be taken.

<dt>1.11 <strong>prc</strong>  <em>ptyp</em>,int

<dd>    define start of procedure

<p>


The symbol appearing in the label field is defined to be the name of a
procedure for use with <strong>jsr</strong> a procedure is a
contiguous section of instructions to which control may be passed with
a <strong>jsr</strong> instruction. This is the only way in which the instructions in a
procedure may be executed. 
<p>It is not permitted to fall into a
procedure.  All procedures should be named in section 0
<strong>inp</strong> statements.

<p>

int is the number of exit parameters (ppm-s) to be used in
<strong>jsr</strong> calls.

<p>

There are three possibilities for <em>ptyp</em>, each consisting of a
single letter as follows.

	    <dl>

   <dt>r

<dd>               recursive

<p>



The return point (one or more words) is stored on the stack as though
one or more <strong>mov</strong> ...,-(<strong>XS</strong> )

<dt>n

<dd>                non-recursive

<p>


The return point is to be stored either (1) in a local storage word
associated with the procedure and not directly available to the
program in any other manner or (2) on a subroutine link stack quite
distinct from the MINIMAL stack addressed by <strong>XS</strong> .

<p>It is an error to use the stack for n-links, since procedure parameters
or results may be passed via the stack.

	    <p>

If method (2) is used for links, error exits (erb,err) from a
procedure will necessitate link stack resetting. The
<strong>ssl</strong> and <strong>sss</strong> orders provided for this
may be regarded as no- <em>ops</em> for implementations using method
(1).


<dt>

<dd>               either

</dl>

<p>


The return point may be stored in either manner according to
efficiency requirements of the actual physical machine used for the
implementation. 
<p>Note that programming of <em>e</em> type procedures must be
independent of the actual implementation.

<p>

The actual form of the return point is undefined.  However, each word
stored on the stack for an r-type call must meet the following
requirements.


	    <ol>
<li>It can be handled as an address
                             and placed in an index register.

<li>

When used as an operand in an address comparison instruction, it must
not appear to lie within the allocated data area.

<li>It is not required to appear
                             to lie within the program section.
</ol>

<dt>1.12 <strong>exi</strong>  int

<dd>         exit from procedure
<p>


The <strong>ppm</strong> and <strong>err</strong> parameters following
a <strong>jsr</strong> are numbered starting from 1.
<strong>exi</strong> int causes control to be returned to the int-th
such param. <strong>exi</strong> 1 gives control to the <em>plbl</em>
of the first <strong>ppm</strong> after the <strong>jsr</strong> if
int is omitted, control is passed back past the last exit parameter
(or past the <strong> jsr</strong> if there are none). for r and e
type procedures, the stack pointer <strong>XS</strong> must be set to
its appropriate entry value before executing an <strong>exi</strong>
instruction.  In this case, <strong>exi</strong> removes return points
from the stack if any are stored there so that the stack pointer is
restored to its calling value.

<dt>1.13 <strong>enp</strong>

<dd>              define end of procedure body
<p>


<strong>enp</strong> delimits a procedure body and may not actually be
executed, hence it must have no label.

<dt>1.14 <strong>err</strong>  int,te<strong>xt</strong>

<dd>    provide error return
<p>


<strong>err</strong> may replace an exit parameter (ppm) in any
procedure call. the int argument is a unique error code in 0 to 899.
the te<strong>xt</strong> supplied as the other operand is arbitrary te<strong>xt</strong> in the
fortran character set and may be used in constructing a file of error
messages for documenting purposes or for building a direct access or
other file of messages to be used by the error handling code.

 <p>In the event that an <strong>exi</strong> attempts to return control via an
exit parameter to an <strong>err</strong> control is instead passed to
the first instruction in the error section (which follows the program
section) with the error code in <strong>WA</strong>.

<dt>1.15 <strong>erb</strong>  int,te<strong>xt</strong>

<dd>    error branch
<p>


This instruction resembles <strong>err</strong> except that it may
occur at any point where a branch is permitted.  It effects a transfer
of control to the error section with the error code in <strong>WA</strong>.

<dt>1.16 <strong>icv</strong>   <em>opn</em>

<dd>         increment value by one
<p>


<strong>icv</strong> increments the value of the operand by unity.  it
is equivalent to <strong>add</strong> <em>opn</em>,=unity

<dt>1.17 <strong>dcv</strong>   <em>opn</em>

<dd>         decrement value by one
<p>


<strong>dcv</strong> decrements the value of the operand by unity.  It
is equivalent to <strong>sub</strong> <em>opn=unity</em>

<dt>1.18 <strong>zer</strong>   <em>opn</em>

<dd>         zeroise  <em>opn</em>
<p>


<strong>zer</strong> is equivalent to <strong>mov</strong> =zeroe,
<em>opn</em>

<dt>1.19 <strong>mnz</strong>   <em>opn</em>

<dd>         move non-zero to  <em>opn</em>
<p>


Any non-zero collectable value may used, for which the opcodes <strong>bnz/bze</strong>
will branch/fail to branch.


<dt>1.20 <strong>ssl</strong>   <em>opw</em>

<dd>         subroutine stack load

<dt>1.21 <strong>sss</strong>   <em>opw</em>

<dd>         subroutine stack store
<p>


This pair of operations is provided to make possible the use of a
local stack to hold subroutine (s-r) return links for n-type
procedures. <strong>sss</strong> stores the s-r stack pointer in
<em>opw</em> and <strong>ssl</strong> loads the s-r stack pointer from
<em>opw</em>. 
<p>By using <strong>sss</strong> in the main program or on
entry to a procedure which should regain control on occurrence of an
<strong>err</strong> or <strong>erb</strong> and by use of
<strong>ssl</strong> in the error processing sections the s-r stack
pointer can be restored giving a link stack cleaned up ready for
resumed execution.  the form of the link stack pointer is undefined in
MINIMAL (it is likely to be a private register known to the
translator) and the only requirement is that it should fit into a
single full word.  <strong>ssl</strong> and <strong>sss</strong> are
no- <em>ops</em> if no private link stack is not used.

<dt>1.22 <strong>rtn</strong>

<dd>              define start of routine
<p>


A routine is a code chunk used for similar purposes to a procedure.
However it is entered by any type of conditional or unconditional
branch (not by <strong>jsr</strong>). on termination it passes control by a branch
(often <strong>bri</strong> through a code word) or even permits
control to drop through to another routine. No return link exists and
the end of a routine is not marked by an explicit opcode (compare
<code>enp</code> ).  All routines must be named in section 0
<strong>inr</strong> statements.  </dl>

<h3>2-  Operations on One Word Integer Values (addresses)</h3>

<dl>

<dt>2.1  <strong>add</strong>   <em>opv</em>,op

<dd>

    adds  <em>opv</em> to the value in  <em>opn</em> and
                             stores the result in  <em>opn</em>. undefined
                             if the result exceeds <strong>cfp$l</strong> .

<dt>2.2  <strong>sub</strong>   <em>opn</em>,<em>opv</em>

<dd>

subtracts <em>opv</em> from <em>opn</em>. stores the result in
<em>opn</em>. Undefined if the result is negative.

<dt>2.3  <strong>ica</strong>   <em>opn</em>

<dd>         increment address in  <em>opn</em>
<p>



equivalent to <strong>add</strong>  <em>opn</em>,*unity

<dt>2.4  <strong>dca</strong>   <em>opn</em>

<dd>

Decrement address in <em>opn</em> equivalent to <strong>sub</strong>
*unity,<em>opn</em>

<dt>2.5  <strong>beq</strong>   <em>opn</em>,<em>opv</em>,<em>plbl</em>

<dd> branch to <em>plbl</em>  <em>opn</em> eq  <em>opv</em>


<dt>2.6  <strong>bne</strong>   <em>opn</em>,<em>opv</em>,<em>plbl</em>


<dd>branch to <em>plbl</em>  <em>opn</em> ne  <em>opv</em>

<dt>2.7  <strong>bgt</strong>   <em>opn</em>,<em>opv</em>,<em>plbl</em>


<dd> branch to <em>plbl</em>  <em>opn</em> gt  <em>opv</em>

<dt>2.8  <strong>bge</strong>   <em>opn</em>,<em>opv</em>,<em>plbl</em>


<dd> branch to <em>plbl</em>  <em>opn</em> ge  <em>opv</em>

<dt>2.9  <strong>blt</strong>   <em>opn</em>,<em>opv</em>,<em>plbl</em>

<dd>branch to <em>plbl</em>  <em>opn</em> lt  <em>opv</em>

<dt>2.10 <strong>ble</strong>   <em>opn</em>,<em>opv</em>,<em>plbl</em>

<dd> branch to <em>plbl</em>  <em>opn</em> le  <em>opv</em>

<dt>2.11 <strong>blo</strong>   <em>opn</em>,<em>opv</em>,<em>plbl</em>

<dd> equivalent to <strong>blt</strong> or ble

<dt>2.12 <strong>bhi</strong>   <em>opn</em>,<em>opv</em>,<em>plbl</em>

<dd> equivalent to <strong>bgt</strong> or bge

<p>


The above instructions compare two address values as unsigned integer
values.  The <strong>blo</strong> and <strong>bhi</strong>
instructions are used in cases where the equal condition either does
not occur or can result either in a branch or no branch. This avoids
inefficient translations in some implementations.

<dt>2.13 <strong>bnz</strong>   <em>opn</em>,<em>plbl</em>

<dd>    Equivalent to <strong>bne</strong>  <em>opn</em>,=zeroe,<em>plbl</em>

<dt>2.14 <strong>bze</strong>   <em>opn</em>,<em>plbl</em>

<dd>    equivalent to <strong>beq</strong>  <em>opn</em>,=zeroe,<em>plbl</em>

<dt>2.15 <strong>lct</strong>  <em>w</em>,<em>opv</em>

<dd>       load counter for bct
<p>


<strong>lct</strong> loads a counter value for use with the bct
instruction. the value in <em>opv</em> is the number of lo
<em>ops</em> to be executed. 
<p>The value in <em>w</em> after this operation is an
undefined one word integer quantity.

<dt>2.16 <strong>bct</strong>  w,<em>plbl</em>

<dd>      branch and count
<p>



<strong>bct</strong> uses the counter value in w to branch the
required number of times and <strong>then</strong> finally to fall
through to the ne<strong>xt</strong> instruction. <strong>bct</strong> can only be used
following an appropriate <strong>lct</strong> instruction.  The value
in <em>w</em> after execution of <strong>bct</strong> is undefined.

<dt>2.17 <strong>aov</strong>   <em>opn</em>,<em>opv</em>,<em>plbl</em>

<dd> <strong>add</strong> with carry test

<p> adds  <em>opv</em> to the value in  <em>opn</em> and stores result in
             <em>opn</em>. Branches to <em>plbl</em> result exceeds <strong>cfp$l</strong> 
            with result in  <em>opn</em> undefined. cf. <strong>add</strong> 

<dt>2.18 <strong>bev</strong>   <em>opn</em>,<em>plbl</em>

<dd>     branch even

<dt>2.19 <strong>bod</strong>   <em>opn</em>,<em>plbl</em>

<dd>     branch odd
<p>


These operations are used only .cepp or .crpp is defined.  On some
implementations, a more efficient implementation is possible by noting
that address of blocks must always be a multiple of
<strong>cfp$b</strong>. We call such addresses even.  Thus return
address on the stack (.crpp) and entry point addresses (.cepp) can be
distinguished from block addresses they are forced to be odd (not a
multiple of <strong>cfp$b</strong> ).  <strong>bev</strong> and
<strong>bod</strong> branch according as operand is even or odd,
respectively.  </dl>

 <h3>3- Operations on the Code Pointer Register
(<strong>CP</strong> )</h3> <p>


The code pointer register provides a psuedo instruction counter for
use in an interpretor. It may be implemented as a real register or as
a memory location, but in either case it is separate from any other
register. the value in the code pointer register is always a word
address (i.e.  a one word integer which is a multiple of
<strong>cfp$b</strong> ).

<dl>
<dt>3.1  <strong>lcp</strong>   reg

<dd>         load code pointer register

<p>

This instruction causes the code pointer register to be set from the
value in <em>reg</em> which is unchanged

<dt>3.2  <strong>scp</strong>   reg

<dd>

Store code pointer register this instruction loads the current value
in the code pointer register into reg. (<strong>CP</strong> ) is
unchanged.

<dt>3.3  <strong>lcw</strong>  reg

<dd>load next code word

<p>

This instruction causes the word pointed to by <strong>CP</strong> to
be loaded into the indicated reg. The value in <strong>CP</strong> is
<strong>then</strong> incremented by one word.  Execution of
<strong>lcw</strong> may destroy <strong>XL</strong> .

<dt>3.4  <strong>icp</strong> 

<dd>              increment <strong>CP</strong>  by one word
<p>


On machines with more than three index registers, <strong>CP</strong>
can be treated simply as an index register.  In this case, the
following equivalences apply:

	    <pre>

            <strong>CP</strong>   <em>reg</em> is like <strong>mov</strong> reg,<strong>CP</strong> 
            <strong>CP</strong>   <em>reg</em> is like <strong>mov</strong> <strong>CP</strong> ,<em>reg</em>
            <strong>lcw</strong> <em>reg</em> is like <strong>mov</strong> (<strong>CP</strong> )+,<em>reg</em>
            <strong>CP</strong>      is like <strong>ica</strong> <strong>CP</strong> 

</pre>

Since <strong>lcw</strong> is allowed to destroy <strong>XL</strong> ,
the following implementation using a work location <strong>CP</strong>
$$$ can also be used.

<pre>
            <strong>CP</strong>    <em>reg</em>         <strong>mov</strong>  reg,<strong>CP</strong> $$$

            <strong>CP</strong>    <em>reg</em>         <strong>mov</strong>  <strong>CP</strong> $$$,<em>reg</em>

            <strong>lcw</strong>   <em>reg</em>         <strong>mov</strong>  <strong>CP</strong> $$$,<strong>XL</strong> 
                             <strong>mov</strong>  (<strong>XL</strong> )+,<em>reg</em>
                             <strong>mov</strong>  <strong>XL</strong> ,<strong>CP</strong> $$$

            i<strong>CP</strong>               <strong>ica</strong>  <strong>CP</strong> $$$
</pre>
</dl>

<h3>4-  Operations on Signed Integer Values</h3>

<dl>

<dt>4.1  <strong>ldi</strong>   <em>ops</em>

<dd>         load integer accumulator from  <em>ops</em>

<dt>4.2  <strong>adi</strong>   <em>ops</em>

<dd>         <strong>add</strong>  <em>ops</em> to integer accumulator

<dt>4.3  <strong>mli</strong>   <em>ops</em>

<dd>         multiply integer accumulator by  <em>ops</em>

<dt>4.4  <strong>sbi</strong>   <em>ops</em>

<dd>
subtract  <em>ops</em> from int accumulator

<dt>4.5  <strong>dvi</strong>   <em>ops</em>

<dd>         divide integer accumulator by  <em>ops</em>

<dt>4.6  <strong>rmi</strong>   <em>ops</em>

<dd>         set int accum to mod(intacc,<em>ops</em>)

<dt>4.7  <strong>sti</strong>   <em>ops</em>

<dd>         store integer accumulator at  <em>ops</em>

<dt>4.8  <strong>ngi</strong>

<dd>              negate the value in the integer
                             accumulator (change its sign)

<p>

The equation satisfied by operands and results of <strong>dvi</strong>
and <strong>rmi</strong> is

	    <pre>
                   div = qot *  <em>ops</em> + rem          where
            div = dividend in integer accumulator
            qot = quotient left in <strong>IA</strong>  by div
             <em>ops</em> = the divisor
            rem = remainder left in <strong>IA</strong>  by rmi
</pre>
<p>

The sign of the result of <strong>dvi</strong> is +
(<strong>IA</strong> ) and ( <em>ops</em>) have the same sign and is -
they have opposite signs. The sign of (<strong>IA</strong> ) is always
used as the sign of the result of rem.

	    <p>

Assuming in each case that <strong>IA</strong> contains the number
specified in parentheses and that seven and msevn hold +7 and -7 resp.
the algorithm is illustrated below.

	    <pre>
            (<strong>IA</strong>  = 13)
            <strong>dvi</strong>  seven       <strong>IA</strong>  = 1
            <strong>rmi</strong>  seven       <strong>IA</strong>  = 6
            <strong>dvi</strong>  msevn       <strong>IA</strong>  = -1
            <strong>rmi</strong>  msevn       <strong>IA</strong>  = 6
            (<strong>IA</strong>  = -13)
            <strong>dvi</strong>  seven       <strong>IA</strong>  = -1
            <strong>rmi</strong>  seven       <strong>IA</strong>  = -6
            <strong>dvi</strong>  msevn       <strong>IA</strong>  = 1
            <strong>rmi</strong>  msevn       <strong>IA</strong>  = -6
</pre>

<p>

The above instructions operate on a full range of signed integer
values. with the exception of <strong>ldi</strong> and
<strong>sti</strong> these instructions may cause integer overflow by
attempting to produce an undefined or out of range result in which
case integer overflow is set, The result in (<strong>IA</strong> ) is
undefined and the following instruction must be <strong>iov</strong>
or <strong>ino</strong>.
<p>Particular care may be needed on target
machines having distinct overflow and divide by zero conditions.

<dt>4.9  <strong>ino</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> no integer overflow

<dt>4.10 <strong>iov</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> integer overflow
<p>


These instructions can only occur immediately following an instruction
which can cause integer overflow (<strong>adi</strong>, <strong>sbi</strong>
<strong>mli</strong> <strong>dvi</strong> <strong>rmi</strong> ngi)
and test the result of the preceding instruction.
<strong>iov</strong> and <strong>ino</strong> may not have labels.

<dt>4.11 <strong>ieq</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>IA</strong> ) eq 0


<dt>4.12 <strong>ige</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>IA</strong> ) ge 0

<dt>4.13 <strong>igt</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>IA</strong> ) gt 0

<dt>4.14 <strong>ile</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>IA</strong> ) le 0


<dt>4.15 <strong>ilt</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>IA</strong> ) lt 0

<dt>4.16 <strong>ine</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>IA</strong> ) ne 0

<p>


The above conditional jump instructions do not change the contents of
the accumulator.
<p>On a ones complement machine, it is permissible to
produce negative zero in <strong>IA</strong> provided these
instructions operate correctly with such a value.  </dl>

 <h3>5- Operations on Real Values</h3> <dl>

<dt>5.1  <strong>ldr</strong>   <em>ops</em>

<dd>         load real accumulator from  <em>ops</em>

<dt>5.2  <strong>str</strong>   <em>ops</em>

<dd>         store real accumulator at  <em>ops</em>


<dt>5.3  <strong>adr</strong>   <em>ops</em>

<dd>         <strong>add</strong>  <em>ops</em> to real accumulator

<dt>5.4  <strong>sbr</strong>   <em>ops</em>

<dd>         subtract  <em>ops</em> from real accumulator


<dt>5.5  <strong>mlr</strong>   <em>ops</em>

<dd>         multiply real accumulator by  <em>ops</em>

<dt>5.6  <strong>dvr</strong>   <em>ops</em>

<dd>         divide real accumulator by  <em>ops</em>

<p>If the result of any of the above operations causes
            underflow, the result yielded is 0.0.
<p>

The result of any of the above operations is undefined or out of
range, real overflow is set, the contents of (<strong>ra</strong>) are undefined and
the following instruction must be either <strong>rov</strong> or
<strong>rno</strong>.

<p>Particular care may be needed on target machines
having distinct overflow and divide by zero conditions.

<dt>5.7  <strong>rov</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> real overflow

<dt>5.8  <strong>rno</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> no real overflow

<p>

These instructions can only occur immediately following an instruction
which can cause real overflow (<strong>adr</strong>,<strong>sbr</strong>
<strong>mlr</strong> <strong>dvr</strong>.

<dt>5.9 <strong>ngr</strong>

<dd>              negate real accum (change sign)

<dt>5.10 <strong>req</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>RA</strong> ) eq 0.0


<dt>5.11 <strong>rge</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>RA</strong> ) ge 0.0

<dt>5.12 <strong>rgt</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>RA</strong> ) gt 0.0


<dt>5.13 <strong>rle</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>RA</strong> ) le 0.0

<dt>5.14 <strong>rlt</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>RA</strong> ) lt 0.0

<dt>5.15 <strong>rne</strong>  <em>plbl</em>

<dd>        jump to <em>plbl</em> (<strong>RA</strong> ) ne 0.0

<p>

            The above conditional instructions do not affect
            the value stored in the real accumulator.
<p>
            On a ones complement machine, it is permissible to
            produce negative zero in <strong>RA</strong>  provided these
            instructions operate correctly with such a value.

<dt>5.16 <strong>atn</strong>

<dd>              arctangent of real accum


<dt>5.17 <strong>chp</strong>

<dd>              integer portion of real accum

<dt>5.18 <strong>cos</strong>

<dd>              cosine of real accum

<dt>5.19 <strong>etx</strong>

<dd>              e to the power in the real accum

<dt>5.20 <strong>lnf</strong>

<dd>              natural logorithm of real accum

<dt>5.21 <strong>sin</strong>

<dd>              sine of real accum

<dt>5.22 <strong>sqr</strong>

<dd>              square root of real accum

<dt>5.23 <strong>tan</strong>

<dd>              tangent of real accum


<p>

The above orders operate upon the real accumulator, and replace the
contents of the accumulator with the result. 

<p> The result of any of the above operations is undefined or out of
range, real overflow is set, the contents of (<strong>ra</strong>) are undefined and
the following instruction must be either <strong>rov</strong> or
<strong>rno</strong> 

</dl>
<h3>6-  Operations on Character Values</h3>

<dl>

<p>


Character operations employ the concept of a character pointer which
uses either index register <strong>XR</strong> or <strong>XL</strong>
(not <strong>XS</strong> ).


<p>

A character pointer points to a specific character in a string of
characters stored <strong>cfp$c</strong> chars to a word.

<p> The only
operations permitted on a character pointer are <strong>lch</strong>
and <strong>sch</strong>. In particular, a character pointer may not
even be moved with <strong>mov</strong> 
<p>

<dl>

<dt>restriction 1

<dd>

It is important when coding in MINIMAL to ensure that no action
occurring between the initial use of <strong>plc</strong> or
<strong>psc</strong> and the eventual clearing of <strong>XL</strong>
or <strong>XR</strong> on completion of character operations can
initiate a garbage collection. The latter of course could cause the
addressed characters to be moved leaving the character pointers
pointing to rubbish.

<dt>restriction 2.

<dd>

A further restriction to be observed in code handling character
strings, is that strings built dynamically should be right padded with
zero characters to a full word boundary to permit easy hashing and use
of <strong>ceq</strong> or <strong>cne</strong> in testing strings for
equality.

</dl>

<dt>6.1  <strong>plc</strong>  <em>x</em>,<em>opv</em>

<dd>       prepare ch ptr for <strong>lch</strong> <strong>cmc</strong> mvc,<strong>trc</strong> 
                             <strong>mcb</strong> 

<dt>6.2  <strong>psc</strong>  <em>x</em>,<em>opv</em>

<dd>       prepare char. ptr for <strong>sch</strong> <strong>mvc</strong> <strong>mcb</strong> 

<p>


<em>opv</em> can be omitted it is zero.  the char. initially addressed
is determined by the word address in x and the integer offset
<em>opv</em>.  There is an automatic implied offset of
<strong>cfp$f</strong> bytes.  <strong>cfp$f</strong> is used to
formally introduce into MINIMAL a value needed in translating these
opcodes which, since MINIMAL itself does not prescribe a string
structure in detail, depends on the choice of a data structure for
strings in the MINIMAL program.  e.g. <strong>cfp$b</strong> =
<strong>cfp$c</strong> = 3, <strong>cfp$f</strong> = 6, num01 = 1,
<strong>XL</strong> points to a series of 4 words, abc/def/ghi/jkl,
then <pre> <strong>plc</strong> <strong>XL</strong> ,=num01 </pre>
points to h.


<dt>6.3  <strong>lch</strong>  <em>reg</em>,<em>opc</em>

<dd>     load character into reg

<dt>6.4  <strong>sch</strong>  <em>reg</em>,<em>opc</em>

<dd>     store character from <em>reg</em>

<p>

These operations are defined such that the character is right
justified in register <em>reg</em> with zero bits to the left. After
<strong>lch</strong>.

<p>For example, it is legitimate to regard
<em>reg</em> as containing the ordinal integer corresponding to the
character.

             <em>opc</em> is one of the following three possibilities.

<ul>
<li>(x)  --            the character pointed to by the
                             character pointer in x. the
                             character pointer is not changed.

<li>(x)+  --             same character as (x) but the
                             character pointer is incremented
                             to point to the ne<strong>xt</strong> character
                             following execution.

<li>-(x)  --             the character pointer is decre-
                             mented before accessing the
                             character so that the previous
                             character is referenced.
</ul>

<dt>6.5  <strong>csc</strong>  x

<dd>           complete store characters


<p>

This instruction marks completion of a <strong>psc</strong>
sch,<strong>sch</strong> ...,sch sequence initiated by a
<strong>psc</strong> x instruction. No more <strong>sch</strong>
instructions using x should be obeyed until another
<strong>psc</strong> is obeyed. It is provided solely as an efficiency
aid on machines without character orders since it permits use of
register buffering of chars in sch sequences. Where
<strong>csc</strong> is not a no-op, it must observe restriction 2.
(e.g. in SPITBOL, <strong>alocs</strong> zeroises the last word of a string frame prior
to <strong>sch</strong> sequence being started so <strong>csc</strong>
must not nullify this action.)

<p>

The following instructions are used to compare two words containing
<strong>cfp$c</strong> characters. 
<p> Comparisons distinct from
<strong>beq</strong> <strong>bne</strong> are provided as on some target machines, the
possibility of the sign bit being set may require special action.
<p>
Note that restriction 2 above, eases use of these orders in testing
complete strings for equality, since whole word tests are possible.

<dt>6.6  <strong>ceq</strong>   <em>opw</em>,<em>opw</em>,<em>plbl</em>

<dd> jump to <em>plbl</em>  <em>opw</em> eq  <em>opw</em>

<dt>6.7  <strong>cne</strong>   <em>opw</em>,<em>opw</em>,<em>plbl</em>

<dd> jump to <em>plbl</em>  <em>opw</em> ne  <em>opw</em>

<dt>6.8  <strong>cmc</strong>  <em>plbl</em>,<em>plbl</em>

<dd>   compare characters

<p>
            <strong>cmc</strong> is used to compare two character strings. before
            executing <strong>cmc</strong>  registers are set up as follows.
<pre>
            (<strong>XL</strong> )             character ptr for first string
            (<strong>XR</strong> )             character pointer for second string
            (<strong>WA</strong>)             character count (must be .gt. zero)
</pre>

<p>


<strong>XL</strong> and <strong>XR</strong> should have been prepared
by <strong>plc</strong> control passes to first <em>plbl</em> the
first string is lexically less than the second string, and to the
second <em>plbl</em> the first string is lexically greater. 
<p>Control
passes to the following instruction the strings are identical. after
executing this instruction, the values of <strong>XR</strong> and
<strong>XL</strong> are set to zero and the value in (<strong>WA</strong>) is
undefined.

 <p> Arguments to <strong>cmc</strong> may be complete or
partial strings, so making optimisation to use whole word comparisons
difficult (dependent in general on shifts and masking).

<dt>6.9  <strong>trc</strong>

<dd>              translate characters

<p>

            <strong>trc</strong> is used to translate a character string using a
            supplied translation table. before executing <strong>trc</strong> the
            registers are set as follows.
<pre>
            (<strong>XL</strong> )             char ptr to string to be translated
            (<strong>XR</strong> )             char ptr to translate table
            (<strong>WA</strong>)             length of string to be translated
</pre>

<p>

<strong>XL</strong> and <strong>XR</strong> should have been prepared
by <strong>plc</strong> the translate table consists of
<strong>cfp$a</strong> contiguous characters giving the translations
of the <strong>cfp$a</strong> characters in the alphabet.

<p>On
completion, (<strong>XR</strong> ) and (<strong>XL</strong> ) are set
to zero and (<strong>WA</strong>) is undefined.

<dt>6.10 <strong>flc</strong>  w

<dd>           fold character to upper case

<p>

<strong>flc</strong> is used only .culc is defined. the character code
value in <em>w</em> is translated to upper case it corresponds to a lower case
character.  </dl> 

<h3>7- Operations on Bit String Values</h3>

<dl>

<dt>7.1  <strong>anb</strong>   <em>w</em>,<em>opw</em>

<dd>       and bit string values


<dt>7.2  <strong>orb</strong>   <emp>w</em>,<em>opw</em>

<dd>       or bit string values


<dt>7.3  <strong>xob</strong>   <em>w</em>,<em>opw</em>

<dd>       exclusive or bit string values


<p>

In the above operations, the logical connective is applied separately
to each of the <strong>cfp$n</strong> bits.  The result is stored in
the second operand location.

<dt>7.4  <strong>cmb</strong>  w

<dd>           complement all bits in  <em>opw</em>


<dt>7.5  <strong>rsh</strong>  w,val

<dd>       right shift by <em>val</em> bits


<dt>7.6  <strong>lsh</strong>  w,val

<dd>       left shift by <em>val</em> bits


<dt>7.7  <strong>rsx</strong>  w,(dx)

<dd>       right shift w number of bits in x


<dt>7.8  <strong>lsx</strong>  w,(x)

<dd>       left shift w number of bits in x

<p>

The above shifts are logical shifts in which bits shifted out are lost
and zero bits supplied as required. The shift count is in the range
0-<strong>cfp$n</strong> .


<dt>7.9  <strong>nzb</strong>  w,<em>plbl</em>

<dd>      jump to <em>plbl</em> w is not all zero bits.

<dt>7.10 <strong>zrb</strong>  w,<em>plbl</em>

<dd>      jump to <em>plbl</em> w is all zero bits


<dt>7.11 <strong>zgb</strong>   <em>opn</em>

<dd>         zeroise garbage bits

<p>

<em>opn</em> contains a bit string representing a word of characters
from a string or some function formed from such characters (e.g. as a
result of hashing).
<p> On a machine where the word size is not a multiple of the character size, some bits in <em>reg</em> may be undefined.  

<p>This opcode replaces such bits by the zero bit. <strong>zgb</strong>
is a no-op the word size is a multiple of the character size.

</dl>

<h3>8-  Conversion Instructions</h3>

<dl>

<p>

The following instructions provide for conversion between lengths in
bytes and lengths in words.


<dt>8.1  <strong>wtb</strong>  reg

<dd>         convert  <em>reg</em> from words to bytes.


<p>That is, multiply by <strong>cfp$b</strong> . this is
                             a no-op <strong>cfp$b</strong>  is one.

<dt>8.2  <strong>btw</strong>  reg

<dd>         convert  <em>reg</em> from bytes to words

<p>

By dividing <em>reg</em> by <strong>cfp$b</strong> discarding the
fraction. no-op <strong>cfp$b</strong> is one

<p>

The following instructions provide for conversion of one word integer
values (addresses) to and from the full signed integer format.

<dt>8.3  <strong>mti</strong>   <em>opn</em>

<dd>

The value of <em>opn</em> (an address) is moved as a positive integer
to the integer accumulator.

<dt>8.4  <strong>mfi</strong>   <em>opn</em>,<em>plbl</em>

<dd>

The value currently stored in the integer accumulator is moved to
<em>opn</em> as an address it is in the range 0 to
<strong>cfp$m</strong> inclusive.  The accumulator value is outside
this range, <strong>then</strong> the result in <em>opn</em> is
undefined and control is passed to <em>plbl</em>. <strong>mfi</strong>
destroys the value of (ia) whether or not integer overflow is
signalled.  <em>plbl</em> may be omitted overflow is impossible.

<p>
            The following instructions provide for conversion
            between real values and integer values.

<dt>8.5  <strong>itr</strong>

<dd>

Convert integer value in integer accumulator to real and store in real
accumulator (may lose precision in some cases)

<dt>8.6  <strong>rti</strong>  <em>plbl</em>

<dd>

Convert the real value in ra to an integer and place result in
<strong>IA</strong> .  Conversion is by truncation of the fraction -
no rounding occurs.  

<p>Jump to <em>plbl</em> out of range. (ra) is not
changed in either case.  

<p><em>plbl</em> may be omitted overflow is impossible.

<p>

The following instructions provide for computing the length of storage
required for a te<strong>xt</strong> string.

<dt>8.7  <strong>ctw</strong>  w,val

<dd>

This instruction computes the sum (number of words required to store w
characters) + (val). the sum is stored in w. 

<p>For example,
<strong>cfp$c</strong> is 5, and <strong>WA</strong> contains 32, <strong>then</strong>
<strong>ctw</strong> <strong>WA</strong>,2 gives a result of 9 in <strong>WA</strong>.

<dt>8.8  <strong>ctb</strong>  w,val

<dd>       <strong>ctb</strong> is exactly like <strong>ctw</strong> except that
                             the result is in bytes. it has the
                             same effect as <strong>ctw</strong> w,<em>val</em>  <strong>wtb</strong> w
<p>

The following instructions provide for conversion from
integers to and from numeric digit characters for use in numeric
conversion routines. They employ negative integer values to allow for
proper conversion of numbers which cannot be complemented.


<dt>8.9  <strong>cvm</strong>  <em>plbl</em>

<dd>        convert by multiplication

<p>


The integer accumulator, which is zero or negative, is multiplied by
10. <strong>WB</strong> contains the character code for a digit. the
value of this digit is then subtracted from the result. the result is
out of range, <strong>then</strong> control is passed to <em>plbl</em>
with the result in (<strong>IA</strong> ) undefined. execution of
<strong>cvm</strong> leaves the result in (<strong>WB</strong> )
undefined.


<dte>8.10 cvd

<dd>              convert by division

<p>


The integer accumulator, which is zero or negative, is divided by 10.
the quotient (zero or negative) is replaced in the accumulator. The
remainder is converted to the character code of a digit and placed in
<strong>WA</strong>. For example, an operand of -523 gives a quotient of -52 and a
remainder in <strong>WA</strong> of ch$d3.

</dl>
<h3>9-  Block Move Instructions</h3>

<dl>

<p>

The following instructions are used for transferring data from one
area of memory to another in blocks.  They can be implemented with the
indicated series of other macro-instructions, but more efficient
implementations will be possible on most machines.


<p>

Note that in the equivalent code sequence shown below, a zero
value in <strong>WA</strong> will move at least one item, and may may wrap the counter
causing a core dump in some imple- mentations.  Thus <strong>WA</strong> should be .gt.
0 prior to invoking any of these block move instructions.

<dt>9.1  <strong>mvc</strong>

<dd>              move characters

<p>


Before obeying this order <strong>WA</strong>,<strong>XL</strong> ,<strong>XR</strong>
should have been set up, the latter two by <strong>plc</strong>
<strong>psc</strong> resp.  <strong>mvc</strong> is equivalent to the
sequence
	    
<pre>
                   <strong>mov</strong>  <strong>WB</strong> ,dumpb
                   <strong>lct</strong>  <strong>WA</strong>,<strong>WA</strong>
            lo <em>opc</em>  <strong>lch</strong>  <strong>WB</strong> ,(<strong>XL</strong> )+
                   <strong>sch</strong>  <strong>WB</strong> ,(<strong>XR</strong> )+
                   <strong>bct</strong>  <strong>WA</strong>,lo <em>opc</em>
                   <strong>csc</strong>  <strong>XR</strong> 
                   <strong>mov</strong>  dumpb,<strong>WB</strong> 

</pre>

<p>

The character pointers are bumped as indicated and the final value of
<strong>WA</strong> is undefined.


<dt>9.2  <strong>mvw</strong>

<dd>              move words

<p>

            <strong>mvw</strong> is equivalent to the sequence

<pre>
             <em>opw</em>  <strong>mov</strong>  (<strong>XL</strong> )+,(<strong>XR</strong> )+
                   <strong>dca</strong>  <strong>WA</strong>               <strong>WA</strong> = bytes to move
                   <strong>bnz</strong>  <strong>WA</strong>,lo <em>opw</em>

</pre>

<p>

Note that this implies that the value in <strong>WA</strong> is the length in bytes
which is a multiple of <strong>cfp$b</strong> .  

<p>The initial addresses in <strong>XR</strong> ,<strong>XL</strong> are word addresses.  as indicated, the final <strong>XR</strong> ,<strong>XL</strong> values
point past the new and old regions of memory respectively.

<p>The final value of <strong>WA</strong> is undefined.  <strong>WA</strong>,<strong>XL</strong> ,<strong>XR</strong>
must be set up before obeying <strong>mvw</strong> 

<dt>9.3  <strong>mwb</strong> 

<dd>              move words backwards

<p>

            <strong>mwb</strong>  is equivalent to the sequence

<pre>
            loopb  <strong>mov</strong>  -(<strong>XL</strong> ),-(<strong>XR</strong> )
                   <strong>dca</strong>  <strong>WA</strong>               <strong>WA</strong> = bytes to move
                   <strong>bnz</strong>  <strong>WA</strong>,loopb
</pre>

<p>

There is a requirement that the initial value in <strong>XL</strong>
be at least 256 less than the value in <strong>XR</strong> . this
allows an implementation in which chunks of 256 bytes are moved
forward (IBM 360, ICL 1900).  

<p>The final value of <strong>WA</strong> is undefined.

<p>
<strong>WA</strong> ,<strong>XL</strong> , <strong>XR</strong> must be
set up before obeying <strong>MWB</strong> .

<dt>9.4  <strong>mcb</strong>

<dd>

              move characters backwards

<p>

            <strong>mcb</strong> is equivalent to the sequence

<pre>
                   <strong>mov</strong>  <strong>WB</strong> ,dumpb
                   <strong>lct</strong>  <strong>WA</strong>,<strong>WA</strong>
            lo <em>opc</em>  <strong>lch</strong>  <strong>WB</strong> ,-(<strong>XL</strong> )
                   <strong>sch</strong>  <strong>WB</strong> ,-(<strong>XR</strong> )
                   <strong>bct</strong>  <strong>WA</strong>,lo <em>opc</em>
                   <strong>csc</strong>  <strong>XR</strong> 
                   <strong>mov</strong>  dumpb,<strong>WB</strong> 
</pre>

<p>


There is a requirement that the initial value in <strong>XL</strong>
be at least 256 less than the value in <strong>XR</strong> . this
allows an implementation in which chunks of 256 bytes are moved
forward (IBM 360, ICL 1900).  

<p>The final value of <strong>WA</strong> is undefined.
<strong>WA</strong>,<strong>XL</strong> ,<strong>XR</strong> must be set up before
obeying <strong>mcb</strong> 

</dl>

<h3>10- Operations Connected with the Stack</h3>

<dl>

<p>


The stack is an area in memory which is dedicated for use in
conjunction with the stack pointer register (<strong>XS</strong> ). As
previously described, it is used by the <strong>jsr</strong> and <strong>exi</strong>
instructions and may be used for storage of any other data as
required.

<p>

The stack builds either way in memory and an important restriction is
that the value in (<strong>XS</strong> ) must be the address of the
stack front at all times since some implementations may randomly
destroy stack locations beyond (<strong>XS</strong> ).  <p>


The starting stack base address is passed in (<strong>XS</strong> ) at
The start of execution. During execution it is necessary to make sure
that the stack does not overflow. This is achieved by executing the
following instruction periodically.


</dl>

<dt>10.1 <strong>chk</strong>

<dl>

<dd>              check stack overflow

<p>

After successfully executing <strong>chk</strong> it is permissible to
use up to 100 additional words before issuing another chk thus
<strong>chk</strong> need not be issued every time the stack is
expanded. In some implementations, the checking may be automatic and
<strong>chk</strong> will have no effect. 

<p>Following the above rule makes sure that the program 
will operate correctly in implementations with no automatic check.

<p>

Stack overflow occurs (detected either automatically or by a
<strong>chk</strong> instruction), <strong>then</strong> control is
passed to the stack overflow section (see program form). 

<p>Note that this transfer may take place following any instruction which stores
data at a new location on the stack.  After stack overflow, stack is
arbitrarily popped to give some space in which the error procedure may
operate. otherwise a loop of stack overflows may occur.

</dl>
<h3>11- Data Generation Instructions</h3>

<dl>
<p>


The following instructions are used to generate constant values in the
constant section and also to assemble initial values in the working
storage section. They may not appear except in these two sections.

<dt>11.1 <strong>dac</strong>  addr

<dd>        assemble address constant.


<p>

Generates one word containing the specified one word integer value
(address).


<dt>11.2 <strong>dic</strong>  integer

<dd>

Generates an integer value which occupies <strong>cfp$i</strong>
consecutive words.  The operand is a digit string with a required
leading sign.

<dt>11.3 <strong>drc</strong>  real

<dd>

Assembles a real constant which occupies <strong>cfp$r</strong>
consecutive words.  The operand form must obey the rules for a fortran
real constant with the extra requirement that a leading sign be
present.


<dt>11.4 <strong>dtc</strong>  <em>dte<strong>xt</strong></em>

<dd>       define <em>text</em> constant.

<p>


<strong>Text</strong> is started and ended with any character not contained in the
characters to be assembled. The constant occupies consecutive words as
dictated by the configuration parameter <strong>cfp$c</strong> . 

<p>Any unused chars in the last word are right filled with zeros (i.e. the
character whose internal code is zero).  The string contains a
sequence of letters, digits, blanks and any of the following special
characters.  =,$.(*)/+-

			     <p>
                             no other characters
                             may be used in a <em>dte<strong>xt</strong></em> operand.

<dt>11.5 <strong>dbc</strong>  val

<dd>         assemble bit string constant.

<p>

The operand is a positive integer value which is interpreted in
binary, right justified and left filled with zero bits. Thus 5 would
imply the bit string value 00...101.  </dl>

<h3>12- Symbol Definition Instructions</h3>

<dl>

<p>

The following instruction is used to define symbols in the definitions
section. It may not be used elsewhere.

<dt>12.1 <strong>equ</strong>  <em>eqop</em>

<dd>        define symbol

<p>


The symbol which appears in the label field is defined to
have the absolute value given by the <em>eqop</em> operand. A given
symbol may be defined only once in this manner, and any symbols
occuring in <em>eqop</em> must be previously defined.  <p>

            the following are the possibilities for <em>eqop</em>

<dl>

<dt>val

<dd>             the indicated value is used


<dt> val+val

<dd>

The sum of the two values is used.  This sum must not exceed
<strong>cfp$m</strong> 

<dt>val-val

<dd>

The difference between the two values (must be positive) is used.

<dt>*

<dd>

This format defines the label by using a value supplied by the MINIMAL
translator. Values are required for the

			     <pre>
            <strong>cfp$x</strong>             (configuration parameters)
            e$xxx            (environment parameters)
            ch$xx            (character codes).
</pre>

<p>

In order for a translator to handle this format correctly the
definitions section must be consulted for details of required symbols
as listed at the front of the section.
</dl>

<p> 
The following instructions may be used to define symbols in the
procedure section. They may not be used in any other part of the
program.


<dt>12.2 <strong>exp</strong>

<dd>              define e<strong>xt</strong>ernal procedure

<p>

            <strong>exp</strong> defines the symbol appearing in the
label field to be the name of an e<strong>xt</strong>ernal procedure which can be
referenced in a subsequent <strong>jsr</strong> instruction. The
coding for the procedure is external to the coding of the source
program in this language.  The code for external procedures may be
referred to collectively as the operating system interface, or more
briefly, osint, and will frequently be a separately compiled segment
of code loaded with SPITBOL to produce a complete system.

<dt>12.3 <strong>inp</strong>  <em>ptyp</em>,int

<dd>    define internal procedure


<p>


            <strong>inp</strong> defines the symbol appearing in the
label field to be the name of an internal procedure and gives its type
and number of exit parameters. the label can be referenced in
<strong>jsr</strong> instructions and it must appear labelling a
<strong>prc</strong> instruction in the program section.

<dt>12.4 <strong>inr</strong>

<dd>              define internal routine

<p>

            <strong>inr</strong> defines the symbol appearing in the
label field to be the name of an internal routine. 

<p>The label may be referenced in any type of branch order and it must appear labelling a
<strong>rtn</strong> instruction in the program section. 

</dl>

<h2>13 - Assembly Listing Layout Instruction</h2>

<dl>
<dt>13.1 <strong>ejc</strong>

<dd>              eject to ne<strong>xt</strong> page




<dt>13.2 <strong>ttl</strong>  te<strong>xt</strong>

<dd>        set new assembly title


<p>

<strong>ttl</strong> implies an immediate eject of the assembly
listing to print the new title.  <p>

The use of <strong>ttl</strong> and <strong>ejc</strong> cards is such
that the program will list neatly the printer prints as many as 58
lines per page. In the event that the printer depth is less than this,
or the listing contains interspersed lines (such as actual generated
code), then the format may be upset.  <p>

Lines starting with an asterisk are comment lines which cause no code
to be generated and may occur freely anywhere in the program. The
format for comment lines is given in section -15-.

<p>

Lines starting with left set brace, '{', begin a block comment that
continues up to and includind the first following line that begins
with a right set brace, '}'. Any statements such as instructions or
conditional assembly within the body of the block comment will not be
recognized as such.

</dl>

<h3>14 - Program Form</h3>

<p>

The program consists of separate sections separated by
<strong>sec</strong> operations. The sections must appear in the
following specified order.

</dl>

<dt>14.1 <strong>sec</strong>

<dl>

<pre>
            start of procedure section

            (procedure section)

            <strong>sec</strong>               start of definitions section

            (definitions section)

            <strong>sec</strong>               start of constant storage section

            (constant storage section)

            <strong>sec</strong>               start of working storage section

            (working storage section)

            <strong>sec</strong>               start of program section

            (program section)

            <strong>sec</strong>               start of stack overflow section

            (stack overflow section)

            <strong>sec</strong>               start of error section

            (error section)

</pre>

<dt>14.2 <strong>end</strong>

<dd>              end of assembly


</dl>

<h2>Section 10 - Program Form</h2>

<dl>
<dt>procedure section

<dd>

The procedure section contains all the exp instructions for e<strong>xt</strong>ernally
available procedures and <strong>inp</strong> inr opcodes for internal
procedures,routines so that a single pass MINIMAL translator has
advance knowledge of procedure types when translating calls.

	    <p>
<dt>definitions section

<dd>

The definitions section contains <strong>equ</strong> instructions
which define symbols referenced later on in the program, constant and
work sections.

<br> <dt>constant storage section

<dd>

The constant storage section consists entirely of constants assembled
with the <strong>dac</strong> dic,<strong>drc</strong> dtc,dbc
assembly operations. these constants can be freely referenced by the
program instructions.  

<br> 

<dt>working storage section

<dd>

The working storage section consists entirely of <strong>dac</strong>
dic,<strong>drc</strong> <strong>dbc</strong> dtc instructions to
define a fixed length work area. The work locations in this area can
be directly referenced in program instructions.  The area is
initialized in accordance with the values assembled in the
instructions.  

<br> 

<dt>program section

<dd>

The program section contains program instructions and associated
operations (such as <strong>prc</strong> <strong>enp</strong> <strong>ent</strong>).

<p>
Control is passed to the first instruction in this section when
execution is initiated.

<dt>stack overflow section

<p>
<dd>

The stack overflow section contains instructions like the program
section. 

<p>Control is passed to the first instruction in this section
following the occurrence of stack overflow, see <strong>chk</strong>
instruction.  

<dt>error section

<dd>

The error section contains instructions like the program section.

<p>Control is passed to the first instruction in this section when a
procedure exit corresponds to an error parameter (see err) or when an
<strong>erb</strong> opcode is obeyed. 

<p>The error code must clean up the main stack and cater for 
the possibility that a subroutine stack may need clean up.

<dt>osint

<dd>

Though not part of the MINIMAL source, it is useful to refer to the
collection of initialisation and <strong>exp</strong> routines as
osint (operating system interface).

<p>  Errors occurring within osint
procedures are usually handled by making an error return. If this is
not feasible or appropriate, osint may use the MINIMAL error section
to report errors directly by branching to it with a suitable numeric
error code in <strong>WA</strong>.  </dl>

<h2>Section 11 - Statement Format</h2>

<dl>

<p>

All labels are exactly five characters long and start with three
letters (abcdefghijklmnopqrstuvwxy$) followed by two letters or
digits.  <p>

The letter z may not be used in MINIMAL symbols but $ is permitted.
<p>

For implementations where $ may not appear in the target code , a
simple substitution of z for $ may thus be made without risk of
producing non-unique symbols.  <p>

The letter z is however permitted in opcode mnemonics and in comments.

<p>MINIMAL statements are in a fixed format as follows.
<pre>
       cols 1-5              label any (else blank)

       cols 6-7              always blank

       cols 8-10             operation mnemonic

       cols 11-12            blanks

       cols 13-28            operand field, terminated by a
                             blank. may occasionally
                             e<strong>xt</strong>end past column 28.

       cols 30-64            comment. always separated from the
                             operand field by at least one blank
                             may occasionally start after column
                             30 the operand e<strong>xt</strong>ends past 28.
                             a special exception occurs for the
                             <strong>iff</strong> instruction, whose comment may
                             be only 20 characters long (30-49).

       cols 65 on            unused


       comment lines have the following format

       col 1                 asterisk

       cols 2-7              blank

       cols 8-64             arbitrary te<strong>xt</strong>, restricted to the
                             fortran character set.


       the fortran character set is a-z 0-9 =,$.(*)-/+
</pre>
</dl>
<h2>Section 12 - Program Execution</h2>

<dl>

<p>

Execution of the program begins with the first instruction in the
program section.

<p>

In addition to the fixed length memory regions defined by the
assembly, there are two dynamically allocated memory regions as
follows.

<dl>

<dt>data area

<dd>

This is an area available to the program for general storage of data
any data value may be stored in this area except instructions.

<p>In some implementations, it may be possible to increase the size of this
area dynamically by adding words at the top end with a call to a
system procedure.  

<dt>stack area <dd>

This region of memory holds the stack used for subroutine calls and
other storage of one word integer values (addresses). This is the
stack associated with index register <strong>XS</strong> .  <p>

The locations and sizes of these areas are specified by the values in
the registers at the start of program execution as follows.

<dl>

<dt>(<strong>XS</strong> )

<dd>

Address one past the stack base.  For example, if  <strong>XS</strong>
is 23456, a d-stack will occupy words 23455,23454,...  whereas a
u-stack will occupy 23457,23458,...

<dt>(<strong>XR</strong> )

<dd>Address of the first word in the data area

<dt>(<strong>XL</strong> )

<dd>Address of the last word in the data area.

<dt>(<strong>WA</strong>)

<dd>Initial stack pointer

<dt> (<strong>WB</strong> ,<strong>WC</strong> ,<strong>IA</strong> ,ra,<strong>CP</strong> )

<dd>zero
</dl>
<dl>

<p>

There is no explicit way to terminate the execution of a program. This
function is performed by an appropriate system procedure referenced
with the <strong>sysej</strong> instruction.


<h1>SPITBOL Operating System Interface (OSINT)</h1>

p>This section describes the operating system interface functions,
mostly written in C, the are used by MACRO SPITBOL for runtime
support,doing input/output, loading external functions, reading and
writing save files, reading and writing load modules, and so forth.

<h4><strong>sysax</strong> -- after execution</h4>

<p> If the conditional assembly symbol .csax is defined, this routine
is called immediately after execution and before printing of execution
statistics or dump output.

<p> The purpose of call is for the implementor to determine and if the
call is not required it will be omitted if .csax is undefined. in this
case <strong>sysax</strong> need not be coded.

<pre>
jsr  <strong>sysax</strong>            call after execution
</pre>
<h4>sysbs -- backspace file</h4>

<p> <strong>sysbs</strong> is used to implement the snobol4 function
backspace.

<p> If the conditional assembly symbol .cbsp is defined.  the meaning
is system dependent.  In general, backspace repositions the file one
record closer to the beginning of file, such that a subsequent read or
write will operate on the previous record.

<pre>

       (<strong>wa</strong>)                  pointer to <strong>fcblk</strong> or zero
       (<strong>xr</strong>)                  backspace argument (<strong>scblk</strong> pointer)
       jsr  <strong>sysbs</strong>            call to backspace
       ppm  loc              return here if file does not exist
       ppm  loc              return here if backspace not allowed
       ppm  loc              return here if i/o error
       (<strong>wa</strong>,<strong>wb</strong>)               destroyed
</pre>

<p> The second error return is used for files for which backspace is
not permitted. For example, it may be expected files on character
devices are in this category.

<h4><strong>sysbp</strong>  exp  0                define external entry point</h4>

<p> <strong>sysbp</strong> is not required in normal operation. It is
called as a breakpoint to assist in debugging.

<pre>
       jsr  <strong>sysbp</strong>            call to breakpoint
</pre>
<h4>sysbx -- before execution</h4>

sysbx  exp  0                define external entry point

<p> Called after initial SPITBOL compilation and before commencing
execution in case osint needs to assign files or perform other
necessary services.  osint may also choose to send a message to online
terminal (if any) indicating that execution is starting.

<pre>
       jsr  sysbx            call before execution starts
</pre>

<h4>sysci -- convert integer</h4>

<p><strong>sysci</strong> is an optional osint routine that causes
SPITBOL to call <strong>sysci</strong> to convert integer values to
strings, rather than using the internal SPITBOL conversion code.  

<p>This code may be less efficient on machines with hardware
conversion instructions and in such cases, It may be an advantage to
include <strong>sysci</strong>.  The symbol .cnci must be defined if
this routine is to be used.

<p> The rules for converting integers to strings are that positive
values are represented without any sign, and

<p> There are never any leading blanks or zeros, except in the case of
zero itself which is represented as a single zero digit.  Negative
numbers are represented with a preceeding minus sign.  There are never
any trailing blanks, and conversion cannot fail.

<pre>
       (ia)                  value to be converted
       jsr  <strong>sysci</strong>            call to convert integer value
       (<strong>xl</strong>)                  pointer to pseudo-<strong>scblk</strong> with string
</pre>

<h4><strong>syscb</strong> -- general string comparison function</h4>

<p> Provides string comparison determined by interface.  used for
international string comparison.


<pre>
       (<strong>xr</strong>)                  character pointer for first string
       (<strong>xl</strong>)                  character pointer for second string
       (<strong>wb</strong>)                  character count of first string
       (<strong>wa</strong>)                  character count of second string
       jsr  <strong>syscb</strong>            call to <strong>syscb</strong> function
       ppm  loc              string too long for <strong>syscb</strong>
       ppm  loc              first string lexically gt second
       ppm  loc              first string lexically lt second
       ---                   strings equal
       (<strong>xl</strong>)                  zero
       (<strong>xr</strong>)                  destroyed
</pre>

<h4><strong>syscr</strong> -- convert real</h4>

<p><strong>syscr</strong> is an optional osint routine that causes
SPITBOL to call <strong>syscr</strong> to convert real values to
strings, rather than using the internal SPITBOL conversion code.  

<p>This code may be desired on machines where the integer size is too
small to allow production of a sufficient number of significant
digits.  The symbol .cncr must be defined if this routine is to be
used.

<p>The rules for converting reals to strings are that positive values
are represented without any sign, and there are never any leading
blanks or zeros, except in the case of zero itself which is
represented as a single zero digit.  Negative numbers are represented
with a preceeding minus sign.  There are never any trailing blanks, or
trailing zeros in the fractional part.  conversion cannot fail.

<pre>
       (ra)                  value to be converted
       (<strong>wa</strong>)                  no. of significant digits desired
       (<strong>wb</strong>)                  conversion type:
                     negative for e-type conversion
                     zero for g-type conversion
                     positive for f-type conversion
       (<strong>ws</strong>)                  character positions in result <strong>scblk</strong>
       (<strong>xr</strong>)                  <strong>scblk</strong> for result
       jsr  <strong>syscr</strong>            call to convert real value
       (<strong>xr</strong>)                  result <strong>scblk</strong>
       (<strong>wa</strong>)                  number of result characters
</pre>

<h4><strong>sysdc</strong> -- date check</h4>

<p><strong>sysdc</strong> is called to check that the expiry date for
a trial version of SPITBOL is unexpired.

<pre>
       jsr  <strong>sysdc</strong>            call to check date
return only if date is ok
</pre>


<h4><strong>sysdm</strong>  exp  0                define external entry point</h4>

<p><strong>sysdm</strong> is called by a SPITBOL program call of
dump(n) with n ge 4.  Its purpose is to provide a core dump.  n could
hold an encoding of the start adrs for dump and amount to be dumped
e.g.  n = 256*a + s , s = start adrs in kilowords, a = kilowords to
dump

<pre>
(<strong>xr</strong>)                  parameter n of call dump(n)
       jsr  <strong>sysdm</strong>            call to enter routine

</pre>

<h4><strong>sysdt</strong> -- get current date</h4>

<p><strong>sysdt</strong> is used to obtain the current date. The
date is returned as a character string in any format appropriate to
the operating system in use. It may also contain the current time of
day. <strong>sysdt</strong> is used to implement the snobol4 function
date().

<pre>
       (<strong>xr</strong>)                  parameter n of call date(n)
       jsr  <strong>sysdt</strong>            call to get date
       (<strong>xl</strong>)                  pointer to block containing date
</pre>

<p>The format of the block is like an <strong>scblk</strong> except
that the first word need not be set. The result is copied into SPITBOL
dynamic memory on return.  <h4><strong>sysea</strong> -- inform osint
of compilation and runtime errors</h4>

<p>Provides means for interface to take special actions on errors

<pre>
       (<strong>wa</strong>)                  error code
       (<strong>wb</strong>)                  line number
       (<strong>ws</strong>)                  column number
       (<strong>xr</strong>)                  system stage
       (<strong>xl</strong>)                  file name (<strong>scblk</strong>)<
       jsr  <strong>sysea</strong>            call to <strong>sysea</strong> function
       ppm  loc              suppress printing of error message
       (<strong>xr</strong>)                  message to print (<strong>scblk</strong>) or 0

</pre>

<p><strong>sysea</strong> may not return if interface chooses to
retain control.  Closing files via the fcb chain will be the
responsibility of the interface.

<p>All registers must be preserved

<h4><strong>sysef</strong> -- eject file</h4>

<p><strong>sysef</strong> is used to write a page eject to a named
file. It may only be used for files where this concept makes sense.
Note that <strong>sysef</strong> is not normally used for the standard
output file (see <strong>sysep</strong>).

<pre>
       (<strong>wa</strong>)                  pointer to <strong>fcblk</strong> or zero
       (<strong>xr</strong>)                  eject argument (<strong>scblk</strong> pointer)
       jsr  <strong>sysef</strong>            call to eject file
       ppm  loc              return here if file does not exist
       ppm  loc              return here if inappropriate file
       ppm  loc              return here if i/o error
</pre>

<h4><strong>sysej</strong> -- end of job</h4>

<p><strong>sysef</strong> is used to write a page eject to a named
file. It may only be used for files where this concept makes sense.

<p>Note that <strong>sysef</strong> is not normally used for the
standard output file (see <strong>sysep</strong>).

<pre>
       (<strong>wa</strong>)                  pointer to <strong>fcblk</strong> or zero
       (<strong>xr</strong>)                  eject argument (<strong>scblk</strong> pointer)
       jsr  <strong>sysef</strong>            call to eject file
       ppm  loc              return here if file does not exist
       ppm  loc              return here if inappropriate file
       ppm  loc              return here if i/o error
</pre>

<h4><strong>sysej</strong> -- end of job</h4>

<p><strong>sysef</strong> is used to write a page eject to a named
file. It may only be used for files where this concept makes sense. 

<p>Note that <strong>sysef</strong> is not normally used for the
standard output file (see <strong>sysep</strong>).

<pre>
       (<strong>wa</strong>)                  pointer to <strong>fcblk</strong> or zero
       (<strong>xr</strong>)                  eject argument (<strong>scblk</strong> pointer)
       jsr  <strong>sysef</strong>            call to eject file
       ppm  loc              return here if file does not exist
       ppm  loc              return here if inappropriate file
       ppm  loc              return here if i/o error
</pre>

<h4><strong>sysej</strong> -- end of job</h4>

<p><strong>sysej</strong> is called once at the end of execution to
terminate the run. The significance of the abend and code values is
system dependent. In general, the code value should be made available
for testing, and the abend value should cause some post-mortem action
such as a dump.

<p>Note that <strong>sysej</strong> does not return to its caller.
See <strong>sysxi</strong> for details of <strong>fcblk</strong> chain

<pre>
       (<strong>wa</strong>)                  value of abend keyword
       (<strong>wb</strong>)                  value of code keyword
       (<strong>xl</strong>)                  o or pointer to head of <strong>fcblk</strong> chain
       jsr  <strong>sysej</strong>            call to end job
</pre>

<p>The following special values are used as codes in
(<strong>wb</strong>)

       <pre>
999  execution suppressed
998  standard output file full or unavailable in a <strong>sysxi</strong>
load module. in these cases (<strong>wa</strong>) contains the number
of the statement causing premature termination.
</pre>

<h4><strong>sysem</strong> -- get error message text</h4>

<p><strong>sysem</strong> is used to obtain the text of err, erb
calls in the source program given the error code number. It is allowed
to return a null string if this facility is unavailable.

<pre>
       (<strong>wa</strong>)                  error code number
       jsr  <strong>sysem</strong>            call to get text
       (<strong>xr</strong>)                  text of message
</pre>

<p>The returned value is a pointer to a block in
<strong>scblk</strong> format except that the first word need not be
set. The string is copied into dynamic memory on return.  if the null
string is returned either because <strong>sysem</strong> does not
provide error message texts or because <strong>wa</strong> is out of
range, SPITBOL will print the string stored in errtext keyword.

<h4><strong>sysen</strong> - endfile</h4>

<p><strong>sysen</strong> is used to implement the snobol4 function
endfile.  The meaning is system dependent. In general, endfile implies
that no further i/o operations will be performed, but does not
guarantee this to be the case. The file should be closed after the
call, a subsequent read or write may reopen the file at the start or
it may be necessary to reopen the file via <strong>sysio</strong>.

<pre>
       (<strong>wa</strong>)                  pointer to <strong>fcblk</strong> or zero
       (<strong>xr</strong>)                  endfile argument (<strong>scblk</strong> pointer)
       jsr  <strong>sysen</strong>            call to endfile
       ppm  loc              return here if file does not exist
       ppm  loc              return here if endfile not allowed
       ppm  loc              return here if i/o error
       (<strong>wa</strong>,<strong>wb</strong>)               destroyed
</pre>

<p>The second error return is used for files for which endfile is not
permitted. For example, it may be expected that the standard input and
output files are in this category.

<h4><strong>sysep</strong> -- eject printer page</h4>

<p><strong>sysep</strong> is called to perform a page eject on the
standard printer output file (corresponding to <strong>syspr</strong>
output).

<pre>
       jsr  <strong>sysep</strong>            call to eject printer output<
</pre>

    <h4><strong>sysex</strong> -- call external function</h4>

    <p><strong>sysex</strong> is called to pass control to an
external function previously loaded with a call to sysld.

<pre>
       (<strong>xs</strong>)                  pointer to arguments on stack
       (<strong>xl</strong>)                  pointer to control block (<strong>efblk</strong>)
       (<strong>wa</strong>)                  number of arguments on stack
       jsr  <strong>sysex</strong>            call to pass control to function
       ppm  loc              return here if function call fails
       ppm  loc              return here if insufficient memory
       ppm  loc              return here if bad argument type
       (<strong>xs</strong>)                  popped past arguments
       (<strong>xr</strong>)                  result returned
</pre>

<p>The arguments are stored on the stack with the last argument at
0(<strong>xs</strong>). On return, <strong>xs</strong> is popped past
the arguments.

<p>The form of the arguments as passed is that used in the SPITBOL
translator (see definitions and data structures section). The control
block format is also described (under <strong>efblk</strong>) in this
section.

<p>There are two ways of returning a result:

<ol>

   <li>Return a pointer to a block in dynamic storage. this block must
be in exactly correct format, including the first word. Only functions
written with intimate knowledge of the system will return in this
way.</li>

<li>String, integer and real results may be returned by pointing to a
pseudo-block outside dynamic memory.

<p>This block is in <strong>icblk</strong>, <strong>rcblk</strong> or
<strong>scblk</strong> format except that the first word will be
overwritten by a type word on return and so need not be correctly set.


<p>Such a result is copied into main storage before proceeding.
unconverted results may similarly be returned in a pseudo-block which
is in correct format including type word recognisable by garbage
collector since block is copied into dynamic memory.

</li>

</ol>

<h4>sysfc -- file control block routine</h4>

<p>See also <strong>sysio</strong>

<p>Input and output have three arguments referred to as an
input(variable name,file <em>arg1</em>,file <em>arg2</em>)
output(variable name,file <em>arg1</em>,file <em>arg2</em>)

<p>File <em>arg1</em> may be an integer or string used to identify an
i/o channel. It is converted to a string for checking.

<p>The exact significance of file <em>arg2</em> is not rigorously
prescribed but to improve portability, The scheme described in the
SPITBOL user manual should be adopted when possible. The preferred
form is

<pre>
a string _f_,r_r_,c_c_,i_i_,...,z_z_  where
_f_ is an optional file name which is placed first.
remaining items may be omitted or included in any order.

_r_ is maximum record length

_c_ is a carriage control character or character string

_i_ is some form of channel identification used in the
absence of _f_ to associate the variable
with a file allocated dynamically by jcl commands at
SPITBOL load time.

,...,z_z_ are additional fields.
</pre>

<p>If , (comma) cannot be used as a delimiter, .ciod should be defined
to introduce by conditional assembly another delimiter (see <pre>
iodel equ * </pre> early in definitions section).  <p>
<strong>sysfc</strong> is called when a variable is input or output
associated to check file <em>arg1</em> and file <em>arg2</em> and to
report whether an <strong>fcblk</strong> (file control block) is
necessary and if so what size it should be.

<p>This makes it possible for SPITBOL rather than osint to allocate
such a block in dynamic memory if required or alternatively in static
memory.

<p>The significance of an <strong>fcblk</strong> , if one is
requested, is entirely up to the system interface.

<p>The only restriction is that if the <strong>fcblk</strong> should
appear to lie in dynamic memory, pointers to it should be proper
pointers to the start of a recognisable and garbage collectable block
(this condition will be met if <strong>sysfc</strong> requests SPITBOL
to provide an <strong>fcblk</strong>).

<p>An option is provided for osint to return a pointer in
<strong>xl</strong> to an <strong>fcblk</strong> which it privately
allocated. This pointer will be made available when i/o occurs later.
private <strong>fcblk</strong>s may have arbitrary contents and
SPITBOL stores nothing in them.

<p>The requested size for an <strong>fcblk</strong> in dynamic memory
should allow a 2 word overhead for block type and length fields.

<p>Information subsequently stored in the remaining words may be
arbitrary if an xnblk (external non-relocatable block) is requested.

<p>If the request is for an <strong><strong>xr</strong>blk</strong>
(external relocatable block) the contents of words should be
collectable (i.e.  any apparent pointers into dynamic should be
genuine block pointers).


<p>These restrictions do not apply if an <strong>fcblk</strong> is
allocated outside dynamic or is not allocated at all.

<p>If an <strong>fcblk</strong> is requested, its fields will be
initialised to zero before entry to <strong>sysio</strong> with the
exception of words 0 and 1 in which the block type and length fields
are placed for <strong>fcblk</strong>s in dynamic memory only.

<p>For the possible use of <strong>sysej</strong> and
<strong>sysxi</strong>, if <strong>fcblk</strong>s are used, a chain
is built so that they may all be found - see <strong>sysxi</strong>
for details.


<p>If both file <em>arg1</em> and file <em>arg2</em> are null, calls
of <strong>sysfc</strong> and <strong>sysio</strong> are omitted.

<p>If file <em>arg1</em> is null (standard input/output file),
<strong>sysfc</strong> is called to check non-null file <em>arg2</em>
but any request for an <strong>fcblk</strong> will be ignored, since
SPITBOL handles the standard files specially and cannot readily keep
<strong>fcblk</strong> pointers for them.  <p>file <em>arg1</em> is
type checked by SPITBOL so further checking may be unneccessary in
many implementations.  file <em>arg2</em> is passed so that
<strong>sysfc</strong> may analyse and check it. however to assist in
this, SPITBOL also passes on the stack the components of this argument
with file name, _f_ (otherwise null) extracted and stacked first.

<p>The other fields, if any, are extracted as substrings, pointers to
them are stacked and a count of all items stacked is placed in
<strong>ws</strong>.

<p>If an <strong>fcblk</strong> was earlier
allocated and pointed to via file <em>arg1</em>,
<strong>sysfc</strong> is also passed a pointer to this
<strong>fcblk</strong>.  <pre> (<strong>xl</strong>) file
<em>arg1</em> <strong>scblk</strong> pointer (2nd arg)
(<strong>xr</strong>) file<em>arg2</em> (3rd arg) or null
-(<strong>xs</strong>)...-(<strong>xs</strong>)
<strong>scblk</strong>s for _f_,_r_,_c_,...  (<strong>ws</strong>) no.
of stacked <strong>scblk</strong>s above (<strong>wa</strong>)
existing file <em>arg1</em> <strong>fcblk</strong> pointer or 0
(<strong>wb</strong>) 0/3 for input/output assocn jsr
<strong>sysfc</strong> call to check need for <strong>fcblk</strong>
ppm loc invalid file argument ppm loc <strong>fcblk</strong> already
in use (<strong>xs</strong>) popped (<strong>ws</strong>) times
(<strong>wa</strong> non zero) byte size of requested
<strong>fcblk</strong> (<strong>wa</strong>=0,<strong>xl</strong> non
zero) private <strong>fcblk</strong> pointer in <strong>xl</strong>
(<strong>wa</strong>=<strong>xl</strong>=0) no <strong>fcblk</strong>
wanted, no private <strong>fcblk</strong> (<strong>ws</strong>) 0/1/2
request alloc of <strong><strong>xr</strong>blk</strong> /static block
for use as <strong>fcblk</strong> (<strong>wb</strong>) destroyed
</pre> <h4><strong>sysgc</strong> -- inform interface of garbage
collections</h4>

<p>Provides means for interface to take special actions prior to and
after a garbage collection.

<p>Possible usages- <ol> <li>provide visible screen icon of garbage
collection in progress.</li> <li>inform virtual memory manager to
ignore page access patterns during garbage collection.  such accesses
typically destroy the page working set accumulated by the
program.</li> <li>inform virtual memory manager that contents of
memory freed by garbage collection can be discarded.</li> </ol> <pre>
(<strong>xr</strong>) non-zero if beginning gc, =0 if completing gc
(<strong>wa</strong>) dnamb=start of dynamic area
(<strong>wb</strong>) dnamp=next available location
(<strong>ws</strong>) dname=last available location + 1 jsr
<strong>sysgc</strong> call to <strong>sysgc</strong> function

       all registers preserved
</pre>
<h4>syshs -- give access to host computer features</h4>

<p> Provides means for implementing special features on different host
computers.  the only defined entry is that where all arguments are
null in which case <strong>syshs</strong> <strong>syshs</strong>
returns an <strong>scblk</strong> containing name of computer, name of
operating system and name of site separated by colons. 

<p>The <strong>scblk</strong> need not have a correct first field as
this is supplied on copying string to dynamic memory.

<p> SPITBOL does no argument checking but does provide a single error
return for arguments checked as erroneous by osint.  It also provides
a single execution error return. 

<p>If these are inadequate, use may be made of the minimal error
section direct as described in minimal documentation, section 10.

<p>Several non-error returns are provided. the first
corresponds to the defined entry or, for implementation
defined entries, any string may be returned. the others
permit respectively,  return a null result, return with a
result to be stacked which is pointed at by <strong>xr</strong>, and a
return causing SPITBOL statement failure. 

<p>If a returned result is in dynamic memory it must obey garbage
collector rules. 

<p>The only results copied on return are strings returned via ppm loc3
return.

<pre>
       (<strong>wa</strong>)                  argument 1
       (<strong>xl</strong>)                  argument 2
       (<strong>xr</strong>)                  argument 3
       (<strong>wb</strong>)                  argument 4
       (<strong>ws</strong>)                  argument 5
       jsr  <strong>syshs</strong>            call to get host information
       ppm  loc1             erroneous arg
       ppm  loc2             execution error
       ppm  loc3             <strong>scblk</strong> pointer in <strong>xl</strong> or 0 if unavailable
       ppm  loc4             return a null result
       ppm  loc5             return result in <strong>xr</strong>
       ppm  loc6             cause statement failure
       ppm  loc7             return string at <strong>xl</strong>, length <strong>wa</strong>
       ppm  loc8             return copy of result in <strong>xr</strong>
</pre>

<h4><strong>sysid</strong> -- return system identification</h4>

<p>This routine should return strings to head the standard printer
output. the first string will be appended to a heading line of the
form

<pre>
    MACRO SPITBOL version v.v
</pre>

<p>Supplied by SPITBOL itself. v.v are digits giving the major version
number and generally at least a minor version number relating to osint
should be supplied to give say

<pre>
    MACRO SPITBOL version v.v(m.m)
</pre>

<p>The second string should identify at least the machine and
operating system.  preferably it should include the date and time of
the run.  optionally the strings may include site name of the the
implementor and/or machine on which run takes place, unique site or
copy number and other information as appropriate without making it so
long as to be a nuisance to users.  the first words of the
<strong>scblk</strong>s pointed at need not be correctly set.


<pre>
       jsr  <strong>sysid</strong>            call for system identification
       (<strong>xr</strong>)                  <strong>scblk</strong> pointer for addition to header
       (<strong>xl</strong>)                  <strong>scblk</strong> pointer for second header
</pre>

<h4><strong>sysif</strong> -- switch to new include file</h4>

<p><strong>sysif</strong> is used for include file processing, both to
inform the interface when a new include file is desired, and when the
end of file of an include file has been reached and it is desired to
return to reading from the previous nested file.

<p>It is the responsibility of <strong>sysif</strong> to remember the
file access path to the present input file before switching to the new
include file.  <pre> (<strong>xl</strong>) pointer to
<strong>scblk</strong> or zero (<strong>xr</strong>) pointer to vacant
<strong>scblk</strong> of length cswin (<strong>xr</strong> not used
if <strong>xl</strong> is zero) jsr <strong>sysif</strong> call to
change files ppm loc unable to open file (<strong>xr</strong>)
<strong>scblk</strong> with full path name of file </pre>

<p>Register <strong>xl</strong> points to an <strong>scblk</strong>
containing the name of the include file to which the interface should
switch.  Data is fetched from the file upon the next call to
<strong>sysrd</strong>.

<p><strong>sysif</strong> may have the ability to search multiple
libraries for the include file named in (<strong>xl</strong>).  It is
therefore required that the full path name of the file where the file
was finally located be returned in (<strong>xr</strong>).  It is this
name that is recorded along with the source statements, and will
accompany subsequent error messages.

<p>Register <strong>xl</strong> is zero to mark conclusion of use of
an include file.

<h4><strong>sysil</strong> -- get input record length</h4>

<p><strong>sysil</strong> is used to get the length of the next input
record from a file previously input associated with a
<strong>sysio</strong> call. The length returned is used to establish
a buffer for a subsequent <strong>sysin</strong> call.
<strong>sysil</strong> also indicates to the caller if this is a
binary or text file.

<pre>
       (<strong>wa</strong>)                  pointer to <strong>fcblk</strong> or zero
       jsr  <strong>sysil</strong>            call to get record length
       (<strong>wa</strong>)                  length or zero if file closed
       (<strong>ws</strong>)                  zero if binary, non-zero if text
</pre>

<p>No harm is done if the value returned is too long since unused
space will be reclaimed after the <strong>sysin</strong> call.

<p>Note that it is the <strong>sysil</strong> call (not the
<strong>sysio</strong> call) which causes the file to be opened as
required for the first record input from the file.

<h4>h<strong>sysin</strong> -- read input record</h4>

<p><strong>sysin</strong> is used to read a record from the file
which was referenced in a prior call to <strong>sysil</strong> (i.e.
these calls always occur in pairs). The buffer provided is an
<strong>scblk</strong> for a string of length set from the
<strong>sysil</strong> call.  If the actual length read is less than
this, the length field of the <strong>scblk</strong> must be modified
before returning unless buffer is right padded with zeroes.

<p>It is also permissible to take any of the alternative returns after
<strong>scblk</strong> length has been modified.

<pre>
       (<strong>wa</strong>)                  pointer to <strong>fcblk</strong> or zero
       (<strong>xr</strong>)                  pointer to buffer (<strong>scblk</strong> pointer)
       jsr  <strong>sysin</strong>            call to read record
       ppm  loc              endfile or no i/p file after <strong>sysxi</strong>
       ppm  loc              return here if i/o error
       ppm  loc              return here if record format error
       (<strong>wa</strong>,<strong>wb</strong>,<strong>ws</strong>)            destroyed
</pre>

<h4><strong>sysio</strong> -- input/output file association</h4>

<p>See also <strong>sysfc</strong>.

<p><strong>sysio</strong> is called in response to a snobol4 input or
output function call except when file <em>arg1</em> and file
<em>arg2</em> are both null.  Its call always follows immediately
after a call of <strong>sysfc</strong>. If <strong>sysfc</strong>
requested allocation of an <strong>fcblk</strong>, its address will be
in <strong>wa</strong>.  for input files, non-zero values of _r_
should be copied to <strong>ws</strong> for use in allocating input
buffers. If _r_ is defaulted or not implemented, <strong>ws</strong>
should be zeroised.

<p>Once a file has been opened, subsequent input(),output() calls in
which the second argument is identical with that in a previous call,
merely associate the additional variable name (first argument) to the
file and do not result in re-opening the file.

<p>In subsequent associated accesses to the file a pointer to any
<strong>fcblk</strong> allocated will be made available.

<pre>
       (<strong>xl</strong>)                  file <em>arg1</em> <strong>scblk</strong> pointer (2nd arg)
       (<strong>xr</strong>)                  file <em>arg2</em> <strong>scblk</strong> pointer (3rd arg)
       (<strong>wa</strong>)                  <strong>fcblk</strong> pointer (0 if none)
       (<strong>wb</strong>)                  0 for input, 3 for output
       jsr  <strong>sysio</strong>            call to associate file
       ppm  loc              return here if file does not exist
       ppm  loc              return if input/output not allowed
       (<strong>xl</strong>)                  <strong>fcblk</strong> pointer (0 if none)
       (<strong>ws</strong>)                  0 (for default) or max record lngth
       (<strong>wa</strong>,<strong>wb</strong>)               destroyed
</pre>

<p>The second error return is used if the file named exists but
input/output from the file is not allowed. For example, the standard
output file may be in this category as regards input association.

<h4>sysld -- load external function</h4>

<p><strong>sysld</strong> is called in response to the use of the snobol4 load
function. The named function is loaded (whatever this means), and a
pointer is returned. the pointer will be used on subsequent calls to
the function (see <strong>sysex</strong>).

<pre>
       (<strong>xr</strong>)                  pointer to function name (<strong>scblk</strong>)
       (<strong>xl</strong>)                  pointer to library name (<strong>scblk</strong>)
       jsr  sysld            call to load function
       ppm  loc              return here if func does not exist
       ppm  loc              return here if i/o error
       ppm  loc              return here if insufficient memory
       (<strong>xr</strong>)                  pointer to loaded code
</pre>

<p>The significance of the pointer returned is up to the system
interface routine. The only restriction is that if the pointer is
within dynamic storage, it must be a proper block pointer.

<h4><strong>sysmm</strong> -- get more memory</h4>

<p><strong>sysmm</strong> is called in an attempt to allocate more
dynamic memory. This memory must be allocated contiguously with the
current dynamic data area.

<p>The amount allocated is up to the system to decide. any value is
acceptable including zero if allocation is impossible.

<pre>
       jsr  <strong>sysmm</strong>            call to get more memory
       (<strong>xr</strong>)                  number of additional words obtained

</pre>

<h4><strong>sysmx</strong> -- supply <strong>m<strong>xl</strong>en</strong></h4>

<p>Because of the method of garbage collection, no SPITBOL object is
allowed to occupy more bytes of memory than the integer giving the
lowest address of dynamic (garbage collectable) memory.
<strong>m<strong>xl</strong>en</strong> is the name used to refer to
this maximum length of an object and for most users of most
implementations, provided dynamic memory starts at an address of at
least a few thousand words, there is no problem.

<p>If the default starting address is less than say 10000 or 20000,
then a load time option should be provided where a user can request
that he be able to create larger objects. This routine informs SPITBOL
of this request if any. the value returned is either an integer
representing the desired value of
<strong>m<strong>xl</strong>en</strong> (and hence the minimum dynamic
store address which may result in non-use of some store) or zero if a
default is acceptable in which <strong>m<strong>xl</strong>en</strong>
is set to the lowest address allocated to dynamic store before
compilation starts.

<p>If a non-zero value is returned, this is used for keyword
ma<strong>xl</strong>ngth. Otherwise the initial low address of
dynamic memory is used for this keyword.

<pre>
       jsr  <strong>sysmx</strong>            call to get <strong>m<strong>xl</strong>en</strong>
       (<strong>wa</strong>)                  either <strong>m<strong>xl</strong>en</strong> or 0 for default
</pre>

<h4><strong>sysou</strong> -- output record</h4>

<p><strong>sysou</strong> is used to write a record to a file previously
associated with a <strong>sysio</strong> call.

<pre>
       (<strong>wa</strong>)                  pointer to <strong>fcblk</strong> or 0 for terminal or 1 for output
       (<strong>xr</strong>)                  record to be written (<strong>scblk</strong>)
       jsr  <strong>sysou</strong>            call to output record
       ppm  loc              file full or no file after <strong>sysxi</strong>
       ppm  loc              return here if i/o error
       (<strong>wa</strong>,<strong>wb</strong>,<strong>ws</strong>)            destroyed
</pre>

<p>Note that it is the <strong>sysou</strong> call (not the
<strong>sysio</strong> call) which causes the file to be opened as
required for the first record output to the file.

<h4><strong>syspi</strong> -- print on interactive channel</h4>

<p>If SPITBOL is run from an online terminal, osint can request that
messages such as copies of compilation errors be sent to the terminal
(see <strong>syspp</strong>). if relevant reply was made by
<strong>syspp</strong> then <strong>syspi</strong> is called to send
such messages to the interactive channel.  <strong>syspi</strong> is
also used for sending output to the terminal through the special
variable name, terminal.  <pre> (<strong>xr</strong>) pointer to line
buffer (<strong>scblk</strong>) (<strong>wa</strong>) line length jsr
<strong>syspi</strong> call to print line ppm loc failure return
(<strong>wa</strong>,<strong>wb</strong>) destroyed </pre>

<h4><strong>syspl</strong> -- provide interactive control of SPITBOL</h4>

<p>Provides means for interface to take special actions, such as
interrupting execution, breakpointing, stepping, and expression
evaluation.  These last three options are not presently implemented by
the code calling <strong>syspl</strong>.

<pre>
       (<strong>wa</strong>)                  opcode as follows-
                             =0 poll to allow osint to interrupt
                             =1 breakpoint hit
                             =2 completion of statement stepping
                             =3 expression evaluation result
       (<strong>wb</strong>)                  statement number
       r_fcb                 o or pointer to head of <strong>fcblk</strong> chain
       jsr  <strong>syspl</strong>            call to <strong>syspl</strong> function
       ppm  loc              user interruption
       ppm  loc              step one statement
       ppm  loc              evaluate expression
       ---                   resume execution
                             (<strong>wa</strong>) = new polling interval
</pre>

<h4><strong>syspp</strong> -- obtain print parameters</h4>

<p><strong>syspp</strong> is called once during compilation to obtain
parameters required for correct printed output format and to select
other options. it may also be called again after
<strong>sysxi</strong> when a load module is resumed. in this case the
value returned in <strong>wa</strong> may be less than or equal to
that returned in initial call but may not be greater.

<p>
the information returned is -

<ol>

   <li>line length in chars for standard print file</li>

<li>no of lines/page. 0 is preferable for a non-paged device (e.g.
online terminal) in which case listing page throws are suppressed and
page headers resulting from -title,-stitl lines are kept short.</li>

 <li>an initial -nolist option to suppress listing unless the program
contains an explicit -list.</li>

 <li>options to suppress listing of compilation and/or execution stats
(useful for established programs) - combined with 3. gives possibility
of listing file never being opened.</li>

 <li>option to have copies of errors sent to an interactive channel in
addition to standard printer.</li>

 <li>option to keep page headers short (e.g. if listing to an online
terminal).</li>

 <li>an option to choose extended or compact listing format. in the
former a page eject and in the latter a few line feeds precede the
printing of each of-- listing, compilation statistics, execution
output and execution statistics.</li>

 <li>an option to suppress execution as though a -noexecute card were
supplied.</li>

 <li>an option to request that name /terminal/ be pre- associated to
an online terminal via <strong>syspi</strong> and
<strong>sysri</strong></li>

 <li>an intermediate (standard) listing option requiring that page
ejects occur in source listings. redundant if extended option chosen
but partially extends compact option.</li>

 <li>option to suppress <strong>sysid</strong> identification.</li>

</ol>
<pre>

       jsr  <strong>syspp</strong>            call to get print parameters
       (<strong>wa</strong>)                  print line length in chars
       (<strong>wb</strong>)                  number of lines/page
       (<strong>ws</strong>)                  bits value ...mlkjihgfedcba where
                     a = 1 to send error copy to int.ch.
                     b = 1 means std printer is int. ch.
                     c = 1 for -nolist option
                     d = 1 to suppress compiln. stats

                     e = 1 to suppress execn. stats
                     f = 1/0 for extnded/compact listing
                     g = 1 for -noexecute
                     h = 1 pre-associate /terminal/

                     i = 1 for standard listing option.
                     j = 1 suppresses listing header
                     k = 1 for -print
                     l = 1 for -noerrors
                     m = 1 for -case 1
</pre>

<h4><strong>syspr</strong> -- print line on standard output file</h4>

<p><strong>syspr</strong> is used to print a single line on the
standard output file.

<pre>
       (<strong>xr</strong>)                  pointer to line buffer (<strong>scblk</strong>)
       (<strong>wa</strong>)                  line length
       jsr  <strong>syspr</strong>            call to print line
       ppm  loc              too much o/p or no file after <strong>sysxi</strong>
       (<strong>wa</strong>,<strong>wb</strong>)               destroyed
</pre>

<p>The buffer pointed to is the length obtained from the
<strong>syspp</strong> call and is filled out with trailing blanks.
the value in <strong>wa</strong> is the actual line length which may
be less than the maximum line length possible. there is no space
control associated with the line, all lines are printed single spaced.

<p>Note that null lines (<strong>wa</strong>=0) are possible in which
case a blank line is to be printed.

<p>The error exit is used for systems which limit the amount of
printed output.

<p>If possible, printing should be permitted after this
condition has been signalled once to allow for dump and other
diagnostic information.  assuming this to be possible, SPITBOL may
make more <strong>syspr</strong> calls. if the error return occurs
another time, execution is terminated by a call of
<strong>sysej</strong> with ending code 998.

<h4><strong>sysrd</strong> -- read record from standard input
file</h4>

<p><strong>sysrd</strong> is used to read a record from the standard
input file. the buffer provided is an <strong>scblk</strong> for a
string the length of which in characters is given in
<strong>ws</strong>, this corresponding to the maximum length of
string which SPITBOL is prepared to receive. at compile time it
corresponds to xxx in the most recent -inxxx card (default 72) and at
execution time to the most recent ,r_r_ (record length) in the third
arg of an input() statement for the standard input file (default 80).

<p>If fewer than (<strong>ws</strong>) characters are read, the
length field of the <strong>scblk</strong> must be adjusted before
returning unless the buffer is right padded with zeroes.

<p>It is also permissible to take the alternative return after such an
adjustment has been made.

<p>SPITBOL may continue to make calls after an endfile return so this
routine should be prepared to make repeated endfile returns.

<pre>
       (<strong>xr</strong>)                  pointer to buffer (<strong>scblk</strong> pointer)
       (<strong>ws</strong>)                  length of buffer in characters
       jsr  <strong>sysrd</strong>            call to read line
       ppm  loc              endfile or no i/p file after <strong>sysxi</strong>
                            or input file name change.  if
                            the former, <strong>scblk</strong> length is zero.
                            if input file name change, length
                            is non-zero. caller should re-issue
                            <strong>sysrd</strong> to obtain input record.
       (<strong>wa</strong>,<strong>wb</strong>,<strong>ws</strong>)            destroyed
</pre>

<h4><strong>sysri</strong> -- read record from interactive channel</h4>

<p>Reads a record from online terminal for SPITBOL variable,
terminal. if online terminal is unavailable then code the endfile
return only.

<p>The buffer provided is of length 258 characters.
<strong>sysri</strong> should replace the count in the second word of
the <strong>scblk</strong> by the actual character count unless buffer
is right padded with zeroes.

<p>It is also permissible to take the alternative return after
adjusting the count.

<p>The end of file return may be used if this makes
sense on the target machine (e.g. if there is an
eof character.)

<pre>
       (<strong>xr</strong>)                  pointer to 258 char buffer (<strong>scblk</strong> pointer)
       jsr  <strong>sysri</strong>            call to read line from terminal
       ppm  loc              end of file return
       (<strong>wa</strong>,<strong>wb</strong>,<strong>ws</strong>)            may be destroyed
</pre>

<h4> <strong>sysrw</strong> -- rewind file</h4>

<p><strong>sysrw</strong> is used to rewind a file i.e. reposition
the file at the start before the first record. the file should be
closed and the next read or write call will open the file at the
start.

<pre>
       (<strong>wa</strong>)                  pointer to <strong>fcblk</strong> or zero
       (<strong>xr</strong>)                  rewind arg (<strong>scblk</strong> pointer)
       jsr  <strong>sysrw</strong>            call to rewind file
       ppm loc return here if file does not exist
       ppm loc return here if rewind not allowed ppm loc return here if i / o error
</pre>}

<h4><strong>sysst</strong> -- set file pointer</h4>

<p><strong>sysst</strong> is called to change the position of a file
pointer. this is accomplished in a system dependent manner, and thus
the 2nd and 3rd arguments are passed unconverted.

<pre>
       (<strong>wa</strong>)                  <strong>fcblk</strong> pointer
       (<strong>wb</strong>)                  2nd argument
       (<strong>ws</strong>)                  3rd argument
       jsr  <strong>sysst</strong>            call to set file pointer
       ppm  loc              return here if invalid 2nd arg
       ppm  loc              return here if invalid 3rd arg
       ppm  loc              return here if file does not exist
       ppm  loc              return here if set not allowed
       ppm  loc              return here if i/o error
</pre>

<h4><strong>systm</strong> -- get execution time so far</h4>

<p><strong>systm</strong> is used to obtain the amount of execution
time used so far since SPITBOL was given control. the units are
described as milliseconds in the SPITBOL output, but the exact meaning
is system dependent. where appropriate, this value should relate to
processor rather than clock timing values.

<p>If the symbol .ctmd is defined, the units are described as
deciseconds (0.1 second).

<pre>
       jsr  <strong>systm</strong>            call to get timer value
       (ia)                  time so far in milliseconds
                            (deciseconds if .ctmd defined)
</pre>

<h4> <strong>systt</strong> -- trace toggle</h4>

<p>Called by SPITBOL function trace() with no args to toggle the
system trace switch.  this permits tracing of labels in SPITBOL code
to be turned on or off.

<pre>
       jsr  <strong>systt</strong>            call to toggle trace switch
</pre>

<h4><strong>sysul</strong> -- unload external function</h4>

<p><strong>sysul</strong> is used to unload a function previously
loaded with a call to sysld.

<pre>
       (<strong>xr</strong>)                  pointer to control block (<strong>efblk</strong>)
       jsr  <strong>sysul</strong>            call to unload function
</pre>

<p>The function cannot be called following a <strong>sysul</strong>
call until another sysld call is made for the same function.

<p>The <strong>efblk</strong> contains the function code pointer and
also a pointer to the vrblk containing the function name (see
definitions and data structures section).

<h4><strong>sysxi</strong> -- exit to produce load module</h4></h4>

<p>When <strong>sysxi</strong> is called, <strong>xl</strong>
contains either a string pointer or zero. In the former case, the
string gives the character name of a program. The intention is that
SPITBOL execution should be terminated forthwith and the named program
loaded and executed. 

<p>This type of chain execution is very system dependent and
implementors may choose to omit it or find it impossible to provide.

<p>If <strong>xl</strong>) is zero,ia contains one of the following
integers

<pre>
-1, -2, -3, -4
    Create if possible a load module containing only the
    impure area of memory which needs to be loaded with
    a compatible pure segment for subsequent executions.
    Version numbers to check compatibility should be
    kept in both segments and checked on loading.
    To assist with this check, (<strong>xr</strong>) on entry is a
    pointer to an <strong>scblk</strong> containing the SPITBOL major
    version number v.v (see <strong>sysid</strong>).  The file thus
    created is called a save file.

0    If possible, return control to job control
    command level. The effect if available will be
    system dependent.

+1, +2, +3, +4
    Create if possible a load module from all of
    memory. It should be possible to load and execute
    this module directly.
</pre>

<p>In the case of saved load modules, the status of open files is not
preserved and implementors may choose to offer means of attaching
files before execution of load modules starts or leave it to the user
to include suitable input(), output() calls in his program.
<strong>sysxi</strong> should make a note that no i/o channels,
including standard files, have files attached so that calls of
<strong>sysin</strong>, <strong>sysou</strong>,
<strong>syspr</strong>, 

<p><strong>sysrd</strong> should fail unless
new associations are made for the load module.
at least in the case of the standard output file, 

<p>It is recommended that either the user be required to attach a file
or that a default file is attached, since the problem of error
messages generated by the load module is otherwise severe.  <p>As a
last resort, if SPITBOL attempts to write to the standard output file
and gets a reply indicating that such ouput is unacceptable it stops
by using an entry to <strong>sysej</strong> with ending code 998.  As
described below, passing of some arguments makes it clear that load
module will use a standard output file.

<p>If use is made of <strong>fcblk</strong>s for i/o association,
SPITBOL builds a chain so that those in use may be found in
<strong>sysxi</strong> and <strong>sysej</strong>. The nodes are 4
words long. The third word contains link to next node or 0, and the
fourth word contains a <strong>fcblk</strong> pointer.

<pre>
       (<strong>xl</strong>)                  zero or <strong>scblk</strong> pointer to first argument
       (<strong>xr</strong>)                  pointer to v.v <strong>scblk</strong>
       (ia)                  signed integer argument
       (<strong>wa</strong>)                  <strong>scblk</strong> pointer to second argument
       (<strong>wb</strong>)                  0 or pointer to head of <strong>fcblk</strong> chain
       jsr  <strong>sysxi</strong>            call to exit
       ppm  loc              requested action not possible
       ppm  loc              action caused irrecoverable error
       (<strong>wb</strong>,<strong>ws</strong>,ia,<strong>xr</strong>,<strong>xl</strong>,cp)   should be preserved over call
       (<strong>wa</strong>)                  0 in all cases except sucessful
                            performance of exit(4) or exit(-4),
                            in which case 1 should be returned.
</pre>

<p>Loading and running the load module or returning from jcl command
level causes execution to resume at the point after the error returns
which follow the call of <strong>sysxi</strong>.  The value passed as
exit argument is used to indicate options required on resumption of
load module.

<p>+1 or -1 require that on resumption, <strong>sysid</strong> and
<strong>syspp</strong> be called and a heading printed on the standard
output file.

<p>+2 or -2 indicate that <strong>syspp</strong> will be called but not <strong>sysid</strong>
and no heading will be put on standard output file.

<p>Above options have the obvious implication that a
standard o/p file must be provided for the load module.

<p>+3, +4, -3 or -4 indicate calls of neither <strong>sysid</strong> nor
<strong>syspp</strong> and no heading will be placed on standard output
       file.

<p> +4 or -4 indicate that execution is to continue after creation of
the save file or load module, although all files will be closed by the
<strong>sysxi</strong> action.  This permits the user to checkpoint
long-running programs while continuing execution.

<p>No return from <strong>sysxi</strong> is possible if another
program is loaded and entered.

</body>
</html>
