-title mincod                                           : phase 2 translation from minimal tokens to 80386 code
-stitl description

*       Copyright 1987-2012 robert b. k. dewar and mark emmer.
*       Copyright 2012-2017 david shields

*       this file is part of macro spitbol.

*       macro spitbol is free software: you can redistribute it and/or modify
*       it under the terms of the gnu general public license as published by
*       the free software foundation, either version 2 of the license, or
*       (at your option) any later version.

*       macro spitbol is distributed in the hope that it will be useful,
*       but without any warranty; without even the implied warranty of
*       merchantability or fitness for a particular purpose.  see the
*       gnu general public license for more details.

*       you should have received a copy of the gnu general public license
*       along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.


*       this program takes input file in minimal token form and produces assembly code for intel 
*	x64 processor. the program obtains the name of the file to be translated from the
*       command line string in host(0).

*       options relating to the processing of comments can be changed by modifying the source.

*       in addition to the minimal token file, the program requires the name of a 
*	"machine definition file" that contains code specific to a particular 80386 assembler.

*       you may also specify option flags on the command line to control the
*       code generation.  the following flags are processed:

*           compress        generate tabs rather than spaces in output file
*           comments        retain full-line and end-of-line comments

*       the variable arch is set equal to the uppercase name of the machine being processed.
*	specific tests upon this variable are discouraged, as all machine-dependent code should 
*	be placed in the machine-definition file if possible.

*       in addition to the normal minimal register complement, one scratch work register, w0 is defined.
*       see the register map below for specific allocations.

*       this program is based in part on earlier translators for the it is based in part on earlier 
*	translators for the dec vax (vms and un*x) written by steve duff and robert goldberg,
*	and the pc-spitbol translator by david shields.

*  to run under spitbol:

*           spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt

*           reads <file>.lex        containing tokenized source code
*           writes <file>.s         with 80386 assembly code
*           also writes <file>.err  with err and erb error messages
*           parts of m.hdr  are prepended and appended to <file>.s
*           also sets flags         to 1 after converting names to upper case
*           also reads <file>.pub   for debug symbols to be declared public

*       example:


*           spitbol -u v37:dos:compress codlinux.spt


*       error is used to report an error for current statement

-stitl crack(line)
        define('crack(line)operands,operand,char')      :(crack.end)

*       crack is called to create a stmt plex containing the various parts  of the minimal source 
*	statement in line.  for conditional assembly ops, the opcode is the op, and op1 is the symbol.
*	note that dtc is handled as a special case to assure that the decomposition is correct.

*       crack prints an error and fails if a syntax error occurs.



*       crack parses stmt into a stmt data plex and returns it. it fails if there is a syntax error.

crack

        nstmts  = nstmts + 1
        op1 = op2 = op3 = typ1 = typ2 = typ3 =
        line    p.csparse                               :s(return)
*       here on syntax error

        error('source line syntax error')               :(freturn)
crack.end
-stitl  chktrace()
        define('chktrace()')                            :(chktrace.end)
chktrace

*                                                    :(return)
*            output = 'chktrace:' iinput_lines ':' label ':' stmtout
*            output = differ (label) 'chktrace label:' label ':'
*            turn off skip mode when begin executable code

        clabel = inlabel
        old_z_skip = z_skip
        old_z_exec = z_exec
        old_is_exec = is_exec
        z_skip = ident(inlabel,'s_aaa') 0

*            incode ? any(lcase)                     :s(return)

        uopcode  = replace(incode, lcase,ucase)

*       do not trace bsw (for now)

        ident(uopcode,'bsw')                            :s(return)
        is_exec = is_executable[uopcode]
        z_exec = ne(z_trace)  ident(inlabel, 's_aaa') 1
        z_exec = gt(input_lines,2186) 1

*            need to skip certain blocks since otherwise get branches that are too long skip when in 
*	code that won't assemble if try to trace this was discovered on a case-by-case basis.

        z_skip  = differ(inlabel) differ(skip_on[inlabel]) 1
        z_skip  = differ(inlabel) differ(skip_off[inlabel]) 0

        ne(z_skip)                                      :s(return)
        eq(z_exec)                                      :s(return)
        eq(is_exec)                                     :s(return)

*            here to emit trace. need to emit trace after label if there is label
*            ident(inlabel)                          :s(chktrace.1)
*            only trace at labels since get jumps that are too removed otherwise
*            ident(label)                            :s(return)
*            here to emit trace code when there is label
*            first need to emit label, then fall through

*            stmtout ? break_ws  . label spanws  rem . body  :f(outstmt5)
*            stmtout = tab body
*            outfile = label
*            label =
        ne(in_gcol)                                     :s(return)

chktrace.1

        genz()
                                                        :(return)

chktrace.end
-stitl	flush
        define('flush()')                               :(flush_end)

*       here to emit bstmts, cstmts, astmts. attach input label and
*       comment to first instruction generated.

flush

        eq(astmts.n) eq(bstmts.n) eq(cstmts.n)          :f(flush_0)

*       here if some statements to emit, so output single 'null' statement to get label
*       and comment field right.

        label = thislabel =
        outstmt(tstmt())                                :(flush_6)

flush_0

        eq(bstmts.n)                                    :s(flush_2)
        i = 1

flush_1

        outstmt(bstmts[i])
        le(i = i + 1, bstmts.n)                         :s(flush_1)

flush_2

        eq(cstmts.n)                                    :s(flush_4)
        i = 1

flush_3

        outstmt(cstmts[i])
        le(i = i + 1, cstmts.n)                         :s(flush_3)

flush_4        eq(astmts.n)                             :s(flush_6)

        i = 1
        ident(pifatal[incode])                          :s(flush_5)
*       here if post incrementing code not allowed
        error('post increment not allowed for op ' incode)

flush_5

        outstmt(astmts[i])
        le(i = i + 1, astmts.n)                         :s(flush_5)

flush_6

        astmts.n = bstmts.n = cstmts.n =                :(return)

flush_end
-stitl define('genrep(op)
        define('genrep(op)l1,l2)')                      :(genrep_end)

*	generate code to repeat operation *op* using
*	'rep *op* loop' instruction.

genrep
        l1 = genlab()
        l2 = genlab()
        genopl(l1 '                                     :')
        genop('or',wa,wa)
        genop('jz',l2)
        genop(op)
        genop('dec',wa)
        genop('jmp',l1)
        genopl(l2 '                                     :')
                                                        :(return)
genrep_end
-stitl genz
        define('genz()')                                :(genz.end)

*	generate trace instruction if needed.

genz

*            no trace if trace has been suspended
*            output = ne(z_suspend) 'z_suspend ' thisline

        ne(z_suspend)                                   :s(return)

*  only trace at label definition
*            ident(thislabel)                        :s(return)

        z_count = z_count + 1
        gt(z_first) le(z_count,z_first)                 :s(return)
        gt(z_limit)  gt(z_count, z_limit)               :s(return)

*            always generate trace if at label definition

        z_desc = '"' replace(thisline,sepchar,' ') '"'
        outfile = tab 'zzz' tab z_count ',' input_lines ',' z_desc
        outlines = outlines + 1
                                                        :(return)

genz.end
-stitl comregs(line)t,pre,word
        define('comregs(line)t,pre,word')               :(comregs.end)

*       map minimal register names to target register names

comregs

        line p.comregs =                                :f(comregs1)
        word = eq(size(word),2) differ(t = register(word)) t
        comregs = comregs pre word                      :(comregs)

comregs1 comregs = comregs line                         :(return)

comregs.end
-stitl error(text)
        define('error(text)')                           :(error.end)

*       this module handles reporting of errors with the offending
*       statement text in thisline.  comments explaining
*       the error are written to the listing (including error chain), and
*       the appropriate counts are updated.

error

	outfile = filenami ': error: ' text
	outfile = rpad(lpad(input_lines,6),size(filenami) -1) ' | ' thisline
        lasterror = output_lines
        output_lines = output_lines + 2
        le(nerrors = nerrors + 1, 10)                   :s(opnext)
        output = 'too many errors, quitting'            :(end)

error.end
-stitl genaop(stmt)
        define('genaop(stmt)')                          :(genaop_end)

*	generates code for statements that must be executed
*	after this instruction.

genaop

        astmts[astmts.n = astmts.n + 1] = stmt          :(return)

genaop_end
-stitl genbop(stmt)
        define('genbop(stmt)')                          :(genbop_end)

*	generates code for statements that must be executed
*	before this instruction.


genbop

        bstmts[bstmts.n = bstmts.n + 1] = stmt          :(return)

genbop_end
-stitl genlab()

        define('genlab()')                              :(genlab_end)

*       generate unique label for use in generated code

genlab

        genlab = '_l' lpad(genlabels = genlabels + 1,4,'0'):(return)

genlab_end
-stitl genopl(gopl,gopc,gop1,gop2,gop3)
        define('genopl(gopl,gopc,gop1,gop2,gop3)')      :(genopl.end)

*       generate operation with label

genopl

        cstmts[cstmts.n = cstmts.n + 1] =
.               tstmt(gopl,gopc,gop1,gop2,gop3)         :(return)

genopl.end
-stitl genop(gopc,gop1,gop2,gop3)
        define('genop(gopc,gop1,gop2,gop3)')            :(genop_end)

*       generate operation with no label

genop

        genopl(,gopc,gop1,gop2,gop3)                    :(return)

genop_end
-stitl getarg(iarg,imem)
        define('getarg(iarg,imem)l1,l2,t1,t2,tmem')     :(getarg_end)

*	get argument to register and return that register.

getarg

* output = 'getarg text <' i.text(iarg) '>  i.type <' i.type(iarg) '>'
        tmem = (differ(imem) '', 'm_word ')
        l1 = i.text(iarg)
        l2 = i.type(iarg)
        eq(l2)                                          :f($(getargcase[l2]))

getarg_c.1
        getarg = l1                                     :(return)

*  int

   getarg = l1                                          :(return)
getarg_c.2

*  dlbl

   getarg = l1                                          :(return)

getarg_c.3
getarg_c.4

*  wlbl, clbl

   getarg = tmem '[' l1 ']'                             :(return)

getarg_c.5
getarg_c.6

*  elbl, plbl

   getarg = l1                                          :(return)

getarg_c.7
getarg_c.8

*  w,x, map register name

        getarg = register(l1)                           :(return)

getarg_c.9

*  (x), register indirect

        l1 len(1) len(2) . l2
        l2 = register(l2)
        getarg = tmem '[' l2 ']'                        :(return)

getarg_c.10

*  (x)+, register indirect, post increment
*  use lea reg,[reg+cfp_b] unless reg is esp, since it takes an extra byte.
*  actually, lea reg,[reg+cfp_b] and add reg,cfp_b are both 2 cycles and 3 bytes
*  for all the other regs, and either could be used.

        l1 = substr(l1,2,2)
        t1 = register(l1)
        getarg = tmem '[' t1 ']'
        (ident(l1,xs) genaop(tstmt(,'add',t1,'cfp_b'))) :s(return)
        genaop(tstmt(,'lea',t1,'[' t1 '+cfp_b]'))       :(return)

getarg_c.11

*       -(x), register indirect, pre decrement

        t1 = register(substr(l1,3,2))
* output = 'getarg_c.11 t1 <' t1 '>'
        getarg = tmem '[' t1 ']'
        genbop(tstmt(,'lea',t1,'[' t1 '-cfp_b]'))       :(return)

getarg_c.12
getarg_c.13

*  int(x)
*  dlbl(x)


        l1 break('(') . t1 '(' len(2) . t2
        getarg = tmem '[(cfp_b*' t1 ')+' register(t2) ']':(return)

getarg_c.14
getarg_c.15

*       name(x), where name is in working section

        l1 break('(') . t1 '(' len(2) . t2
        getarg = tmem '[' t1 '+'  register(t2) ']'      :(return)

getarg_c.16 getarg = l1                                 :(return)

*  signed integer

getarg_c.17 getarg = l1                                 :(return)

*  signed real


getarg_c.18

*       =dlbl

        getarg = substr(l1,2)                           :(return)

getarg_c.19
*       *dlbl


        getarg = 'cfp_b*' substr(l1,2)                  :(return)

getarg_c.20
getarg_c.21
*       =name (data section)


        getarg =  substr(l1,2)                          :(return)

getarg_c.22
*       =name (program section)

        getarg =  substr(l1,2)                          :(return)

getarg_c.23
getarg_c.24

*       pnam, eqop


	getarg = l1                                            :(return)

getarg_c.25
getarg_c.26
getarg_c.27

*  ptyp, text, dtext

   getarg = l1                                          :(return)

getarg_end
-stitl	isreg(iarg)
        define('isreg(iarg)')                           :(isreg_end)

*	succeeds if *iarg* is a minimal register name, fails otherwise.
isreg

* output = 'isreg datatype ' datatype(iarg) ' <' datatype(iarg) '>'
        ge(i.type(iarg),7) le(i.type(iarg),8)           :f(freturn)s(return)

isreg_end
-stitl initmap(str)
        define('initmap(str),index,val')                :(initmap.end)

*       this routine is called to initialize a table from a string of
*       index/value pairs.

initmap

        initmap = table(size(str))

initmap.1

        str     (break('[') $ index len(1) break(']') $ val len(1)) =
.                                                       :f(return)
        val     = convert( val,'integer' )
        val     = ident(val,lastval) lastval
        lastval = val
        initmap[index] = val                            :(initmap.1)

initmap.end
-stitl include(filename)

*	copy contents of *filename*

        define('include(filename)includefile,line')     :(include.end)

include

        input(.includefile,4,filename)                  :s(include.next)
        error('cannot open include file ' filename)     :(return)

include.next

        outfile = includefile                           :s(include.next)
        endfile(4)                                      :(return)

include.end
-stitl memmem()t
        define('memmem()t')				:(memmem.end)
memmem

*       memmem is called for those ops for which both operands may be
*       in memory, in which case, we generate code to load second operand
*       to pseudo-register w0, and then modify the second argument
*       to reference this register

        eq(ismem[i.type(i1)])				:s(return)
        eq(ismem[i.type(i2)])				:s(return)

*       here if memory-memory case, load second argument and then make second argument *w0*.

        t = getarg(i2)
        genop('mov',w0,getarg(i2))
	i2 = minarg(8,'w0')
                                                        :(return)
memmem.end
-stitl prcent(n)
        define('prcent(n)')                             :(prcent.end)

prcent prcent = 'prc_+cfp_b*' ( n - 1)                  :(return)

prcent.end
-stitl	report(num,text)

        define('report(num,text)')                      :(report.end)

report

        output = rpad('  ' text ':',30) num			:(return)

report.end
-stitl outstmt(ostmt)label,opcode,op1,op2,op3,comment,line)
        define('outstmt(ostmt)line,label,opcode,op1,op2,op3,comment,t,stmtout'):(outstmt.end)

*       outstmt is used to send a target statement to the output file.

outstmt label = t.label(ostmt)

*       clear label if definition already emitted

        label = ident(label, lastlabel)

outstmt1

*       attach source comment to first generated instruction

        differ(comment)                                 :s(outstmt2)
        ident(tcomment)                                 :s(outstmt2)
        comment = tcomment; tcomment =

outstmt2

        opcode = t.opc(ostmt)
        op1 = t.op1(ostmt)
        op2 = t.op2(ostmt)
        op3 = t.op3(ostmt)
        differ(compress)                                :s(outstmt3)
        line = rpad( rpad(label,7) ' ' rpad(opcode,4) ' '
.                 (ident(op1), op1
.                       (ident(op2), ',' op2
.                               (ident(op3), ',' op3))) ,27)
                                                        :(outstmt4)
outstmt3

        line = label tab opcode tab
.                 (ident(op1), op1
.                   (ident(op2), ',' op2
.                     (ident(op3), ',' op3)))

outstmt4

        line = trim(line)
        line = le(size(line),48) rpad(line,48) '; ' comment:s(outstmt5)
        line = le(size(line),56) rpad(line,56) '; ' comment:s(outstmt5)
        line = line '; ' comment

outstmt5
**
**      send text to output file if not null.

*            line = replace(trim(line),'$','_')

        eq(z_trace)                                     :s(outstmt6)

*            here if trace code desired for executable instructions

        chktrace()

outstmt6

* output =  line
        outfile = line
        ntarget = ntarget + 1
        output_lines = output_lines + 1

*       record code labels in table with delimiter removed.
        (ge(sectnow,5) differ(thislabel))               :f(return)
        label ? break(':') . label                      :f(return)
        labtab<label> = output_lines                       :(return)

outstmt.end
-stitl prsarg(iarg)
        define('prsarg(iarg)l1,l2')                     :(prsarg_end)
prsarg

        prsarg = minarg(0)
        iarg break(',') . l1 ',' rem . l2               :f(return)
        prsarg = minarg(convert(l1,'integer'),l2)       :(return)

prsarg_end
-stitl readline()
        define('readline()')                            :(readline_end)

*       this routine returns the next statement line in the input lex file
*       to the caller.  it never fails.  if there is no more input,
*       then a minimal end statement is returned.
*       comments are passed through to the output file directly.

readline

        readline = infile                               :f(readline_eof)

        input_lines  = input_lines + 1
        ident( readline )                               :f(readline_2)

        outfile = readline
        output_lines = output_lines + 1                       :(readline)

readline_2
* output = readline
        lne(substr(readline,1,1 ),'*' )                 :s(return)

*       Here if comment.

        z_skip = ident(readline,'*z+') 0                :s(readline)
        z_skip = ident(readline,'*z-') 1                :s(readline)

        outfile = ';' substr(readline,2)
        output_lines = output_lines + 1                       :(readline)

readline_eof

   readline = '        end'                             :(return)
readline_end
-stitl	register(s)
	define('register(s)')                                  :(register.end)

*	returns target register for register *s*.
*	fails if *s* is not a valid register name.

register

	register = $(s)
	ident(register)                                        :s(freturn)
                                                        :(return)

register.end
-stitl	reglow(s)
	define('reglow(s)')                                    :(reglow.end)

*	returns name of low (rightmost byte) part of target register *s*.

reglow

	reglow = ident(s,'w0')  'al'                           :s(return);* w0
	reglow = ident(s,'wa')  'cl'                           :s(return);* wa
	reglow = ident(s,'wb')  'bl'                           :s(return);* wb
	reglow = ident(s,'wc')  'dl'                           :s(return);* wc

	reglow = ident(s,'rax') 'al'                           :s(return);* w0
	reglow = ident(s,'rbx') 'bl'                           :s(return);* wa
	reglow = ident(s,'rcx') 'cl'                           :s(return);* wb
	reglow = ident(s,'rdx') 'dl'                           :s(return);* wc
	error('bad argument to reglow')                        :(return)

reglow.end
	define('skip_init(s)on,off')                           :(skip_init.end)

*	initialize the skip table used for instruction trace.

skip_init       s break(':') . on ':' rem . off         :f(return)

        skip_on[on] = 1
        skip_off[off] = 1                               :(return)

skip_init.end

	define('init()')                                       :(init.end)

init

*       revision history:

        version = 'v1.12'
        rcode = '_rc_'

*       keyword initialization

        &anchor = 1;    &stlimit = 15000000;    &trim   = 1;  &dump = 1

	&dump = 2

*       useful constants

        letters = 'abcdefghijklmnopqrstuvwxyz'
        ucase   = letters
        lcase   = 'abcdefghijklmnopqrstuvwxyz'
        nos     = '0123456789'
        tab     = char(9)

*	sepchar separates fields in input file

	sepchar = '|'

*       default the parameter string if none present

        fileprefix = "sbl"

*            cfp_b is bytes per word, cfp_c is characters per word
*            these should agree with values used in translator
*  set target-dependent configuration parameters

*            cfp_b is bytes per word, cfp_c is characters per word
*            these should agree with values used in translator
        cfp_b = 8
        log_cfp_b = '3'

        cfp_c = 8
        log_cfp_c = '3'

*	used for data declarations
        op_w = 'q'
        op_c = 'b'

*	target register assignments

	cp = 'cp' 

*	w0 is temp register

	w0 = 'rax'

        wa = 'rcx'

        wb = 'rbx'
	wb = 'wb'

        wc = 'rdx'

	ia = 'rbp'

        cp = 'cp'

	xl = 'rsi'
	xl = 'xl'
	xt = xl

	xr = 'rdi'
	xr = 'xr'

	xs = 'rsp'

	w0 = 'w0'; wa = 'wa'; wb = 'wb'; wc = 'wc'
	xl = 'xl'; xr = 'xr'; xs = 'xs'; xt = xl

*	_ia_ is mapped to _rbp_ in nasm.h.

	ia = 'ia'

*	cp is kept in memory

* symbolic target assignments

*       real_op maps minimal real opcode to machine opcode

        real_op = table(10)
        real_op['adr'] = 'fadd'
        real_op['atn'] = 'fpatan'
        real_op['chp'] = 'frndint'
        real_op['cos'] = 'fcos'
        real_op['dvr'] = 'fdiv'
        real_op['ldr'] = 'fld'
        real_op['mlr'] = 'fmul'
        real_op['ngr'] = 'fchs'
        real_op['sbr'] = 'fsub'
        real_op['sin'] = 'fsin'
        real_op['sqr'] = 'fsqrt'
        real_op['str'] = 'fst'

config_done


*       set z_trace to enable instruction by instruction trace
        z_trace = 1
        z_trace = 0
*       z_limit is maximum number of calls to be generated if non-zero
        z_limit = 000
*       set z_first non-zero to skip first number of instructions that would generate trace
        z_first = 0
*       will set in_executable when in part of program where executable
*       instructions may occur
        z_exec = 0

*       z_suspend is set to temporarily disable the trace.
        z_suspend = 0
*       set in_skip when should not insert trace code, else assembly errors result.
*       start with skip on, turn off when see first start of code.
        z_skip = 1
*       skip_on and skip_off are labels indicating the start and end,
*       respectively, of sections of the code that should not be traced,
*       usually because they contain a loop instruction that won't
*       compile if too much trace code is inserted.
        skip_on = table(50)
        skip_off = table(50)

*       skip_init('start:ini03')
        skip_init('gbcol                                :gtarr')
*       skip_init('gtn01:gtnvr')
*       skip_init('bpf05:bpf07')
*       skip_init('scv12:scv19')
*       skip_init('exbl1:exbl2')
*       skip_init('exbl5:expan')
*       skip_init('prn17:prn18')
*       skip_init('ini11:ini13')
*       skip_init('oex13:oexp2')
*       skip_init('oex14:oexp6')
*       skip_init('bdfc1:b_efc')
*       skip_init('sar01:sar10')
*       skip_init('srpl5:srpl8')
*       skip_init('pflu1:pflu2')
*       skip_init('prpa4:prpa5')
*       skip_init('prn17:prn18')
*       skip_init('prtvl:prtt1')
*       skip_init('trim4:trim5')
*       skip_init('prnl1:prnl2')
*       skip_init('prti1:prtmi')
*       skip_init('srpl5:srpl8')



*       data structures

        data('minarg(i.type,i.text)')
        data('tstmt(t.label,t.opc,t.op1,t.op2,t.op3,t.comment)')

        sectnow = 0

*       ppm_cases gives count of ppm/err statments that must follow call to
*       a procedure

        ppm_cases = table(50,,0)


         p.comregs = break(letters) . pre span(letters) . word

*       exttab has entry for external procedures

        exttab = table(50)

*       labtab records labels in the code section, and their line numbers

        labtab = table(500)

*       for each statement, code in generated into three
*       arrays of statements:

*       astmts: statements after opcode (()+, etc.)
*       bstmts: statements before code (-(), etc)
*       cstmts: generated code proper

        astmts = array(20,'')
        bstmts = array(10,'')
        cstmts = array(20,'')

*       genlabels is count of generated labels (cf. genlab)

        genlabels = 0


*       initialize variables

        labcnt = output_lines = input_lines = nstmts = ntarget = nerrors = 0
        lastopc = lastop1 = lastop2 =
        data_lc = 0
        max_exi = 0

*       initial patterns

*       p.csparse parses tokenized line
        p.csparse = sepchar break(sepchar) . inlabel
.       sepchar break(sepchar) . incode
.       sepchar break(sepchar) . iarg1
.       sepchar break(sepchar) . iarg2
.       sepchar break(sepchar) . iarg3
.       sepchar break(sepchar) . incomment
        sepchar rem . slineno

*       dispatch table

        getargcase = table(27)
        getargcase[1] = .getarg_c.1;   getargcase[2] = .getarg_c.2
        getargcase[3] = .getarg_c.3;   getargcase[4] = .getarg_c.4
        getargcase[5] = .getarg_c.5;   getargcase[6] = .getarg_c.6
        getargcase[7] = .getarg_c.7;   getargcase[8] = .getarg_c.8
        getargcase[9] = .getarg_c.9;   getargcase[10] = .getarg_c.10
        getargcase[11] = .getarg_c.11; getargcase[12] = .getarg_c.12
        getargcase[13] = .getarg_c.13; getargcase[14] = .getarg_c.14
        getargcase[15] = .getarg_c.15; getargcase[16] = .getarg_c.16
        getargcase[17] = .getarg_c.17; getargcase[18] = .getarg_c.18
        getargcase[19] = .getarg_c.19; getargcase[20] = .getarg_c.20
        getargcase[21] = .getarg_c.21; getargcase[22] = .getarg_c.22
        getargcase[23] = .getarg_c.23; getargcase[24] = .getarg_c.24
        getargcase[25] = .getarg_c.25; getargcase[26] = .getarg_c.26
        getargcase[27] = .getarg_c.27


*       pifatal maps minimal opcodes for which no a code allowed
*       to nonzero value. such operations include conditional
*       branches with operand of form (x)+

        pifatal = initmap(
.       'aov[1]beq[1]bne[1]bge[1]bgt[1]bhi[1]ble[1]blo[1]'
.       'blt[1]bne[1]bnz[1]ceq[1]cne[1]mfi[1]nzb[1]zrb[1]')

*            trace not working for mvc (x64)

        is_executable = table(100)
        s =
+       'add adi adr anb aov atn '
+       'bct beq bev bge bgt bhi ble blo blt bne bnz bod '
+       'brn bri bsw btw bze ceq chk chp cmb cmc cmp cne csc '
+       'cos ctb ctw cvd cvm dca dcv eti dvi dvr erb esw etx flc '
+       'ica icp icv ieq ige igt ile ilt ine ino iov itr jmp '
+       'jsr lch lct lcp lcw ldi ldr lei lnf lsh lsx mcb mfi mli mlr '
+       'mnz mov mti mvw mwb ngi eti ngr nzb orb plc prc psc '
+       'req rge rgt rle rlt rmi rne rno rov rsh rsx rti rtn sbi sbr '
+       'sch scp sin sqr ssl sss sti str sub tan trc wtb xob zer '
+       'zgb zrb'

*            don't trace mvc as doing so causes just 'end' to fail. sort out later. (ds 01/09/13)

is_exec.1

        s len(3) . opc ' ' =                            :f(is_exec.2)
        is_executable[opc] = 1                          :(is_exec.1)

is_exec.2

*       various constants

        comment.delim = ';'

*       branchtab maps minimal opcodes 'beq', etc to desired
*       target instruction

        branchtab = table(10)
        branchtab['beq'] = 'je'
        branchtab['bne'] = 'jne'
        branchtab['bgt'] = 'ja'
        branchtab['bge'] = 'jae'
        branchtab['ble'] = 'jbe'
        branchtab['blt'] = 'jb'
        branchtab['blo'] = 'jb'
        branchtab['bhi'] = 'ja'

*       optim.tab flags opcodes capable of participating in or optimization in outstmt routine.

        optim.tab = table(10)

        optim.tab<"and"> = optim.tab<"add"> = optim.tab<"sub"> = optim.tab<"neg"> = optim.tab<"or"> =
.       optim.tab<"xor"> = optim.tab<"shr"> = optim.tab<"shl"> = optim.tab<"inc"> = optim.tab<"dec"> =  1


*       ismem is a map from operand type that is nonzero if the operand type is a memory reference.

        ismem = array(30,0)

        ismem<3> = ismem<4> = ismem<5> = ismem<9> = ismem<10> = ismem<11> = ismem<12> =
.	ismem<13> = ismem<14>  = ismem<15> = 1

*       other definitions that are dependent upon things defined in the
*       machine definition file, and cannot be built until after the definition
*       file has been read in.

*       p.outstmt examines output lines for certain types of comment contructions

        fillc     = (ident(compress) " ",tab)
        p.outstmt = (break(fillc) . label span(fillc)) . leader
+                       comment.delim rem . comment
        p.alltabs = span(tab) rpos(0)


        filenami = 'sbl.lex'
        input(.infile,1,filenami)                       :s(inputok)

inputok

        report(filenami, 'input lex file')

*       associate output files.

        filenamo = 'sbl.asm'
        output(.outfile,2,filenamo)                     :s(outputok)
        output = '  cannot open asm file: ' filenamo    :(end)

outputok

        output = report(filenamo,'output asm file')

*	open file for compilation of minimal err and erb messages

        output(.errfile,3, fileprefix ".err")           :s(err_ok)
        output = "  cannot open error message file: " fileprefix ".err":(end)
err_ok

*       will have havehdr non-null if more remains to copy out at end.

                                                        :(nopub)
*       read in pub file if it exists.  this contains a list of symbols to
*       be declared public when encountered.

        pubtab = table(2)
        input(.pubfile,5, fileprefix ".pub")            :f(nopub)
        pubtab = table(101)

pubcopy

        line = pubfile                                  :f(pubend)
        pubtab[line] = 1                                :(pubcopy)

pubend

         endfile(5)

nopub


*       get file name


*  get definition file name following token file name, and flags.

*            fileprefix ? break(';:') . fileprefix len(1) (break(';:') | rem) . target
*+              ((len(1) rem . flags) | '')
*            $replace(target,lcase,ucase) = 1

*  parse and display flags, setting each one's name to non-null value (1).

                                                        :(flgs.skip)
flgs

   flags ? ((len(1) break(';                            :')) . flag len(1)) |
+        ((len(1) rem) . flag) =                        :f(flgs2)
        flag = replace(flag,lcase,ucase)
        output = "  flag                                : " flag
        $flag = 1                                       :(flgs)

flgs.skip

flgs2

                                                        :(return)
init.end
-stitl main program
*       here follows the driver code for the "main" program.

	init()

*       loop until program exits via g_end

*       opnext is invoked to initiate processing of the next line from
*       readline_
*       after doing this, opnext branches to the generator routine indicated
*       for this opcode if there is one.
*       the generators all have entry points beginning
*       with "g_", and can be considered a logical extension of the
*       opnext routine.  the generators have the choice of branching back
*       to dsgen to cause the thisstmt plex to be sent to outstmt, or
*       or branching to opnext, in which case the generator must output
*       all needed code itself.

*       the generators are listed in a separate section below.

*       &trace = 2000
*       &ftrace = 1000
*       &profile = 1

        include('nasm.h')
        include('nasm.dcl')

*	Main loop - read next line and generate necessary code for it.

        &dump = 2
opnext

         thisline = readline()
         crack(thisline)                                :f(opnext)
         op_ = incode '_'

*       append ':' after label if in code or data.

*       output label of executable instruction immediately if there is one,
*       as it simplifies later processing, especially for tracing_

        ident(inlabel)                                  :s(opnext.1)
        thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)

*       keep the label as is is not in executable code

        lt(sectnow,5)                                   :s(opnext.1)

*       here if in code, so output label now
*       defer label processing for ent to allow emission of alignment ops for x86.

        ident(incode,'ent')                             :s(opnext.1)
        outfile = thislabel
        outlines = outlines + 1

*       set lastlabel so can check to avoid emitting duplicate label definitions

        lastlabel = thislabel

*       clear out label info once generated

        label = thislabel =

opnext.1

        thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
        i1 = prsarg(iarg1)
        i2 = prsarg(iarg2)
        i3 = prsarg(iarg3)
        tcomment = comregs(incomment) '} ' incode ' ' i.text(i1) ' '
.               i.text(i2) ' ' i.text(i3)
        argerrs = 0
* output = 'bad incode ' incode
                                                        :($('g_' incode))
*       here if bad opcode

ds01

        error('bad op-code')                            :(opnext)

*       generate tokens.

ds.typerr

        error('operand type zero')                      :(opnext)
-stitl generators

*	### 1-  Basic Instruction Set

*	*   1.1  MOV   _opn,opv_  move one word value

*	MOV causes the value of operand _opv_ to be set as the new contents of operand location 
*	_opn_. In the case where _opn_ is not an index register, any value which can normally occupy 
*	a memory word (including a part of a multiword real or integer value) can be transferred 
*	using MOV. If the target location _opn_ is an index register, then _opv_ must specify
*	an appropriate one word value or operand containing such an appropriate value.

g_mov

*	possible optimizations:

*       change mov x,(xr)+ to
*            mov ax,x; stows

*       do  mov (xl)+,wx as
*            lodsw
*            xchg ax,tx
*       and also mov (xl)+,name as
*            lodsw
*            mov name,w0

*       need to process memory-memory case

*       change 'mov (xs)+,a' to 'pop a'
*       change 'mov a,-(xs)' to 'push a'

        i.src = i2; i.dst = i1
        t.src = i.text(i.src); t.dst = i.text(i.dst)
        ident(t.src,'(xl)+')                            :s(mov_xlp)
        ident(t.src,'(xt)+')                            :s(mov_xtp)
        ident(t.src,'(xs)+')                            :s(mov_xsp)
        ident(t.dst,'(xr)+')                            :s(mov_xrp)
        ident(t.dst,'-(xs)')                            :s(mov_2)
        memmem()
        genop('mov',getarg(i1),getarg(i2))
                                                        :(opdone)
mov_xtp
mov_xlp

        ident(t.dst,'(xr)+') genop('movs_w')            :s(opdone)
        genop('lods_w')
        ident(t.dst,'-(xs)') genop('push',w0)           :s(opdone)
        genop('mov',getarg(i.dst),w0)                   :(opdone)

mov_xsp

        ident(t.dst,'(xr)+')                            :s(mov_xsprp)
        genop('pop',getarg(i.dst))                      :(opdone)

mov_xsprp 

	genop('pop',w0)
        genop('stos_w')                                 :(opdone)

mov_xrp genop('mov',w0,getarg(i.src))

        genop('stos_w')                                 :(opdone)

mov_2
*	isreg(i2) genop('push', register(t.src))	:s(opdone)
        genop('push',getarg(i.src))                     :(opdone)

*	* 1.2  BRN  _plbl_    unconditional branch

*	BRN causes control to be passed to the indicated label in the program section.

g_brn

        genop('jmp',getarg(i1))                         :(opdone)

*	* 1.3  BSW  _x,val,plbl_    branch on switch value

*	BSW IFF,ESW provide a capability for a switched branch similar to a fortran computed goto. 
*	The _val_ on the BSW instruction is the maximum number of branches. the value in x ranges 
*	from zero up to but not including this maximum. each IFF provides a branch.

*	_val_ must be less than that given on the bsw and control goes to _plbl_ if the value in 
*	x matches.  If the value in x does not correspond to any of the IFF entries, then control 
*	passes to the _plbl_ on the BSW.

*	The  _plbl_ operand may be omitted if there are no values missing from the list.

*	IFF and ESW may only be used in this context.  Execution of BSW may destroy the contents of _x_.

*	The IFF entries may be in any order and since a translator may thus need to store and 
*	sort them, the comment field is restricted in length (sec 11).

g_bsw

        t1 = getarg(i1)
        t2 = genlab()
        z_suspend = 1
        ident(i.text(i3))                               :s(g_bsw1)
        genop('cmp',t1,getarg(i2))
        genop('jge',getarg(i3))

*  here after default case.

g_bsw1

        genop('jmp', 'm_word [' t2 '+' t1 '*cfp_b]')
        genop('segment .data')
        genopl(t2 ':')
        z_suspend = 0
                                                        :(opdone)
*	* 1.4  IFF  _val,plbl_        provide branch for switch

*	```
*	            IFF  val,_plbl_     ...
*	            ...
*	            ...
*	```

g_iff

        genop('d_word',getarg(i2))                      :(opdone)

*	* 1.5  ESW      end of branch switch table
g_esw

        genop('segment .text')                          :(opdone)

*	*   1.6  ENT  _val_ define program entry point

*	The symbol appearing in the label field is defined to be a program entry point which 
*	can subsequently be used in conjunction with the BRI instruction, which provides the 
*	only means of entering the code. 

g_ent

*       entry points are stored in byte before program entry label
*       last arg is optional, in which case no initial 'db' need be
*       issued. we force odd alignment so can distinguish entry point
*       addresses from block addresses (which are always even).

*       note that this address of odd/even is less restrictive than
*       the minimal definition, which defines an even address as being
*       a multiple of cfp_b (4), and an odd address as one that is not
*       a multiple of cfp_b (ends in 1, 2, or 3).  the definition here
*       is a simple odd/even, least significant bit definition.
*       that is, for us, 1 and 3 are odd, 2 and 4 are even.


        t1 = i.text(i1)
        outfile = tab 'align' tab '2'
        differ(t1)                                      :s(g_ent.1)
        outfile = tab 'nop'
                                                        :(g_ent.2)
g_ent.1

        outfile = tab 'db' tab  t1

g_ent.2

        outlines = outlines + 2
        genopl(thislabel)

*       note that want to attach label to last instruction
*            t1 = cstmts[cstmts.n]
*            t.label(t1) = tlabel
*            cstmts[cstmts.n] = t1
*       here to see if want label made public

        thislabel ? rtab(1) . thislabel '               :'
*       (differ(pubtab[thislabel]), differ(debug)) genop('global',thislabel)
        thislabel =                                     :(opdone)

*	*   1.7  BRI   _opn_      branch indirect

*	_opn_ contains the address of a program entry point (see ent).
*	control is passed to the executable code starting at the entry point
*	address.  _opn_ is left unchanged.

g_bri

        genop('jmp',getarg(i1))                         :(opdone)

*	*   1.8  LEI  _x_         load entry point identification

*	X contains the address of an entry point for which an identifying
*	value was given on the the ENT line. LEI replaces the contents of _x_ by this value.

g_lei

        t1 = register(i.text(i1))
        genop('movzx',t1,'byte [' t1 '-1]' )            :(opdone)

*	*   1.9  JSR  _pnam_      call procedure _pnam_

g_jsr

        jsr_proc = getarg(i1)
        genop('call',jsr_proc)

*            get count of following ppm statements

        jsr_count = ppm_cases[jsr_proc]
        eq(jsr_count)                                   :s(opdone)
        z_suspend = 1
        jsr_calls = jsr_calls +  1
        jsr_label = 'call_' jsr_calls
        jsr_label_norm = jsr_label
        genop('dec','m_word [' rcode ']')
        genop('js',jsr_label_norm)
        z_suspend = 0

*            generate branch around for ppms that will follow
*            take the branch if normal return (eax==0)
                                                        :(opdone)

*	*   1.10 PPM  _plbl_      provide exit parameter

*	```
*	            PPM  _plbl_         ...
*	            ...
*	            PPM  _plbl_         ...
*	```

*	JSR causes control to be passed to the named procedure. _pnam_ is the label on a PRC
*	statement elsewhere in the program section (see prc) or has been defined using an 
*	*exp* instruction.

*	The PPM exit parameters following the call give names of program locations (_plbl_-s)
*	to which alternative EXI returns of the called procedure may pass control.

*	They may optionally be replaced by error returns (see err). the number of exit parameters
*	following a JSR must equal the int in the procedure definition.

*	The operand of PPM may be omitted if the corresponding EXI return is certain not to be taken.

g_ppm							:(g_err)

*	*   1.11 PRC  _ptyp,int_  define start of procedure

*	The symbol appearing in the label field is defined to be the name of a procedure for use 
*	with JSR a procedure is a contiguous section of instructions to which control may be passed 
*	with a JSR instruction.

*	This is the only way in which the instructions in a procedure may be executed.

*	It is not permitted to fall into a procedure.  All procedures should be named in section 0
*	 INP statements.

*	_int_ is the number of exit parameters (PPM-s) to be used in JSR calls.


g_prc

*       generate public declaration
*            t1 = thislabel
*            t1 ? rtab(1) . t1 ':'
*            genop()
*            genop('global',t1)
*       nop needed to get labels straight

        prc.args = getarg(i2)
        ppm_cases[thislabel] = i.text(i2)
        thislabel =
        max_exi = gt(prc.args,max_exi) prc.args
        prc.type = i.text(i1)                           :($('g_prc.' prc.type))

g_prc.e
g_prc.r                                                 :(opdone)

g_prc.n

*       store return address in reserved location
        prc.count = prc.count + 1
        genop('pop', 'm_word [' prcent(prc.count) ']')  :(opdone)

*	*   1.12 EXI  _int_       exit from procedure


*	The PPM and ERR parameters following a JSR are numbered starting from 1.

*	EXI int causes control to be returned to the int-th such param. EXI 1 gives control to 
*	the _plbl_ of the first PPM after the JSR if int is omitted, control is passed back past 
*	the last exit parameter (or past the JSR if there are none).

*	For _r and_ _e_ type procedures, the stack pointer XS must be set to its appropriate entry 
*	value before executing an EXI instruction.

*	In this case, EXI removes return points from the stack if any are stored there so 
*	that the stack pointer is restored to its calling value.

g_exi

        t1 = getarg(i1); t2 = prc.type; t3 = i.text(i1)

*       if type r or e, and no exit parameters, just return

        differ(t2,'n') eq(prc.args)     genop('ret')    :s(opdone)
        t3 = ident(t3) '0'
        genop('mov','m_word [' rcode ']',+t3)
        ident(t2,'n')                                   :s(g_exi.1)
        genop('ret')                                    :(opdone)

g_exi.1

        genop('mov',w0, 'm_word ['  prcent(prc.count) ']' )
        genop('jmp',w0)
                                                        :(opdone)

*	*   1.13 ENP  define end of procedure body

*	ENP delimits a procedure body and may not actually be executed, hence it must have no label.

g_enp   genop()                                         :(opdone)

*	*   1.14 ERR  _int,text_  provide error return

*	ERR may replace an exit parameter (PPM) in any procedure call. the int argument is a 
*	unique error code in 0 to 899.

*	The text supplied as the other operand is arbitrary text in the FORTRAN character set 
*	and may be used in constructing a file of error messages to be used by the error handling code.

*	In the event that an EXI attempts to return control via an exit parameter to an ERR control 
*	is instead passed to the first instruction in the error section (which follows the program
*	section) with the error code in WA.

g_err

*       Here with return code in rcode. it is zero for normal return and positive for error return.
*	decrement the value. if it is negative then this is normal return. otherwise, proceed 
*	decrementing rcode until it goes negative,and then take the appropriate branch.

        t1 = getarg(i1)

*       branch to next case if rcode code still not negative.

        ident(incode,'ppm')                             :s(g_ppm.loop)
        count.err =  count.err + 1
        errfile =   i.text(i1) ' ' i.text(i2)
        max.err = gt(t1,max.err) t1
                                                        :(g_ppm.loop)

g_ppm.loop.next

        genopl(lab_next ':')
        jsr_count = jsr_count - 1
        z_suspend = eq(jsr_count) 0
        eq(jsr_count) genopl(jsr_label_norm ':')        :(opdone)

g_ppm.loop

        lab_next = genlab()
        genop('dec','m_word [' rcode ']')
        genop('jns',lab_next)
        ident(incode,'ppm')                             :s(g_ppm.loop.ppm)

*       here if error exit via exi. set rcode to exit code and jump
*       to error handler with error code in rcode

g_ppm.loop.err

        genop('mov','m_word [' rcode ']', +t1)
        genop('jmp','err_')
                                                        :(g_ppm.loop.next)
g_ppm.loop.ppm

*            check each ppm case and take branch if appropriate

        ident(i.text(i1))                               :s(g_ppm.2)
        count.ppm = count.ppm + 1
        genop('jmp',    getarg(i1))
                                                        :(g_ppm.loop.next)

g_ppm.2

*       a ppm with no arguments, which should never be executed, is
*       translated to err 299,internal logic error: unexpected ppm branch

        t1 = 299
        errfile =  t1 ' internal logic error            : unexpected ppm branch'
                                                        :(g_ppm.loop.err)

*	*   1.15 ERB  _int,text_  error branch

*	This instruction resembles ERR except that it may occur at any point where a branch is permitted.
*	It effects a transfer of control to the error section with the error code in WA.

g_erb
        errfile =  i.text(i1) ' ' i.text(i2)
*            set rcode to error code and branch to error handler
        genop('mov', 'm_word [' rcode ']',  +(i.text(i1)))
        genop('jmp','err_')
                                                        :(opdone)


g_icv

        genop('inc',getarg(i1))                         :(opdone)

g_dcv

        genop('dec',getarg(i1))                         :(opdone)

g_zer

        ident(i.text(i1),'(xr)+') genop('mov',w0,'0')
+               genop('stos_w')                         :s(opdone)
        isreg(i1)                                       :s(g_zer1)
        ident(i.text(i1),'-(xs)')                       :s(g_zer.xs)
        genop('mov',w0,'0')
        genop('mov',getarg(i1),w0)                      :(opdone)

g_zer1

        t1 = getarg(i1)
        genop('xor',t1,t1)                              :(opdone)

g_zer.xs

        genop('push','0')                               :(opdone)

g_mnz

        genop('mov',getarg(i1),xs)                      :(opdone)

g_ssl
g_sss
g_rtn

        genop()                                         :(opdone)


g_ieq   jop = 'je'                                      :(op.cmp)
g_ige   jop = 'jge'                                     :(op.cmp)
g_igt   jop = 'jg'                                      :(op.cmp)
g_ile   jop = 'jle'                                     :(op.cmp)
g_ilt   jop = 'jl'                                      :(op.cmp)
g_ine   jop = 'jne'                                     :(op.cmp)
op.cmp

        genop('sti_',w0)
        genop('or',w0,w0)
        genop(jop,getarg(i1))                           :(opdone)

*       real operations

*       lch requires separate cases for each first operand possibility.

g_scg_0

        leq('-',substr(t2,1,1))                         :f(g_scg_1)
        t2 break('(') len(1) len(2) . t3
        genop('dec',register(t3))
        (eq(cfp_b,cfp_c) genop('dec',register(t3)), genop('sub',register(t3),'cfp_b'))
g_scg_1

        t2 break('(') len(1) len(2) . t3
        eq(cfp_b,cfp_c) genop('mov',w0,t1,)
        eq(cfp_b,cfp_c) genop('mov','[' register(t3) ']','al')
        ne(cfp_b,cfp_c) genop('mov','m_char [' register(t3) ']',t1)
*       see if postincrement needed.
        t2 rtab(1) '+'                                  :f(g_scg_2)
        (eq(cfp_b,cfp_c) genop('inc',register(t3)), genop('add',register(t3),'cfp_b'))

g_scg_2                                                 :(opdone)
g_scg_w

*       here if moving character from work register, convert t1
*       to name of low part.

        t1 = (eq(cfp_b,cfp_c) reglow(getarg(i1)), getarg(i1))

        ident(t2,'(xl)')                                :s(g_scg_w.xl)
        ident(t2,'-(xl)')                               :s(g_scg_w.pxl)
        ident(t2,'(xl)+')                               :s(g_scg_w.xlp)
        ident(t2,'(xr)')                                :s(g_scg_w.xr)
        ident(t2,'-(xr)')                               :s(g_scg_w.pxr)
        ident(t2,'(xr)+')                               :s(g_scg_w.xrp)

g_scg_w.xl

        genop('mov','m_char [' register(xl) ']',t1)                   :(opdone)

g_scg_w.pxl

        (eq(cfp_b,cfp_c)  genop('dec', xl), genop('sub',xl, 'cfp_b'))
        genop('mov','m_char [' register(xl) ']',t1)                   :(opdone)

g_scg_w.xlp

        genop('mov','m_char [' register(xl) ']',t1)
        (eq(cfp_b,cfp_c)  genop('inc', xl), genop('add',xl, 'cfp_b'))
                                                        :(opdone)
g_scg_w.xr

        genop('mov','m_char [' register(xr) ']',t1)                   :(opdone)

g_scg_w.pxr

        (eq(cfp_b,cfp_c)  genop('dec', xr), genop('sub',xr, 'cfp_b'))
        genop('mov','m_char [' register(xr) ']',t1)                   :(opdone)

g_scg_w.xrp

        (eq(cfp_b,cfp_c) genop('mov','al',t1), genop('mov','eax',t1))
        genop('stos_b')                                 :(opdone)



*	*   7.8  LSX  _w,(x)_

*	Left shift _w_ by the  number of bits in _x_


*	The above shifts are logical shifts in which bits shifted out are lost and zero bits supplied 
*	as required. The shift count is in the range 0-CFP$N .

g_lsx

        error('lsx not supported')

g_zzz

        genop('zzz',getarg(i1))                         :(opdone)


*	*   8.7  CTW  _w,val_

*	This instruction computes the sum (number of words required to store 
*	w characters) + (val). the sum is stored in _w_.

*	For example, CFP$C is 5, and WA contains 32, then CTW WA,2 gives a result of 9 in WA.


g_ctw

*       assume cfp_c chars per word

        t1 = getarg(i1)
        eq(cfp_b,cfp_c)                                 :s(g_ctw.1)

*       here if one word per character, so just add character count

        genop('add',t1,i.text(i2))
                                                        :(opdone)
g_ctw.1

        genop('add',t1,'(cfp_c-1)+cfp_c*' i.text(i2))
        genop('shr',t1,'log_cfp_c')
                                                        :(opdone)
g_sec

        genop('')
        sectnow = sectnow + 1                           :($("g_sec." sectnow))

*  procedure declaration section

g_sec.1

        genop('segment .text')
        genop('global','sec01')
        genopl('sec01' ':')                             :(opdone)

*       definitions section

g_sec.2

        genop('segment .data')
        genop('global','sec02')
        genopl('sec02' ':')                             :(opdone)

*  constants section

g_sec.3

        genop('segment .data')
        genop('global','sec03')
        genopl('sec03' ':')                             :(opdone)

*  working variables section

g_sec.4

        genop('global','esec03')
        genopl('esec03' '                               :')
        genop('segment .data')
        genop('global','sec04')
        genopl('sec04' ':')                             :(opdone)

*       here at start of program section.  if any n type procedures,
*       put out entry-word block declaration at end of working storage

g_sec.5

*       emit code to indicate in code section
*       get direction set to up.

        genop('global','esec04')
        genopl('esec04' '                               :')

*             (gt(prc.count1) genopl('prc$' ':','times', prc.count1 ' dd 0'))

        genop('prc_                                     : times ' prc.count1 ' dd 0')
        genop('global','lowspmin')
        genopl('lowspmin' '                             :','d_word','0')
        genop('global','end_min_data')
        genopl('end_min_data' '                         :')
        genop('segment .text')
        genop('global','sec05')
        genopl('sec05' ':')                             :(opdone)

*       stack overflow section.  output exi__n tail code

g_sec.6

        genop('global','sec06')
        genopl('sec06'  '                               :', 'nop')
                                                        :(opdone)

*       error section.  produce code to receive erb's

g_sec.7

        genop('global','sec07')
        genopl('sec07' '                                :')
        flush()
*       error section.  produce code to receive erb's

*            allow for some extra cases in case of max.err bad estimate
        n1 = max.err + 8
        output = '  max.err ' max.err
        genopl('err_                                    :','xchg',wa,'m_word [' rcode ']')
                                                        :(opdone)


opdone

        flush()                                         :(opnext)
opdone.end
g_end

        &dump = 2
        &dump = 0
        ident(havehdr)                                  :s(g_end.2)

*       here to copy remaining part from hdr file

g_end.1

        line = hdrfile                                  :f(g_end.2)
        ntarget = ntarget + 1
        output_lines = output_lines + 1
        outfile = line                                  :(g_end.1)

g_end.2

*       here at end of code generation.

        endfile(1)
        endfile(2)
        endfile(3)
        report(input_lines,          'lines read')
        report(nstmts,          'statements processed')
        report(ntarget,         'target code lines produced')
        report(&stcount,        'spitbol statements executed')
        report(max.err,         'maximum err/erb number')
        report(prc.count1,      'prc count')
        output  = '  ' gt(prc.count,prc.count1)
.         '  differing counts for n-procedures          :'
.         ' inp ' prc.count1 ' prc ' prc.count
        differ(nerrors) report(nerrors,'errors detected')

        errfile = '* ' max.err ' maximum err/erb number'
        errfile  = '* ' prc.count ' prc count'
.               differ(lasterror) '  the last error was in line ' lasterror

        &code   = ne(nerrors) 2001
        report(collect(), 'free words')
                                                        :(end)

*	*   1.16 ICV   _opn_  increment value by one

*	ICV increments the value of the operand by unity.

*	*   1.17 DCV   _opn_      decrement value by one

*	DCV decrements the value of the operand by unity.

*	*   1.18 ZER   _opn_ zeroise  _opn_

*	ZER is equivalent to MOV =zeroe,_opn_

*	*   1.19 MNZ   _opn_ move non-zero to  _opn_


*	Any non-zero collectable value may used, for which the opcodes *bnz/bze* will branch/fail to branch.


*	*   1.20 SSL   _opw_      subroutine stack load

*	*   1.21 SSS   _opw_      subroutine stack store

*	This pair of operations is provided to make possible the use of a local stack to hold 
*	subroutine (subroutine) return links for n-type procedures.

*	SSS stores the subroutine stack pointer in _opw_ and SSL loads the subroutine stack pointer from _opw_.

*	By using SSS in the main program or on entry to a procedure which should regain control on occurrence of an
*	ERR or ERB and by use of SSL in the error processing sections the subroutine stack
*	pointer can be restored giving a link stack cleaned up ready for resumed execution.

*	The form of the link stack pointer is undefined in MINIMAL (it is likely to be a private register known to the
*	translator) and the only requirement is that it should fit into a single full word.

*	SSL and SSS are no-ops if no private link stack is not used.

*	*   1.22 RTN define start of routine


*	However it is entered by any type of conditional or unconditional branch (not by JSR).

*	On termination it passes control by a branch (often BRI through a code word) or even permits control to drop through to another routine.

*	No return link exists and the end of a routine is not marked by an explicit opcode (compare ENP).

*	All routines must be named in section 0 INR statements.  

*	#### 2-  Operations on One Word Integer Values (addresses)


*	*   2.1  ADD   _opn,opv_

*	Adds  _opv_ to the value in  _opn_ and stores the result in  _opn_. 
*	Undefined if the result exceeds CFP$L .

g_add
	memmem()
        genop('add',getarg(i1),getarg(i2))              :(opdone)

*	*   2.2  SUB   _opn,opv_

*	Subtracts _opv_ from _opn_, and stores the result in _opn_. Undefined if the result is negative.

g_sub

	memmem()
        genop('sub',getarg(i1),getarg(i2))              :(opdone)

*	*   2.3  ICA   _opn_

*	Increment address in  _opn_ *	Equivalent to ADD  _opn_,*unity

g_ica   genop('add',getarg(i1),'cfp_b')                 :(opdone)

*	*   2.4  DCA   _opn_

*	Decrement address in _opn_ equivalent to SUB _opn_,*unity

g_dca   genop('sub',getarg(i1),'cfp_b')                 :(opdone)

*	*   2.5  BEQ   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ eq  _opv_


*	*   2.6  BNE   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ ne  _opv_

*	*   2.7  BGT   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ gt  _opv_

*	*   2.8  BGE   _opn,opv,plbl_


*	Branch to _plbl_  _opn_ ge  _opv_

*	*   2.9  BLT   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ lt  _opv_

*	*   2.10 BLE   _opn,opv,plbl_

*	Branch to _plbl_  _opn_ le  _opv_

*	*   2.11 BLO   _opn,opv,plbl_

*	Equivalent to BLT or ble

*	*   2.12 BHI   _opn,opv,plbl_

*	Equivalent to BGT or BGE

*	The above instructions compare two address values as unsigned integer values.  The BLO and BHI 
*	instructions are used in cases where the equal condition either does not occur or can result 
*	either in a branch or no branch.

*	This avoids inefficient translations in some implementations.

g_beq
g_bne
g_bgt
g_bge
g_blt
g_ble
g_blo
g_bhi

*       these operators all have two operands, memmem may apply
*       issue target opcode by table lookup.

        memmem()
        t1 = branchtab[incode]
        genop('cmp',getarg(i1),getarg(i2))
        genop(branchtab[incode],getarg(i3))
.                                                       :(opdone)

*	*   2.13 BNZ   _opn,plbl_

*	Equivalent to BNE  _opn_,=zeroe,_plbl_

*	*   2.14 BZE   _opn,plbl_

*	Equivalent to BEQ  _opn_,=zeroe,_plbl_

g_bnz

        isreg(i1)                                       :s(g_bnz1)
        genop('cmp', getarg(i1) ,'0')
        genop('jnz',getarg(i2))
                                                        :(opdone)
g_bnz1

        genop('or',getarg(i1),getarg(i1))
        genop('jnz',getarg(i2))
                                                        :(opdone)

g_bze   isreg(i1)                                       :s(g_bze1)

        genop('cmp', getarg(i1)  ,'0')
        genop('jz',getarg(i2))
                                                        :(opdone)
g_bze1

        t1 = getarg(i1)
        genop('or',t1,t1)
        genop('jz',getarg(i2))                          :(opdone)

*	*   2.15 LCT  _w,opv_

*	Load counter for BCT

*	LCT loads a counter value for use with the BCT instruction. The value in _opv_ is 
*	the number of loop operations to be executed.

*	The value in _w_ after this operation is an undefined one word integer quantity.

g_lct

*       if operands differ must emit code

        differ(i.text(i1),i.text(i2))                   :s(g_lct.1)

*       here if operands same. emit no code if no label, else emit null

        ident(thislabel)                                :s(opnext)
        genop()                                         :(opdone)

g_lct.1

        genop('mov',getarg(i1),getarg(i2))              :(opdone)

*	*   2.16 BCT  _w,plbl_

*	Branch and count

*	BCT uses the counter value in w to branch the required number of times and then finally to fall
*	through to the next instruction.

*	BCT can only be used following an appropriate LCT instruction.

*	The value in _w_ after execution of BCT is undefined.

g_bct

*       can issue loop if target register is cx.

        t1 = getarg(i1)
        t2 = getarg(i2)
                                                        :(g_bct2)
        ident(t1,wa)                                    :s(g_bct1)

g_bct2

        genop('dec',t1)
        genop('jnz',t2)                                 :(opdone)

g_bct1

        genop('loop',t2)                                :(opdone)

*	*   2.17 AOV   _opn,opv,plbl_

*	ADD with carry test

*	Adds  _opv_ to the value in  _opn_ and stores result in _opn_.

*	Branches to _plbl_ result exceeds CFP$L with result in  _opn_ undefined. cf. ADD

g_aov

        genop('add',getarg(i2),getarg(i1))
        genop('jc',getarg(i3))
                                                        :(opdone)
*	*   2.18 BEV   _opn,plbl_

*	Branch even

*	*   2.19 BOD   _opn,plbl_

*	Branch odd

*	These operations are used only .cepp or .crpp is defined.

*	On some implementations, a more efficient implementation is possible by noting that address of 
*	blocks must always be a multiple of CFP$B. We call such addresses even.

*	Thus return address on the stack (.crpp) and entry point addresses (.cepp) can be distinguished 
*	from block addresses they are forced to be odd (not a *	multiple of CFP$B ). 
*	EV and BOD branch according as operand is even or odd, respectively.

g_bev

        t1 = getarg(i1)
        t1 = eq(i.type(i1),8) reglow(t1)
        genop('test',t1,'1')
        genop('je',getarg(i2))
                                                        :(opdone)
g_bod

        t1 = getarg(i1)
        t1 = eq(i.type(i1),8) reglow(t1)
        genop('test',t1,'1')
        genop('jne',getarg(i2))                         :(opdone)

*	 #### 3- Operations on the Code Pointer Register

*	(CP )

*	The code pointer register provides a psuedo instruction counter for use in an interpretor. It may 
*	be implemented as a real register or as a memory location, but in either case it is separate 
*	from any other register.

*	*   3.1  LCP   _reg_

*	Load code pointer register

*	This instruction causes the code pointer register to be set from the
*	value in _reg_ which is unchanged

g_lcp   genop(op_,getarg(i1))                        	:(opdone)

*	*   3.2  SCP   _reg_

*	Store code pointer register this instruction loads the current value in the code pointer 
*	register into reg_ (CP ) is unchanged.

g_scp        genop(op_,getarg(i1))                     	:(opdone)

*	*   3.3  LCW  _reg_

*	Load next code word

*	This instruction causes the word pointed to by CP to be loaded into the indicated reg_
*	 The value in CP is then incremented by one word.

*	Execution of LCW may destroy XL .

g_lcw  genop(op_,getarg(i1))                           	:(opdone)

*	*   3.4  ICP

*	Increment CP  by one word

*	On machines with more than three index registers, CP can be treated simply as an index register.

*	Current implementation keeps *CP* in memory.

g_icp   genop(op_,getarg(i1))                          	:(opdone)

*	#### 4-  Operations on Signed Integer Values

*	*   4.1  LDI   _ops_

*	Load integer accumulator from  _ops_

g_ldi

        genop('mov',ia,getarg(i1))			:(opdone)

*	*   4.2  ADI   _ops_

*	ADD  _ops_ to integer accumulator

g_adi

        genop('add',ia,getarg(i1))                    :(opdone)

*	*   4.3  MLI   _ops_

*	Multiply integer accumulator by  _ops_

g_mli

        genop('imul',ia,getarg(i1))                   :(opdone)

*	*   4.4  SBI   _ops_

*	Subtract  _ops_ from int accumulator

g_sbi

        genop('sub',ia,getarg(i1))                    :(opdone)

*	*   4.5  DVI   _ops_

*	Divide integer accumulator by  _ops_

g_dvi


        genop('mov',w0,ia)
        genop('cdq')
        genop('idiv',getarg(i1))
        genop('mov',ia,w0)
                                                        :(opdone)

*	*   4.6  RMI   _ops_

*	Set integer accumulator to `mod(intacc,_ops_)`

g_rmi
        genop('mov',w0,ia)
        genop('cdq')
        genop('idiv',getarg(i1))
        genop('mov',ia,wc)
                                                        :(opdone)
*	*   4.7  STI   _ops_

*	Store integer accumulator at  _ops_

*	*   4.8  NGI

*	Negate the value in the integer accumulator (change its sign)

*	*   4.9  INO  _plbl_

*	Jump to _plbl_ if no integer overflow

*	*   4.10 IOV  _plbl_

*	Jump to _plbl_ if integer overflow

*	These instructions can only occur immediately following an instruction which can cause 
*	integer overflow (ADI, SBI MLI DVI RMI ngi) and test the result of the preceding instruction.

*	IOV and INO may not have labels.

*	*   4.11 IEQ  _plbl_

*	Jump to _plbl_ if (IA) eq 0

*	*   4.12 IGE  _plbl_

*	Jump to _plbl_ if (IA) ge 0

*	*   4.13 IGT  _plbl_

*	Jump to _plbl_ if (IA) gt 0

*	*   4.14 ILE  _plbl_

*	Jump to _plbl_ if (IA) le 0

*	*   4.15 ILT  _plbl_

*	Jump to _plbl_ if (IA) lt 0

*	*   4.16 INE  _plbl_

*	Jump to _plbl_ if (IA) ne 0

*	The above conditional jump instructions do not change the contents of the accumulator.

g_sti

        genop('mov',getarg(i1),ia)                    	:(opdone)

g_ngi
        genop('neg',ia)                               	:(opdone)

g_ino
g_iov

        genop(op_,getarg(i1))                           :(opdone)

*	 #### 5- Operations on Real Values 

*	*   5.1  LDR   _ops_

*	Load real accumulator from  _ops_

*	*   5.2  STR   _ops_

*	Store real accumulator at  _ops_


*	*   `5.3  ADR   _ops_

*	ADD  _ops_ to real accumulator

*	*   5.4  SBR   _ops_

*	Subtract  _ops_ from real accumulator


*	*   5.5  MLR   _ops_

*	Multiply real accumulator by  _ops_

*	*   5.6  DVR   _ops_

*	Divide real accumulator by  _ops_

*	If the result of any of the above operations causes underflow, the result yielded is 0.0.

*	The result of any of the above operations is undefined or out of range, real overflow is set,
*	 the contents of (RA) are undefined and the following instruction must be either ROV or RNO.

*	Particular care may be needed on target machines having distinct overflow and divide by zero conditions.

g_ldr
g_str
g_adr
g_sbr
g_mlr
g_dvr

        t1 = getarg(i1,'m_word')
        genop('lea',w0,t1)
        genop('call',op_)
                                                        :(opdone)
*	*   5.7  ROV  _plbl_

*	Jump to _plbl_ real overflow

*	*   5.8  RNO  _plbl_

*	Jump to _plbl_ no real overflow

*	These instructions can only occur immediately following an instruction which can cause real 
*	overflow (ADR,SBR MLR DVR.

g_rov
g_rno
        genop(op_,getarg(i1))                           :(opdone)

*	*   5.9 NGR

*	Negate real accumulator (change sign)

g_ngr genop('call',op_)
                                                        :(opdone)
*	*   5.10 REQ  _plbl_

*	Jump to _plbl_ if (RA) eq 0.0

*	*   5.11 RGE  _plbl_

*	Jump to _plbl_ if (RA) ge 0.0

*	*   5.12 RGT  _plbl_

*	Jump to _plbl_ if (RA) gt 0.0


*	*   5.13 RLE  _plbl_

*	Jump to _plbl_ if (RA) le 0.0

*	*   5.14 RLT  _plbl_

*	Jump to _plbl_ if (RA ) lt 0.0

*	*   5.15 RNE  _plbl_

*	Jump to _plbl_ if (RA) ne 0.0

*	The above conditional instructions do not affect the value stored in the real accumulator.

g_req   jop = 'je'                                      :(g_r1)
g_rne   jop = 'jne'                                     :(g_r1)
g_rge   jop = 'jge'                                     :(g_r1)
g_rgt   jop = 'jg'                                      :(g_r1)
g_rle   jop = 'jle'                                     :(g_r1)
g_rlt   jop = 'jl'
g_r1    genop('call','cpr_')

        genop('mov','al','byte [reg_fl]')
        genop('or','al','al')
        genop(jop,getarg(i1))                           :(opdone)

*	*   5.16 ATN

*	Arctangent of real accumulator

*	*   5.17 CHP

*	Integer portion of real accumulator

*	*   5.18 COS

*	Cosine of real accumulator

*	*   5.19 ETX

*	e to the power in the real accumulator

*	*   5.20 LNF

*	Natural logorithm of real accumulator

*	*   5.21 SIN

*	Sine of real accumulator

*	*   5.22 SQR

*	square root of real accumulat

*	*   5.23 TAN

*	Tangent of real accumulator


*	The above orders operate upon the real accumulator, and replace the contents of the 
*	accumulator with the result.

*	The result of any of the above operations is undefined or out of range, real overflow is set,
*	the contents of (RA) are undefined and the following instruction must be either ROV or RNO

g_atn
g_chp
g_cos
g_etx
g_lnf
g_sin
g_sqr
g_tan

        genop('call',op_)
                                                        :(opdone)

*	#### 6-  Operations on Character Values


*	Character operations employ the concept of a character pointer which
*	uses either index register XR or XL (not XS ).

*	A character pointer points to a specific character in a string of
*	characters stored CFP$C chars to a word.

*	The only operations permitted on a character pointer are LCH
*	and SCH. In particular, a character pointer may not even be moved with MOV

*	*   6.1  PLC  _x,opv_

*	Prepare ch ptr for LCH CMC mvc,TRC MCB

*	*   6.2  PSC  _x,opv_

*	Prepare character pointer for SCH MVC MCB

*	_opv_ can be omitted it is zero.

*	The character initially addressed is determined by the word address in _x_ and 
*	the integer offset _opv_.

*	There is an automatic implied offset of CFP$F bytes.  CFP$F is used to formally introduce 
*	into MINIMAL a value needed in translating these opcodes which, since MINIMAL itself 
*	does not prescribe a string structure in detail, depends on the choice of a 
*	data structure for strings in the MINIMAL program.  e.g_ CFP$B =
*	CFP$C = 3, CFP$F = 6, num01 = 1,

*	XL points to a series of 4 words, abc/def/ghi/jkl, then PLC XL ,=num01 points to h.

g_plc
g_psc

        ne(cfp_b,cfp_c)                                 :s(g_plc.1)

*       last arg is optional.  if present and a register or constant,
*       use lea instead.

        t1 = getarg(i1)
        t2 = i.type(i2)
        ((isreg(i2), ge(t2,1) le(t2,2))
+       genop('lea',t1,'[cfp_f+' t1 '+' getarg(i2) ']')):s(opdone)
        genop('add',t1,'cfp_f')
        eq(i.type(i2))                                  :s(opdone)

*       here if d_offset_(given (in a variable), so add it in.

        genop('add',t1,getarg(i2))                      :(opdone)

g_plc.1

*       here for case where character size if word size last arg is optional.
*	if present and a register or constant, use lea instead.

        t1 = getarg(i1)
        t2 = i.type(i2)
        ((isreg(i2), ge(t2,1) le(t2,2))
+       genop('lea',t1,'[cfp_f+' t1 '+' 'cfp_b*' getarg(i2) ']')):s(opdone)
        genop('add',t1,'cfp_f')
        eq(i.type(i2))                                  :s(opdone)

*       here if d_offset_(given (in a variable), so add it in, after converting to byte count
        genop('mov',w0, getarg(i2))
        genop('sal',w0, 'log_cfp_b')

        genop('add',t1,w0)                              :(opdone)

*	*   6.3  LCH  _reg,opc_

*	Load character into register

g_lch

        t2 = i.text(i2)
        t1 = getarg(i1)

*       see if predecrement needed.
        leq('-',substr(t2,1,1))                         :f(g_lcg_1)
        t2 break('(') len(1) len(2) . t3
        (eq(cfp_b,cfp_c) genop('dec',register(t3)), genop('sub',register(t3),'cfp_b'))

g_lcg_1

        t2 break('(') len(1) len(2) . t3
        eq(cfp_b,cfp_c) genop('mov',w0,'0')
        eq(cfp_b,cfp_c) genop('mov','al','m_char [' register(t3) ']')
        eq(cfp_b,cfp_c) genop('mov',t1,w0)

        ne(cfp_b,cfp_c) genop('mov',t1,'m_char [' register(t3) ']')

*       see if postincrement needed.
        t2 rtab(1) '+'                                  :f(g_lcg_2)
        (eq(cfp_b,cfp_c) genop('inc',register(t3)), genop('add',register(t3),'cfp_b'))

g_lcg_2                                                 :(opdone)

*	*   6.4  SCH  _reg,opc_

*	Store character from _reg_

*	These operations are defined such that the character is right justified in register 
*	_reg_ with zero bits to the left.

g_sch

        t2 = i.text(i2)
        eq(i.type(i1),8)                                :s(g_scg_w)
        t1 = getarg(i1)
        eq(cfp_b,cfp_w)                                 :f(g_scg_0)
        ident(t2,'(xr)+')                               :f(g_scg_0)

*       here if can use stos.

        eq(cfp_b,cfp_c) genop('mov',w0_l,getarg(i1))
        ne(cfp_b,cfp_c) genop('mov',w0,getarg(i1))
        genop('stos_b')                                 :(opdone)

*	*   6.5  CSC  _x_

*	Complete store characters

*	This instruction marks completion of a PSC sch,SCH ...,sch sequence initiated by a
*	PSC x instruction.

*	No more SCH instructions using x should be obeyed until another PSC is obeyed.

*	It is provided solely as an efficiency aid on machines without character orders since it 
*	permits use of register buffering of chars in sch sequences.

*	Where CSC is not a no-op, it must observe restriction 2. (e.g_ in SPITBOL, *alocs* 
*	zeroises the last word of a string frame prior to SCH sequence being started so CSC 
*	must not nullify this action.)

*	The following instructions are used to compare two words containing
*	CFP$C characters.

*	Comparisons distinct from BEQ BNE are provided as on some target machines, the possibility 
*	of the sign bit being set may require special action.

*	Note that restriction 2 above, eases use of these orders in testing complete strings for 
*	equality, since whole word tests are possible.

g_csc   ident(thislabel)                                :s(opnext)

        genop()                                         :(opdone)

*	*   6.6  CEQ   _opw,opw,plbl_

*	Jump to _plbl_  _opw_ eq  _opw_

g_ceq

        memmem()
        genop('cmp',getarg(i1),getarg(i2))
        genop('je',getarg(i3))
                                                        :(opdone)
*	*   6.7  CNE   _opw,opw,plbl_

*	Jump to _plbl_  _opw_ ne  _opw_

g_cne   memmem()

        genop('cmp',getarg(i1),getarg(i2))
        genop('jnz',getarg(i3))
                                                        :(opdone)
*	*   6.8  CMC  _plbl_,_plbl_

*	Compare characters

*	CMC is used to compare two character strings. before executing CMC registers are 
*	set up as follows.

*	```
*	            (XL)             character ptr for first string
*	            (XR)             character pointer for second string
*	            (WA)             character count (must be .gt. zero)
*	```

*	XL and XR should have been prepared by PLC control passes to first _plbl_ the first string is 
*	lexically less than the second string, and to the second _plbl_ the first string is lexically greater.

*	Control passes to the following instruction the strings are identical. after executing this 
*	instruction, the values of XR and XL are set to zero and the value in (WA) is undefined.

*	Arguments to CMC may be complete or partial strings, so making optimisation to use whole word 
*	comparisons difficult (dependent in general on shifts and masking).

g_cmc

        genop('repe','cmps_b')
        genop('mov',xl,'0')
        genop('mov',xr,xl)
        t1 = getarg(i1)
        t2 = getarg(i2)
        (ident(t1,t2) genop('jnz',t1))                  :s(opdone)
        genop('ja',t2)
        genop('jb',t1)                                  :(opdone)

*	*   6.9  TRC

*	Translate characters

*	TRC is used to translate a character string using a supplied translation table.
*	Before executing *trc* the registers are set as follows.

*	```
*	            (XL)             char ptr to string to be translated
*	            (XR)             char ptr to translate table
*	            (WA)             length of string to be translated
*	```

*	XL and XR should have been prepared by PLC the translate table consists of CFP$A* 
*	contiguous characters giving the translations of the CFP$A* characters in the alphabet.

*	On completion, (XR ) and (XL ) are set to zero and (WA) is undefined.

g_trc

        genop('xchg',xl,xr)
        eq(cfp_b,cfp_c) genopl((t1 = genlab()) '        :','movzx',w0,'m_char [' register(xr) ']')
        ne(cfp_b,cfp_c) genopl((t1 = genlab()) '        :','mov',w0,'m_char [' register(xr) ']')
        ne(cfp_b,cfp_c) genop('sal', w0, 'log_cfp_b');* convert char value to byte offset
        eq(cfp_b,cfp_c) genop('mov','al', '[' xl '+' w0 ']')
        ne(cfp_b,cfp_c) genop('mov',w0,'[' xl '+' w0 ']')
        genop('stos' op_c)
*            genop('loop',t1)
        genop('dec',wa)
        genop('jnz',t1)
        genop('xor',xl,xl)
        genop('xor',xr,xr)
                                                        :(opdone)
*	*   6.10 FLC  _w_

*	Fold character to upper case

g_flc

        output = 'flc  not supported ' (end)
        t1 = (eq(cfp_b,cfp_c) reglow(getarg(i1)), getarg(i1))
        t2 = genlab()

*       z_suspend = 1

        genop('cmp',t1,"'A'")
        genop('jb', t2 )
        genop('cmp',t1,"'Z'")
        genop('ja', t2)
        genop('add',t1,'32')
        genopl(t2 '                                     :')

*       z_suspend = 0
                                                        :(opdone)
*	#### 7- Operations on Bit String Values

*	*   7.1  ANB   _w,opw_

*	And bit string values, result in _w_

g_anb   genop('and',getarg(i1),getarg(i2))              :(opdone)

*	*   7.2  ORB   _w,opw_

*	Or bit string values, result in _w_

g_orb   genop('or',getarg(i1),getarg(i2))               :(opdone)

*	*   7.3  XOB   _w,opw_

*	Exclusive or bit string values, result in _w_

*	In the above operations, the logical connective is applied separately to each of the CFP$N bits.
*	The result is stored in the second operand location.

g_xob   genop('xor',getarg(i1),getarg(i2))              :(opdone)

*	*   7.4  CMB  _w_

*	Complement all bits in _w_

*	This statement is NOT used in Minimal version of SPITBOL, so no need to translate it.

g_cmb   genop('not',getarg(i1))                         :(opdone)

*	*   7.5  RSH  _w,val_

*	Right shift _w_ by _val_ bits

g_rsh

        genop('shr',getarg(i1),getarg(i2))              :(opdone)


*	*   7.6  LSH  _w,val_

*	Left shift _w_ by _val_ bits

g_lsh

        genop('shl',getarg(i1),getarg(i2))              :(opdone)

*	*   7.7  RSX  _w,(x)_

*	Right shift _w_ by  number of bits in _x_

g_rsx

        error('rsx not supported')

*	*   7.9  NZB  w,_plbl_

*	Jump to _plbl_ w is not all zero bits.

g_nzb   isreg(i1)                                       :s(g_nzb1)

        genop('cmp',getarg(i1),'0')
        genop('jnz',getarg(i2))
                                                        :(opdone)
g_nzb1

        genop('or',getarg(i1),getarg(i1))
        genop('jnz',getarg(i2))
                                                        :(opdone)
*	*   7.10 ZRB  w,_plbl_

*	Jump to _plbl_ w is all zero bits

g_zrb   isreg(i1)                                       :s(g_zrb1)

        genop('cmp',getarg(i1),'0')
        genop('jz',getarg(i2))
                                                        :(opdone)
g_zrb1

        genop('or',getarg(i1),getarg(i1))
        genop('jz',getarg(i2))
                                                        :(opdone)
*	*   7.11 ZGB   _opn_

*	Zeroise garbage bits

*	_opn_ contains a bit string representing a word of characters from a string or 
*	some function formed from such characters (e.g_ as a result of hashing).

*	 On a machine where the word size is not a multiple of the character size,
*	 some bits in _reg_ may be undefined.

*	This opcode replaces such bits by the zero bit. ZGB is a no-op the word size is a
*	 multiple of the character size.

g_zgb

        genop('nop')                                    :(opdone)


*	#### 8-  Conversion Instructions


*	The following instructions provide for conversion between lengths in bytes and lengths in words.


*	*   8.1  WTB  _reg_

*	Convert  _reg_ from words to bytes.

*	That is, multiply by CFP$B . This is a no-op if CFP$B  is one.

g_wtb   genop('sal',getarg(i1),'log_cfp_b')             :(opdone)

*	*   8.2  BTW  _reg_

*	Convert _reg_ from bytes to words by dividing _reg_ by CFP$B discarding the fraction.
*	This is a  no-op if CFP$B is one

*	The following instructions provide for conversion of one word integer values (addresses) 
*	to and from the full signed integer format.

g_btw   genop('shr',getarg(i1),'log_cfp_b')             :(opdone)

*	*   8.3  MTI   _opn_

*	The value of _opn_ (an address) is moved as a positive integer to the integer accumulator.

g_mti   ident(i.text(i1),'(xs)+')                       :f(g_mti.1)

        genop('pop',w0)
        genop('ldi_',w0)                                :(opdone)

g_mti.1

        genop('ldi_',getarg(i1))                        :(opdone)

*	*   8.4  MFI   _opn,plbl_

*	The value currently stored in the integer accumulator is moved to _opn_ as an address 
*	it is in the range 0 to CFP$M inclusive.

*	If the accumulator value is outside this range, then the result in _opn_ 
*	is undefined and control is passed to _plbl_.

*	MFI destroys the value of (IA) whether or not integer overflow is signalled.  
*	_plbl_ may be omitted overflow is impossible.

*	The following instructions provide for conversion between real values and integer values.

g_mfi

*       last arg is optional
*       compare with cfp$m, branching if result negative

        eq(i.type(i2))                                  :s(g_mfi.1)

*       here if label given, branch if wc not in range (ie, negative)

        genop('sti_',w0)
        genop('or',w0,w0)
        genop('js',getarg(i2))

g_mfi.1

        ident(i.text(i1),'-(xs)')                       :s(g_mfi.2)
        genop('sti_',getarg(i1))                        :(opdone)

g_mfi.2

        genop('sti_',w0)
        genop('push',w0)                                :(opdone)

*	*   8.5  ITR

*	Convert integer value in integer accumulator to real and store in real accumulator 
*	(may lose precision in some cases)

g_itr

        genop('call','itr_')                            :(opdone)

*	*   8.6  RTI  _plbl_

*	Convert the real value in RA to an integer and place result in IA .  Conversion is 
*	by truncation of the fraction - no rounding occurs.

*	Jump to _plbl_ if RA out of range. *RA* is not changed in either case.

*	_plbl_ may be omitted overflow is impossible.

*	The following instructions provide for computing the length of storage required for a text string_

g_rti

        genop('rti_')
        eq(i.type(i1))                                  :s(opdone)

*       here if label given, branch if real too large

        genop('jc',getarg(i1))                          :(opdone)

*	*   8.8  CTB  _w,val_

*	CTB is exactly like CTW except that the result is in bytes.

*	The following instructions provide for conversion from integers to and from numeric 
*	digit characters for use in numeric conversion routines. They employ negative integer 
*	values to allow for proper conversion of numbers which cannot be complemented.


g_ctb

        t1 = getarg(i1)
        eq(cfp_b,cfp_c)                                 :s(g_ctb.1)

*       here if one word per character, so just add character count, then convert to byte count

        genop('add',t1,i.text(i2))
        genop('sal',getarg(i1),'log_cfp_b')             :(opdone)

g_ctb.1

        genop('add',t1,'(cfp_b-1)+cfp_b*' i.text(i2))
        genop('and',t1,'-cfp_b')
                                                        :(opdone)
*	*   8.9  CVM  _plbl_

*	Convert by multiplication

*	The integer accumulator, which is zero or negative, is multiplied by 10.  WB contains the 
*	character code for a digit. the value of this digit is then subtracted from the result.

*	The result is out of range, then control is passed to _plbl_ with the result in 
*	(IA) undefined. execution of CVM leaves the result in (WB ) undefined.

g_cvm   t1 = getarg(i1)

        genop('sti_',w0)
        genop('imul',w0,'10')
        genop('jo',t1)
        genop('sub',register(wb),'ch_d0')
        genop('sub',w0,register(wb))
        genop('ldi_',w0)
        genop('jo',t1)
                                                        :(opdone)

*	* 8.10 cvd

*	Convert by division

*	The integer accumulator, which is zero or negative, is divided by 10.
*	the quotient (zero or negative) is replaced in the accumulator.

*	The remainder is converted to the character code of a digit and placed in
*	WA. For example, an operand of -523 gives a quotient of -52 and a
*	remainder in WA of CH$D3.

g_cvd

        genop('cvd_')                                   :(opdone)

*	#### 9-  Block Move Instructions

*	The following instructions are used for transferring data from one area of memory 
	to another in blocks.  They can be implemented with the indicated series of other 
*	macro-instructions, but more efficient implementations will be possible on most machines.

*	Note that in the equivalent code sequence shown below, a zero value in WA will move at 
*	least one item, and may may wrap the counter causing a core dump in some imple- mentations.
*	  Thus WA should be greater than 0 prior to invoking any of these block move instructions.

*	*   9.1  MVC

*	Move characters


*	Before obeying this order WA,XL ,XR should have been set up, the latter two by PLC
*	PSC resp.  MVC is equivalent to the sequence

*	```
*	                   mov  dumpb,WB
*	                   lct  WA,WA
*	            loopc  lch  WB,(XL)+
*	                   sch  WB,(XR)+
*	                   bct  WA,loopc
*	                   csc  XR
*	                   mov  WB,dumpb

*	```

*	The character pointers are bumped as indicated and the final value of WA is undefined.

g_mvc

*            use word move if character size is word size
*            if charsize is word size, convert character count to byte count for word move

        ne(cfp_b,cfp_c) genop('shl', wa, 'log_cfp_b')
        ne(cfp_b,cfp_c)                                 :s(g_mvw)
        t1 = genlab()
        z_suspend = 1
        genop('rep')
        genop('movs_b')
        z_suspend = 0
                                                        :(opdone)

*	* 9.2  MVW

*	              move words


*	MVW is equivalent to the sequence

*	```
*	             opw  mov  (XR)+,(XL)+
*	             dca  WA              WA = bytes to move
*	             bnz  WA,lo opw

*	```



*	Note that this implies that the value in WA is the length in bytes which is a multiple of CFP$B .

*	The initial addresses in XR ,XL are word addresses.

*	As indicated, the final XR ,XL values point past the new and old regions of memory respectively.

*	The final value of WA is undefined.  WA,XL ,XR must be set up before obeying MVW

g_mvw

        z_suspend = 1
        genop('shr',wa,'log_cfp_b')
        genop('rep','movs_w')
        z_suspend = 0
                                                        :(opdone)

*	*   9.3  MWB

*	Move words backwards

*	MWB  is equivalent to the sequence

*	```
*	            loopb  mov  -(XL),-(XR)
*	                   dca  WA               WA = bytes to move
*	                   bnz  WA,loopb
*	```

*	There is a requirement that the initial value in XL be at least 256 less than the value in XR .

*	The final value of WA is undefined.

*	WA ,XL , XR must be set up before obeying MWB .

g_mwb

        genop('shr',wa,'log_cfp_b')
        genop('std')
        genop('lea',xl,'[xl-cfp_b]')
        genop('lea',xr,'[xr-cfp_b]')
        genrep('movs_w')
        genop('cld')                                    :(opdone)

        genop('std')
        genop('shr',wa,'log_cfp_b')
        genop('rep')
        genop('movs_w')
        genop('ctd')
                                                        :(opdone)

*	*   9.4  MCB

*	Move characters backwards


*	MCB is equivalent to the sequence

*	```
*	                   mov  dumpb,WB
*	                   lct  WA,WA
*	            loopc  lch  WB,-(XL)
*	                   sch  WB,-(XR)
*	                   bct  WA,loopc
*	                   csc  XR
*	                   mov  WB,dumpb
*	```


*	There is a requirement that the initial value in XL be at least 256 less than the value in XR.
*	This allows an implementation in which chunks of 256 bytes are moved forward (IBM 360, ICL 1900).

*	The final value of WA is undefined.  WA,XL ,XR must be set up before obeying MCB

g_mcb

*            use word move if character size is word size

        ne(cfp_b,cfp_c) genop('shl', wa, 'log_cfp_b')
        ne(cfp_b,cfp_c)                                 :s(g_mwb)
        genop('std')
        genop('dec',xl)
        genop('dec',xr)
        genrep('movs_b')
        genop('cld')
                                                        :(opdone)
        genop('std')
        genop('rep')
        genop('movs_b')
        genop('cld')
                                                        :(opdone)

*	#### 10- Operations Connected with the Stack


*	The stack is an area in memory which is dedicated for use in conjunction with the 
*	stack pointer register (XS ). As previously described, it is used by the JSR and EXI
*	instructions and may be used for storage of any other data as required.

*	The stack builds downward in this implementation.

*	The starting stack base address is passed in (XS ) at The start of execution.
	During execution it is necessary to make sure that the stack does not overflow.
*	This is achieved by executing the following instruction periodically.

*	*   10.1 CHK

*	Check stack overflow

*	After successfully executing CHK it is permissible to use up to 100 additional words 
	before issuing another chk thus CHK need not be issued every time the stack is
*	expanded. In some implementations, the checking may be automatic and CHK will have no effect.

g_chk

        genop('cmp',xs,'lowspmin')
        genop('jb','sec06')
                                                        :(opdone)

*	#### 11- Data Generation Instructions

*	The following instructions are used to generate constant values in the constant section 
*	and also to assemble initial values in the working storage section.
*	They may not appear except in these two sections.

*	*   11.1 DAC  _addr_

*	Assemble address constant.

*	Generates one word containing the specified one word integer value (address).

g_dac

        t1 = i.type(i1)
        t2 = "" ;*(le(t1,2) "", le(t1,4) "d_offset_(", le(t1,6) "d_offset_(", "")
        genopl(thislabel,'d_word',t2 i.text(i1))
                                                        :(decend)

*	*   11.2 DIC  _integer_

*	Generates an integer value which occupies CFP$I consecutive words.

*	The operand is a digit string with a required leading sign.

g_dic

        genopl(thislabel,'d_word',i.text(i1))
                                                        :(decend)
*	*   11.3 DRC  _real_

*	Assembles a real constant which occupies CFP$R consecutive words.

*	The operand form must obey the rules for a FORTRAN real constant with the extra 
*	requirement that a leading sign be present.

g_drc

        genop('align',8)
        t1 = i.text(i1)
        t1 ? fence "+" = ""
        genop('d_real',t1)

*       note that want to attach label to last instruction

        t.label(cstmts[cstmts.n]) = thislabel
        thislabel =                                     :(opdone)


*	*   11.4 DTC  _dtext_

*	Define _text_ constant.

*	Text is started and ended with any character not contained in the characters to be 
*	assembled. The constant occupies consecutive words as dictated by the 
*	configuration parameter CFP$C .

*	Any unused chars in the last word are right filled with zeros (i.e. the character whose 
*	internal code is zero).  The string contains a sequence of letters, digits, blanks and 
*	any of the following special characters.  =,$.(\*)/+-


*	No other characters may be used in a _dtext_ operand.

g_dtc

*       change first and last chars to " (assume / used in source)

        t1 = i.text(i1)
        t1 tab(1) rtab(1) . t2
        t3 = remdr(size(t2),cfp_c)

*             t2 = "'" t2 "'"
*       append nulls to complete last word so constant length is multiple
*       of word word

        dtc_i = 1
        t4 =

g_dtc.1

        t4 = gt(dtc_i, 1) t4 ","
        t4 = t4 "'" substr(t2,dtc_i,1) "'"
        le(dtc_i = dtc_i + 1, size(t2))                 :s(g_dtc.1)

        t4 = ne(t3) t4 dupl(',0',cfp_c - t3)
        genopl(thislabel,'d_char',t4)
                                                        :(opdone)
*	*   11.5 DBC  val

*	Assemble bit string constant.

*	The operand is a positive integer value which is interpreted in binary, 
*	right justified and left filled with zero bits. Thus 5 would imply the bit string value 00...101.  

g_dbc

        genopl(thislabel,'d_word',getarg(i1))		:(opdone)

decend

*       here at end of dic or dac to see if want label made public

        thislabel ? rtab(1) . thislabel '               :'
*       differ(pubtab[thislabel]) genop('global',thislabel)
                                                        :(opdone)

*	#### 12- Symbol Definition Instructions

*	The following instruction is used to define symbols in the definitions section.
*	 It may not be used elsewhere.

*	*   12.1 EQU  _eqop_

*	Define symbol

*	The symbol which appears in the label field is defined to have the absolute value given by the _eqop_ operand.
*	A given symbol may be defined only once in this manner, and any symbols occuring in _eqop_ 
*	must be previously defined.

g_equ

        genopl(thislabel,'equ',i.text(i1))
                                                        :(opdone)
*	*   12.2 *exp

*	Define external procedure

*	*exp* defines the symbol appearing in the label field to be the name of an external 
*	procedure which can be referenced in a subsequent JSR instruction.

*	The coding for the procedure is external to the coding of the source program in this language.
*	The code for external procedures may be referred to collectively as the operating system 
*	interface, or more briefly, osint, and will frequently be a separately compiled segment
*	of code loaded with SPITBOL to produce a complete system.

g_exp

        ppm_cases[thislabel] = i.text(i1)
        genop('extern',thislabel)
        thislabel =                                     	:(opdone)

*	*   12.3 INP  _ptyp_,int

*	Define internal procedure

*	INP defines the symbol appearing in the label field to be the name of an internal 
*	procedure and gives its type and number of exit parameters.

*	The label can be referenced in JSR instructions and it must appear labelling a
*	PRC instruction in the program section.

g_inp

        ppm_cases[thislabel] = i.text(i2)
        prc.count1 = ident(i.text(i1),'n') prc.count1 + 1	:(opnext)

*	*   12.4 INR

*	Define internal routine

*	INR defines the symbol appearing in the label field to be the name of an internal routine.

*	The label may be referenced in any type of branch order and it must appear labelling a
*	RTN instruction in the program section.


g_inr	genop('')						:(opdone)

*	### 13 - Assembly Listing Layout Instruction

*	Who uses listings these days? Who even knows what a listing is? Those were the days ...

*	*   13.1 EJC

*	Eject to next page


g_ejc								:(opnext)
*	*   13.2 TTL  text

*	Set new assembly title

*	TTL implies an immediate eject of the assembly listing to print the new title.

*	The use of TTL and EJC cards is such that the program will list neatly the 
*	printer prints as many as 58 lines per page. In the event that the printer depth
*	is less than this, or the listing contains interspersed lines (such as actual generated
*	code), then the format may be upset.


g_ttl								:(opnext)

end
