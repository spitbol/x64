       TTL  MINIMAL -- MACHINE INDEPENDENT MACRO ASSEMBLY LANG.
       EJC
*
*      THE FOLLOWING SECTIONS DESCRIBE THE IMPLEMENTATION
*      LANGUAGE ORIGINALLY DEVELOPED FOR SPITBOL BUT NOW MORE
*      WIDELY USED. MINIMAL IS AN ASSEMBLY LANGUAGE
*      FOR AN IDEALIZED MACHINE. THE FOLLOWING DESCRIBES THE
*      BASIC CHARACTERISTICS OF THIS MACHINE.
*
*      SECTION 1 - CONFIGURATION PARAMETERS
*
*      THERE ARE SEVERAL PARAMETERS WHICH MAY VARY WITH THE
*      TARGET MACHINE. THE MACRO-PROGRAM IS INDEPENDENT OF THE
*      ACTUAL DEFINITIONS OF THESE PARAMETERS.
*
*      THE DEFINITIONS OF THESE PARAMETERS ARE SUPPLIED BY
*      THE TRANSLATION PROGRAM TO MATCH THE TARGET MACHINE.
*
*      CFP$A                 NUMBER OF DISTINCT CHARACTERS IN
*                            INTERNAL ALPHABET IN THE RANGE
*                            64 LE CFP$A LE MXLEN.
*
*      CFP$B                 NUMBER OF BYTES IN A WORD WHERE A
*                            BYTE IS THE AMOUNT OF STORAGE
*                            ADDRESSED BY THE LEAST SIGNIFICANT
*                            ADDRESS BIT.
*
*      CFP$C                 NUMBER OF CHARACTERS WHICH CAN
*                            BE STORED IN A SINGLE WORD.
*
*      CFP$F                 BYTE OFFSET FROM START OF A STRING
*                            BLOCK TO THE FIRST CHARACTER.
*                            DEPENDS BOTH ON TARGET MACHINE AND
*                            STRING DATA STRUCTURE. SEE PLC, PSC
*
*      CFP$I                 NUMBER OF WORDS IN A SIGNED
*                            INTEGER CONSTANT
*
*      CFP$L                 THE LARGEST UNSIGNED INTEGER
*                            OF FORM 2**N - 1 WHICH CAN BE
*                            STORED IN A SINGLE WORD.  N WILL
*                            OFTEN BE CFP$N BUT NEED NOT BE.
*
*      CFP$M                 THE LARGEST POSITIVE SIGNED INTEGER
*                            OF FORM 2**N - 1 WHICH CAN BE
*                            STORED IN A SINGLE WORD.  N WILL
*                            OFTEN BE CFP$N-1 BUT NEED NOT BE.
*
*      CFP$N                 NUMBER OF BITS WHICH CAN BE STORED
*                            IN A ONE WORD BIT STRING.
*
*      CFP$R                 NUMBER OF WORDS IN A REAL CONSTANT
*
*      CFP$S                 NUMBER OF SIGNIFICANT DIGITS TO
*                            BE OUTPUT IN CONVERSION OF A REAL
*                            QUANTITY.
.IF    .CNCR
.ELSE
*                            THE INTEGER CONSISTING OF
*                            THIS NUMBER OF 9S MUST NOT BE TOO
*                            LARGE TO FIT IN THE INTEGER ACCUM.
.FI
*
.IF    .CUCF
*      CFP$U                 REALISTIC UPPER BOUND ON ALPHABET.
*
*
.FI
*      CFP$X                 NUMBER OF DIGITS IN REAL EXPONENT
       EJC
*
*      SECTION 2 - MEMORY
*
*      MEMORY IS ORGANIZED INTO WORDS WHICH EACH CONTAIN CFP$B
*      BYTES. FOR WORD MACHINES CFP$B, WHICH IS A CONFIGURATION
*      PARAMETER, MAY BE ONE IN WHICH CASE WORDS AND BYTES ARE
*      IDENTICAL. TO EACH WORD CORRESPONDS AN ADDRESS WHICH IS
*      A NON-NEGATIVE QUANTITY WHICH IS A MULTIPLE OF CFP$B.
*      DATA IS ORGANIZED INTO WORDS AS FOLLOWS.
*
*      1)   A SIGNED INTEGER VALUE OCCUPIES CFP$I CONSECUTIVE
*           WORDS (CFP$I IS A CONFIGURATION PARAMETER).
*           THE RANGE MAY INCLUDE MORE NEGATIVE NUMBERS THAN
*           POSITIVE (E.G. THE TWOS COMPLEMENT REPRESENTATION).
*
*      2)   A SIGNED REAL VALUE OCCUPIES CFP$R CONSECUTIVE
*           WORDS. (CFP$R IS A CONFIGURATION PARAMETER).
*
*      3)   CFP$C CHARACTERS MAY BE STORED IN A SINGLE WORD
*           (CFP$C IS A CONFIGURATION PARAMETER).
*
*      4)   A BIT STRING CONTAINING CFP$N BITS CAN BE STORED IN
*           A SINGLE WORD (CFP$N IS A CONFIGURATION PARAMETER).
*
*      5)   A WORD CAN CONTAIN A UNSIGNED INTEGER VALUE IN
*           THE RANGE (0 LE N LE CFP$L). THESE INTEGER VALUES
*           MAY REPRESENT ADDRESSES OF OTHER WORDS AND SOME OF
*           THE INSTRUCTIONS USE THIS FACT TO PROVIDE INDEXING
*           AND INDIRECTION FACILITIES.
*
*      6)   PROGRAM INSTRUCTIONS OCCUPY WORDS IN AN UNDEFINED
*           MANNER. DEPENDING ON THE ACTUAL IMPLEMENTATION,
*           INSTRUCTIONS MAY OCCUPY SEVERAL WORDS, OR PART OF
*           A WORD, OR EVEN BE SPLIT OVER WORD BOUNDARIES.
*
*      THE FOLLOWING REGIONS OF MEMORY ARE AVAILABLE TO THE
*      PROGRAM. EACH REGION CONSISTS OF A SERIES OF WORDS WITH
*      CONSECUTIVE ADDRESSES.
*
*      1)   CONSTANT SECTION           ASSEMBLED CONSTANTS
*      2)   WORKING STORAGE SECTION    ASSEMBLED WORK AREAS
*      3)   PROGRAM SECTION            ASSEMBLED INSTRUCTIONS
*      4)   STACK AREA                 ALLOCATED STACK AREA
*      5)   DATA AREA                  ALLOCATED DATA AREA
       EJC
*
*      SECTION 3 - REGISTERS
*
*      THERE ARE THREE INDEX REGISTERS CALLED XR,XL,XS. IN
*      ADDITION XL MAY SOMETIMES BE REFERRED TO BY THE ALIAS
*      OF XT - SEE SECTION 4. ANY OF THE ABOVE REGISTERS
*      MAY HOLD A POSITIVE UNSIGNED INTEGER IN THE RANGE
*      (0 LE N LE CFP$L). WHEN THE INDEX REGISTER IS USED FOR
*      INDEXING PURPOSES, THIS MUST BE AN APPROPRIATE ADDRESS.
*      XS IS SPECIAL IN THAT IT IS USED TO POINT TO THE TOP
*      ITEM OF A STACK IN MEMORY. THE STACK MAY BUILD UP OR
*      DOWN IN MEMORY.SINCE IT IS REQUIRED THAT XS POINTS TO THE
*      STACK TOP BUT ACCESS TO ITEMS BELOW THE TOP IS PERMITTED,
*      REGISTERS XS AND XT MAY BE USED WITH SUITABLE OFFSETS
*      TO INDEX STACKED ITEMS. ONLY XS AND XT MAY BE USED FOR
*      THIS PURPOSE SINCE THE DIRECTION OF THE OFFSET IS
*      TARGET MACHINE DEPENDENT. XT IS A SYNONYM FOR XL
*      WHICH THEREFORE CANNOT BE USED IN CODE SEQUENCES
*      REFERENCING XT.
*
*      THE STACK IS USED FOR S-R LINKAGE AND TEMPORARY
*      DATA STORAGE FOR WHICH THE STACK ARRANGEMENT IS SUITABLE.
*      XR,XL CAN ALSO CONTAIN A CHARACTER POINTER IN CONJUNCTION
*      WITH THE CHARACTER INSTRUCTIONS (SEE DESCRIPTION OF PLC).
       EJC
*
*      THERE ARE THREE WORK REGISTERS CALLED WA,WB,WC WHICH
*      CAN CONTAIN ANY DATA ITEM WHICH CAN BE STORED IN A
*      SINGLE MEMORY WORD. IN FACT, THE WORK REGISTERS ARE JUST
*      LIKE MEMORY LOCATIONS EXCEPT THAT THEY HAVE NO ADDRESSES
*      AND ARE REFERENCED IN A SPECIAL WAY BY THE INSTRUCTIONS.
*
*      NOTE THAT REGISTERS WA,WB HAVE SPECIAL USES IN CONNECTION
*      WITH THE CVD, CVM, MVC, MVW, MWB, CMC, TRC INSTRUCTIONS.
*
*      REGISTER WC MAY OVERLAP THE INTEGER ACCUMULATOR (IA) IN
*      SOME IMPLEMENTATIONS. THUS ANY OPERATION CHANGING THE
*      VALUE IN WC LEAVES (IA) UNDEFINED AND VICE VERSA
*      EXCEPT AS NOTED IN THE FOLLOWING RESTRICTION ON SIMPLE
*      DUMP/RESTORE OPERATIONS.
*
*          RESTRICTION
*          -----------
*
*      IF IA AND WC OVERLAP THEN
*          STI  IASAV
*          LDI  IASAV
*      DOES NOT CHANGE WC, AND
*          MOV  WC,WCSAV
*          MOV  WCSAV,WC
*      DOES NOT CHANGE IA.
*
*
*
*      THERE IS AN INTEGER ACCUMULATOR (IA) WHICH IS CAPABLE OF
*      HOLDING A SIGNED INTEGER VALUE (CFP$I WORDS LONG).
*      REGISTER WC MAY OVERLAP THE INTEGER ACCUMULATOR (IA) IN
*      SOME IMPLEMENTATIONS. THUS ANY OPERATION CHANGING THE
*      VALUE IN WC LEAVES (IA) UNDEFINED AND VICE VERSA
*      EXCEPT AS NOTED IN THE ABOVE RESTRICTION ON SIMPLE
*      DUMP/RESTORE OPERATIONS.
*
*
*
*      THERE IS A SINGLE REAL ACCUMULATOR (RA) WHICH CAN HOLD
*      ANY REAL VALUE AND IS COMPLETELY SEPARATE FROM ANY OF
*      THE OTHER REGISTERS OR PROGRAM ACCESSIBLE LOCATIONS.
*
*
*
*      THE CODE POINTER REGISTER (CP) IS A SPECIAL INDEX
*      REGISTER FOR USE IN IMPLEMENTATIONS OF INTERPRETORS.
*      IT IS USED TO CONTAIN A PSEUDO-CODE POINTER AND CAN
*      ONLY BE AFFECTED BY ICP, LCP, SCP AND LCW INSTRUCTIONS.
       EJC
*      SECTION 4 - THE STACK
*
*      THE FOLLOWING NOTES ARE TO GUIDE BOTH IMPLEMENTORS OF
*      SYSTEMS WRITTEN IN MINIMAL AND MINIMAL PROGRAMMERS IN
*      DEALING WITH STACK MANIPULATION. IMPLEMENTATION OF A
*      DOWNWARDS BUILDING STACK IS EASIEST AND IN GENERAL IS
*      TO BE PREFERRED, IN WHICH CASE IT IS MERELY NECESSARY TO
*      CONSIDER XT AS AN ALTERNATIVE NAME FOR XL.
*
*      THE MINIMAL VIRTUAL MACHINE INCLUDES A STACK AND HAS
*      OPERAND FORMATS -(XS) AND (XS)+ FOR PUSHING AND POPPING
*      ITEMS WITH AN IMPLICATION THAT THE STACK BUILDS DOWN IN
*      MEMORY (A D-STACK). HOWEVER ON SOME TARGET MACHINES IT IS
*      BETTER FOR THE STACK TO BUILD UP (A U-STACK).
*      A STACK ADDRESSED ONLY BY PUSH AND POP OPERATIONS CAN
*      BUILD IN EITHER DIRECTION WITH NO COMPLICATION BUT
*      SUCH A PURE SCHEME OF STACK ACCESS PROVES RESTRICTIVE.
*      HENCE IT IS PERMITTED TO ACCESS BURIED ITEMS USING AN
*      INTEGER OFFSET PAST THE INDEX REGISTER POINTING TO THE
*      STACK TOP. ON TARGET MACHINES THIS OFFSET WILL BE
*      POSITIVE/NEGATIVE FOR D-STACKS/U-STACKS AND THIS MUST
*      BE ALLOWED FOR IN THE TRANSLATION.
*      A FURTHER RESTRICTION IS THAT AT NO TIME MAY AN ITEM BE
*      PLACED ABOVE THE STACK TOP. FOR SOME OPERATIONS THIS
*      MAKES IT CONVENIENT TO ADVANCE THE STACK POINTER AND THEN
*      ADDRESS ITEMS BELOW IT USING A SECOND INDEX REGISTER.
*      THE PROBLEM OF SIGNED OFFSETS PAST SUCH A REGISTER THEN
*      ARISES. TO DISTINGUISH STACK OFFSETS, WHICH IN SOME
*      IMPLEMENTATIONS MAY BE NEGATIVE, FROM NON-STACK OFFSETS
*      WHICH ARE INVARIABLY POSITIVE, XT, AN ALIAS OR
*      SYNONYM FOR XL IS USED. FOR A U-STACK IMPLEMENTATION, THE
*      MINIMAL TRANSLATOR SHOULD NEGATE THE SIGN OF OFFSETS
*      APPLIED TO BOTH (XS) AND (XT).
*      PROGRAMMERS SHOULD NOTE THAT SINCE XT IS NOT A
*      SEPARATE REGISTER, XL SHOULD NOT BE USED IN CODE WHERE
*      XT IS REFERENCED. OTHER MODIFICATIONS NEEDED IN U-STACK
*      TRANSLATIONS ARE IN THE ADD, SUB, ICA, DCA OPCODES
*      APPLIED TO XS, XT. FOR EXAMPLE
*
*      MINIMAL           D-STACK TRANS.  U-STACK TRANS.
*
*      MOV  WA,-(XS)     SBI  XS,1       ADI  XS,1
*                        STO  WA,(XS)    STO  WA,(XS)
*      MOV  (XT)+,WC     LOD  WC,(XL)    LOD  WC,(XL)
*                        ADI  XL,1       SBI  XL,1
*      ADD  =SEVEN,XS    ADI  XS,7       SBI  XS,7
*      MOV  2(XT),WA     LOD  WA,2(XL)   LOD  WA,-2(XL)
*      ICA  XS           ADI  XS,1       SBI  XS,1
*
*      NOTE THAT FORMS SUCH AS
*      MOV  -(XS),WA
*      ADD  WA,(XS)+
*      ARE ILLEGAL, SINCE THEY ASSUME INFORMATION STORAGE
*      ABOVE THE STACK TOP.
       EJC
*      SECTION 5 - INTERNAL CHARACTER SET
*
*      THE INTERNAL CHARACTER SET IS REPRESENTED BY A SET OF
*      CONTIGUOUS CODES FROM 0 TO CFP$A-1. THE CODES FOR THE
*      DIGITS 0-9 MUST BE CONTIGUOUS AND IN SEQUENCE. OTHER
*      THAN THIS, THERE ARE NO RESTRAINTS.
*
*      THE FOLLOWING SYMBOLS ARE AUTOMATICALLY DEFINED TO HAVE
*      THE VALUE OF THE CORRESPONDING INTERNAL CHARACTER CODE.
*
*      CH$LA                 LETTER A
*      CH$LB                 LETTER B
*      .                     .
*      CH$L$                 LETTER Z
*
*      CH$D0                 DIGIT 0
*      .                     .
*      CH$D9                 DIGIT 9
*
*      CH$AM                 AMPERSAND
*      CH$AS                 ASTERISK
*      CH$AT                 AT
*      CH$BB                 LEFT BRACKET
*      CH$BL                 BLANK
*      CH$BR                 VERTICAL BAR
*      CH$CL                 COLON
*      CH$CM                 COMMA
*      CH$DL                 DOLLAR SIGN
*      CH$DT                 DOT (PERIOD)
*      CH$DQ                 DOUBLE QUOTE
*      CH$EQ                 EQUAL SIGN
*      CH$EX                 EXCLAMATION MARK
*      CH$MN                 MINUS
*      CH$NM                 NUMBER SIGN
*      CH$NT                 NOT
*      CH$PC                 PERCENT
*      CH$PL                 PLUS
*      CH$PP                 LEFT PAREN
*      CH$RB                 RIGHT BRACKET
*      CH$RP                 RIGHT PAREN
*      CH$QU                 QUESTION MARK
*      CH$SL                 SLASH
*      CH$SM                 SEMI-COLON
*      CH$SQ                 SINGLE QUOTE
*      CH$UN                 UNDERLINE
*
*      THE FOLLOWING OPTIONAL SYMBOLS ARE INCORPORATED
*      BY DEFINING THE CONDITIONAL ASSEMBLY SYMBOL NAMED.
*
*      26 SHIFTED LETTERS INCORPORATED BY DEFINING .CASL
*
*      CH$$A                 SHIFTED A
*      CH$$B                 SHIFTED B
*      .                     .
*      CH$$$                 SHIFTED Z
*
*      CH$HT                 HORIZONTAL TAB - DEFINE .CAHT
*      CH$VT                 VERTICAL TAB   - DEFINE .CAVT
*      CH$EY                 UP ARROW       - DEFINE .CAEX
       EJC
*
*      SECTION 6 - CONDITIONAL ASSEMBLY FEATURES
*
*      SOME FEATURES OF THE INTERPRETER ARE APPLICABLE TO ONLY
*      CERTAIN TARGET MACHINES. THEY MAY BE INCORPORATED OR
*      OMITTED BY USE OF CONDITIONAL ASSEMBLY. THE FULL
*      FORM OF A CONDITION IS -
*      .IF    CONDITIONAL ASSEMBLY SYMBOL    (CAS)
*      .THEN
*             MINIMAL STATEMENTS1   (MS1)
*      .ELSE
*             MINIMAL STATEMENTS2   (MS2)
*      .FI
*      THE FOLLOWING RULES APPLY
*      1.   THE DIRECTIVES .IF, .THEN, .ELSE, .FI MUST
*           START IN COLUMN 1.
*      2.   THE CONDITIONAL ASSEMBLY SYMBOL MUST START WITH A
*           DOT IN COLUMN 8 FOLLOWED BY 4 LETTERS OR DIGITS E.G.
*              .CA$1
*      3.   .THEN IS REDUNDANT AND MAY BE OMITTED IF WISHED.
*      4.   MS1, MS2 ARE ARBITRARY SEQUENCES OF MINIMAL
*           STATEMENTS EITHER OF WHICH MAY BE NULL OR MAY
*           CONTAIN FURTHER CONDITIONS.
*      5.   IF MS2 IS OMITTED, .ELSE MAY ALSO BE OMITTED.
*      6.   .FI IS REQUIRED.
*      7.   CONDITIONS MAY BE NESTED TO A DEPTH DETERMINED
*           BY THE TRANSLATOR (NOT LESS THAN 20, SAY).
*
*      SELECTION OF THE ALTERNATIVES MS1, MS2 IS BY MEANS OF THE
*      DEFINE AND UNDEFINE DIRECTIVES OF FORM -
*      .DEF   CAS
*      .UNDEF CAS
*      WHICH OBEY RULES 1. AND 2. ABOVE AND MAY OCCUR AT ANY
*      POINT IN A MINIMAL PROGRAM, INCLUDING WITHIN A CONDITION.
*      MULTIPLY DEFINING A SYMBOL IS AN ERROR.
*      UNDEFINING A SYMBOL WHICH IS NOT DEFINED IS NOT AN ERROR.
*
*      THE EFFECT IS THAT IF A SYMBOL IS CURRENTLY DEFINED,
*      THEN IN ANY CONDITION DEPENDING ON IT, MS1 WILL BE
*      PROCESSED AND MS2 OMITTED. CONVERSELY IF IT IS UNDEFINED,
*      MS1 WILL BE OMITTED AND MS2 PROCESSED.
*
*      NESTING OF CONDITIONS IS SUCH THAT CONDITIONS
*      IN A SECTION NOT SELECTED FOR PROCESSING MUST NOT BE
*      EVALUATED. NESTED CONDITIONS MUST REMEMBER THEIR
*      ENVIRONMENT WHILST BEING PROCESSED. EFFECTIVELY THIS
*      IMPLIES USE OF A SCHEME BASED ON A STACK WITH .IF, .FI
*      MATCHING BY THE CONDITION PROCESSOR OF THE TRANSLATOR.
       EJC
*
*      SECTION 7 - OPERAND FORMATS
*
*      THE FOLLOWING SECTION DESCRIBES THE VARIOUS POSSIBILITIES
*      FOR OPERANDS OF INSTRUCTIONS AND ASSEMBLY OPERATIONS.
*
*      01   INT              UNSIGNED INTEGER LE CFP$L
*      02   DLBL             SYMBOL DEFINED IN DEFINITIONS SEC
*      03   WLBL             LABEL IN WORKING STORAGE SECTION
*      04   CLBL             LABEL IN CONSTANT SECTION
*      05   ELBL             PROGRAM SECTION ENTRY LABEL
*      06   PLBL             PROGRAM SECTION LABEL (NON-ENTRY)
*      07   X                ONE OF THE THREE INDEX REGISTERS
*      08   W                ONE OF THE THREE WORK REGISTERS
*      09   (X)              LOCATION INDEXED BY X
*      10   (X)+             LIKE (X) BUT POST INCREMENT X
*      11   -(X)             LIKE (X) BUT PREDECREMENT X
*      12   INT(X)           LOCATION INT WORDS BEYOND ADDR IN X
*      13   DLBL(X)          LOCATION DLBL WORDS PAST ADDR IN X
*      14   CLBL(X)          LOCATION (X) BYTES BEYOND CLBL
*      15   WLBL(X)          LOCATION (X) BYTES BEYOND WLBL
*      16   INTEGER          SIGNED INTEGER (DIC)
*      17   REAL             SIGNED REAL (DRC)
*      18   =DLBL            LOCATION CONTAINING DAC DLBL
*      19   *DLBL            LOCATION CONTAINING DAC CFP$B*DLBL
*      20   =WLBL            LOCATION CONTAINING DAC WLBL
*      21   =CLBL            LOCATION CONTAINING DAC CLBL
*      22   =ELBL            LOCATION CONTAINING DAC ELBL
*      23   PNAM             PROCEDURE LABEL (ON PRC INSTRUC)
*      24   EQOP             OPERAND FOR EQU INSTRUCTION
*      25   PTYP             PROCEDURE TYPE (SEE PRC)
*      26   TEXT             ARBITRARY TEXT (ERB,ERR,TTL)
*      27   DTEXT            DELIMITED TEXT STRING (DTC)
*
*      THE NUMBERS IN THE ABOVE LIST ARE USED IN SUBSEQUENT
*      DESCRIPTION AND IN SOME OF THE MINIMAL TRANSLATORS.
       EJC
*
*      OPERAND FORMATS (CONTINUED)
*
*      THE FOLLOWING SPECIAL SYMBOLS REFER TO A COLLECTION OF
*      THE LISTED POSSIBILITIES
*
*      VAL  01,02                      PREDEFINED VALUE
*
*           VAL IS USED TO REFER TO A PREDEFINED ONE WORD
*           INTEGER VALUE IN THE RANGE 0 LE N LE CFP$L.
*
*      REG  07,08                      REGISTER
*
*           REG IS USED TO DESCRIBE AN OPERAND WHICH CAN BE
*           ANY OF THE REGISTERS (XL,XR,XS,XT,WA,WB,WC). SUCH
*           AN OPERAND CAN HOLD A ONE WORD INTEGER (ADDRESS).
*
*      OPC  09,10,11                   CHARACTER
*
*           OPC IS USED TO DESIGNATE A SPECIFIC CHARACTER
*           OPERAND FOR USE IN THE LCH AND SCH INSTRUCTIONS.
*           THE INDEX REGISTER REFERENCED MUST BE EITHER XR OR
*           XL (NOT XS,XT). SEE SECTION ON CHARACTER OPERATIONS.
*
*      OPS  03,04,09,12,13,14,15       MEMORY REFERENCE
*
*           OPS IS USED TO DESCRIBE AN OPERAND WHICH IS IN
*           MEMORY. THE OPERAND MAY BE ONE OR MORE WORDS LONG
*           DEPENDING ON THE DATA TYPE. IN THE CASE OF MULTIWORD
*           OPERANDS, THE ADDRESS GIVEN IS THE FIRST WORD.
*
*      OPW  AS FOR OPS + 08,10,11      FULL WORD
*
*           OPW IS USED TO REFER TO AN OPERAND WHOSE CAPACITY IS
*           THAT OF A FULL MEMORY WORD. OPW INCLUDES ALL THE
*           POSSIBILITIES FOR OPS (THE REFERENCED WORD IS USED)
*           PLUS THE USE OF ONE OF THE THREE WORK REGISTERS
*           (WA,WB,WC). IN ADDITION, THE FORMATS (X)+ AND -(X)
*           ALLOW INDEXED OPERATIONS IN WHICH THE INDEX REGISTER
*           IS POPPED BY ONE WORD AFTER THE REFERENCE (X)+,
*           OR PUSHED BY ONE WORD BEFORE THE REFERENCE -(X)
*           THESE LATTER TWO FORMATS PROVIDE A FACILITY FOR
*           MANIPULATION OF STACKS. THE FORMAT DOES NOT IMPLY
*           A PARTICULAR DIRECTION IN WHICH STACKS MUST BUILD -
*           IT IS USED FOR COMPACTNESS. NOTE THAT THERE IS A
*           RESTRICTION WHICH DISALLOWS AN INSTRUCTION TO USE
*           AN INDEX REGISTER IN ONE OF THESE FORMATS
*           IN SOME OTHER MANNER IN THE SAME INSTRUCTION.
*           E.G.   MOV  XL,(XL)+   IS ILLEGAL.
*           THE FORMATS -(X) AND (X)+ MAY ALSO BE USED IN
*           PRE-DECREMENTATION, POST-INCREMENTATION TO ACCESS
*           THE ADJACENT CHARACTER OF A STRING.
       EJC
*
*      OPERAND FORMATS (CONTINUED)
*
*      OPN  AS FOR OPW + 07            ONE WORD INTEGER
*
*           OPN IS USED TO REPRESENT AN OPERAND LOCATION WHICH
*           CAN CONTAIN A ONE WORD INTEGER (E.G. AN ADDRESS).
*           THIS INCLUDES ALL THE POSSIBILITIES FOR OPW PLUS
*           THE USE OF ONE OF THE INDEX REGISTERS (XL,XR,XT,
*           XS). THE RANGE OF INTEGER VALUES IS 0 LE N LE CFP$L.
*
*      OPV  AS FOR OPN + 18-22         ONE WORD INTEGER VALUE
*
*           OPV IS USED FOR AN OPERAND WHICH CAN YIELD A ONE
*           WORD INTEGER VALUE (E.G. AN ADDRESS). IT INCLUDES
*           ALL THE POSSIBILITIES FOR OPN (THE CURRENT VALUE OF
*           THE LOCATION IS USED) PLUS THE USE OF LITERALS. NOTE
*           THAT ALTHOUGH THE LITERAL FORMATS ARE DESCRIBED IN
*           TERMS OF A REFERENCE TO A LOCATION CONTAINING AN
*           ADDRESS CONSTANT, THIS LOCATION MAY NOT ACTUALLY
*           EXIST IN SOME IMPLEMENTATIONS SINCE ONLY THE VALUE
*           IS REQUIRED. A RESTRICTION IS PLACED ON LITERALS
*           WHICH MAY CONSIST ONLY OF DEFINED SYMBOLS AND
*           CERTAIN LABELS. CONSEQUENTLY SMALL INTEGERS TO BE
*           USED AS LITERALS MUST BE PRE-DEFINED, A DISCIPLINE
*           AIDING PROGRAM MAINTENANCE AND REVISION.
*
*      ADDR 01,02,03,04,05             ADDRESS
*
*           ADDR IS USED TO DESCRIBE AN EXPLICIT ADDRESS VALUE
*           (ONE WORD INTEGER VALUE) FOR USE WITH DAC.
*
*
*           ****************************************************
*           *   IN THE FOLLOWING DESCRIPTIONS THE USAGE --     *
*           *      (XL),(XR), ... ,(IA)                        *
*           *   IN THE DESCRIPTIVE TEXT SIGNIFIES THE          +
*           *   CONTENTS OF THE STATED REGISTER.               *
*           ****************************************************
       EJC
*
*      SECTION 8 - LIST OF INSTRUCTION MNEMONICS
*
*      THE FOLLOWING LIST INCLUDES ALL INSTRUCTION AND
*      ASSEMBLY OPERATION MNEMONICS IN ALPHABETICAL ORDER.
*      THE MNEMONICS ARE PRECEDED BY A NUMBER IDENTIFYING
*      THE FOLLOWING SECTION WHERE THE INSTRUCTION IS DESCRIBED.
*      A STAR (*) IS APPENDED TO THE MNEMONIC IF THE LAST
*      OPERAND MAY OPTIONALLY BE OMITTED.
*      SEE SECTION -15- FOR DETAILS OF STATEMENT FORMAT AND
*      COMMENT CONVENTIONS.
*
*       2.1  ADD  OPV,OPN      ADD ADDRESS
*       4.2  ADI  OPS          ADD INTEGER
*       5.3  ADR  OPS          ADD REAL
*       7.1  ANB  OPW,W        AND BIT STRING
*       2.17 AOV  OPV,OPN,PLBL ADD ADDRESS, FAIL IF OVERFLOW
*       5.16 ATN               ARCTANGENT OF REAL ACCUM
*       2.16 BCT  W,PLBL       BRANCH AND COUNT
*       2.5  BEQ  OPN,OPV,PLBL BRANCH IF ADDRESS EQUAL
*       2.18 BEV  OPN,PLBL     BRANCH IF ADDRESS EVEN
*       2.8  BGE  OPN,OPV,PLBL BRANCH IF ADDRESS GREATER OR EQUL
*       2.7  BGT  OPN,OPV,PLBL BRANCH IF ADDRESS GREATER
*       2.12 BHI  OPN,OPV,PLBL BRANCH IF ADDRESS HIGH
*       2.10 BLE  OPN,OPV,PLBL BRANCH IF ADDRESS LESS OR EQUAL
*       2.11 BLO  OPN,OPV,PLBL BRANCH IF ADDRESS LOW
*       2.9  BLT  OPN,OPV,PLBL BRANCH IF ADDRESS LESS THAN
*       2.6  BNE  OPN,OPV,PLBL BRANCH IF ADDRESS NOT EQUAL
*       2.13 BNZ  OPN,PLBL     BRANCH IF ADDRESS NON-ZERO
*       2.19 BOD  OPN,PLBL     BRANCH IF ADDRESS ODD
*       1.2  BRN  PLBL         BRANCH UNCONDITIONAL
*       1.7  BRI  OPN          BRANCH INDIRECT
*       1.3  BSW* X,VAL,PLBL   BRANCH ON SWITCH VALUE
*       8.2  BTW  REG          CONVERT BYTES TO WORDS
*       2.14 BZE  OPN,PLBL     BRANCH IF ADDRESS ZERO
*       6.6  CEQ  OPW,OPW,PLBL BRANCH IF CHARACTERS EQUAL
*      10.1  CHK               CHECK STACK OVERFLOW
*       5.17 CHP               INTEGER PORTION OF REAL ACCUM
*       7.4  CMB  W            COMPLEMENT BIT STRING
*       6.8  CMC  PLBL,PLBL    COMPARE CHARACTER STRINGS
*       6.7  CNE  OPW,OPW,PLBL BRANCH IF CHARACTERS NOT EQUAL
*       6.5  CSC  X            COMPLETE STORE CHARACTERS
*       5.18 COS               COSINE OF REAL ACCUM
*       8.8  CTB  W,VAL        CONVERT CHARACTER COUNT TO BYTES
*       8.7  CTW  W,VAL        CONVERT CHARACTER COUNT TO WORDS
*       8.10 CVD               CONVERT BY DIVISION
*       8.9  CVM  PLBL         CONVERT BY MULTIPLICATION
*      11.1  DAC  ADDR         DEFINE ADDRESS CONSTANT
*      11.5  DBC  VAL          DEFINE BIT STRING CONSTANT
*       2.4  DCA  OPN          DECREMENT ADDRESS BY ONE WORD
*       1.17 DCV  OPN          DECREMENT VALUE BY ONE
*      11.2  DIC  INTEGER      DEFINE INTEGER CONSTANT
       EJC
*
*      ALPHABETICAL LIST OF MNEMONICS (CONTINUED)
*
*      11.3  DRC  REAL         DEFINE REAL CONSTANT
*      11.4  DTC  DTEXT        DEFINE TEXT (CHARACTER) CONSTANT
*       4.5  DVI  OPS          DIVIDE INTEGER
*       5.6  DVR  OPS          DIVIDE REAL
*      13.1  EJC               EJECT ASSEMBLY LISTING
*      14.2  END               END OF ASSEMBLY
*       1.13 ENP               DEFINE END OF PROCEDURE
*       1.6  ENT* VAL          DEFINE ENTRY POINT
*      12.1  EQU  EQOP         DEFINE SYMBOLIC VALUE
*       1.15 ERB  INT,TEXT     ASSEMBLE ERROR CODE AND BRANCH
*       1.14 ERR  INT,TEXT     ASSEMBLE ERROR CODE
*       1.5  ESW               END OF SWITCH LIST FOR BSW
*       5.19 ETX               E TO THE POWER IN THE REAL ACCUM
*       1.12 EXI* INT          EXIT FROM PROCEDURE
*      12.2  EXP               DEFINE EXTERNAL PROCEDURE
*       6.10 FLC  W            FOLD CHARACTER TO UPPER CASE
*       2.3  ICA  OPN          INCREMENT ADDRESS BY ONE WORD
*       3.4  ICP               INCREMENT CODE POINTER
*       1.16 ICV  OPN          INCREMENT VALUE BY ONE
*       4.11 IEQ  PLBL         JUMP IF INTEGER ZERO
*       1.4  IFF  VAL,PLBL     SPECIFY BRANCH FOR BSW
*       4.12 IGE  PLBL         JUMP IF INTEGER NON-NEGATIVE
*       4.13 IGT  PLBL         JUMP IF INTEGER POSITIVE
*       4.14 ILE  PLBL         JUMP IF INTEGER NEGATIVE OR ZERO
*       4.15 ILT  PLBL         JUMP IF INTEGER NEGATIVE
*       4.16 INE  PLBL         JUMP IF INTEGER NON-ZERO
*       4.9  INO  PLBL         JUMP IF NO INTEGER OVERFLOW
*      12.3  INP  PTYP,INT     INTERNAL PROCEDURE
*      12.4  INR               INTERNAL ROUTINE
*       4.10 IOV  PLBL         JUMP IF INTEGER OVERFLOW
*       8.5  ITR               CONVERT INTEGER TO REAL
*       1.9  JSR  PNAM         CALL PROCEDURE
*       6.3  LCH  REG,OPC      LOAD CHARACTER
*       2.15 LCT  W,OPV        LOAD COUNTER FOR LOOP
*       3.1  LCP  REG          LOAD CODE POINTER REGISTER
*       3.3  LCW  REG          LOAD NEXT CODE WORD
*       4.1  LDI  OPS          LOAD INTEGER
*       5.1  LDR  OPS          LOAD REAL
*       1.8  LEI  X            LOAD ENTRY POINT ID
*       5.20 LNF               NATURAL LOGORITHM OF REAL ACCUM
*       7.6  LSH  W,VAL        LEFT SHIFT BIT STRING
*       7.8  LSX  W,(X)        LEFT SHIFT INDEXED
*       9.4  MCB               MOVE CHARACTERSWORDS BACKWARDS
*       8.4  MFI* OPN,PLBL     CONVERT (IA) TO ADDRESS VALUE
*       4.3  MLI  OPS          MULTIPLY INTEGER
*       5.5  MLR  OPS          MULTIPLY REAL
*       1.19 MNZ  OPN          MOVE NON-ZERO
*       1.1  MOV  OPV,OPN      MOVE
*       8.3  MTI  OPN          MOVE ADDRESS VALUE TO (IA)
*       9.1  MVC               MOVE CHARACTERS
*       9.2  MVW               MOVE WORDS
*       9.3  MWB               MOVE WORDS BACKWARDS
*       4.8  NGI               NEGATE INTEGER
       EJC
*
*      ALPHABETICAL LIST OF MNEMONICS (CONTINUED)
*
*       5.9  NGR               NEGATE REAL
*       7.9  NZB  W,PLBL       JUMP IF NOT ALL ZERO BITS
*       7.2  ORB  OPW,W        OR BIT STRINGS
*       6.1  PLC* X,OPV        PREPARE TO LOAD CHARACTERS
*       1.10 PPM* PLBL         PROVIDE PROCEDURE EXIT PARAMETER
*       1.11 PRC  PTYP,VAL     DEFINE START OF PROCEDURE
*       6.2  PSC* X,OPV        PREPARE TO STORE CHARACTERS
*       5.10 REQ  PLBL         JUMP IF REAL ZERO
*       5.11 RGE  PLBL         JUMP IF REAL POSITIVE OR ZERO
*       5.12 RGT  PLBL         JUMP IF REAL POSITIVE
*       5.13 RLE  PLBL         JUMP IF REAL NEGATIVE OR ZERO
*       5.14 RLT  PLBL         JUMP IF REAL NEGATIVE
*       4.6  RMI  OPS          REMAINDER INTEGER
*       5.15 RNE  PLBL         JUMP IF REAL NON-ZERO
*       5.8  RNO  PLBL         JUMP IF NO REAL OVERFLOW
*       5.7  ROV  PLBL         JUMP IF REAL OVERFLOW
*       7.5  RSH  W,VAL        RIGHT SHIFT BIT STRING
*       7.7  RSX  W,(X)        RIGHT SHIFT INDEXED
*       8.6  RTI* PLBL         CONVERT REAL TO INTEGER
*       1.22 RTN               DEFINE START OF ROUTINE
*       4.4  SBI  OPS          SUBTRACT INTEGER
*       5.4  SBR  OPS          SUBTRACT REALS
*       6.4  SCH  REG,OPC      STORE CHARACTER
*       3.2  SCP  REG          STORE CODE POINTER
*      14.1  SEC               DEFINE START OF ASSEMBLY SECTION
*       5.21 SIN               SINE OF REAL ACCUM
*       5.22 SQR               SQUARE ROOT OF REAL ACCUM
*       1.20 SSL  OPW          SUBROUTINE STACK LOAD
*       1.21 SSS  OPW          SUBROUTINE STACK STORE
*       4.7  STI  OPS          STORE INTEGER
*       5.2  STR  OPS          STORE REAL
*       2.2  SUB  OPV,OPN      SUBTRACT ADDRESS
*       5.23 TAN               TANGENT OF REAL ACCUM
*       6.9  TRC               TRANSLATE CHARACTER STRING
*      13.2  TTL  TEXT         SUPPLY ASSEMBLY TITLE
*       8.1  WTB  REG          CONVERT WORDS TO BYTES
*       7.3  XOB  OPW,W        EXCLUSIVE OR BIT STRINGS
*       1.18 ZER  OPN          ZEROISE INTEGER LOCATION
*       7.11 ZGB  OPN          ZEROISE GARBAGE BITS
*       7.10 ZRB  W,PLBL       JUMP IF ALL ZERO BITS
       EJC
*
*      SECTION 9 - MINIMAL INSTRUCTIONS
*
*      THE FOLLOWING DESCRIPTIONS ASSUME THE DEFINITIONS -
*
*      ZEROE  EQU  0
*      UNITY  EQU  1
*
*      -1-  BASIC INSTRUCTION SET
*
*      1.1  MOV  OPV,OPN     MOVE ONE WORD VALUE
*
*           MOV CAUSES THE VALUE OF OPERAND OPV TO BE SET AS
*           THE NEW CONTENTS OF OPERAND LOCATION OPN. IN THE
*           CASE WHERE OPN IS NOT AN INDEX REGISTER, ANY VALUE
*           WHICH CAN NORMALLY OCCUPY A MEMORY WORD (INCLUDING
*           A PART OF A MULTIWORD REAL OR INTEGER VALUE)
*           CAN BE TRANSFERRED USING MOV. IF THE TARGET LOCATION
*           OPN IS AN INDEX REGISTER, THEN OPV MUST SPECIFY AN
*           APPROPRIATE ONE WORD VALUE OR OPERAND CONTAINING
*           SUCH AN APPROPRIATE VALUE.
*
*      1.2  BRN  PLBL        UNCONDITIONAL BRANCH
*
*           BRN CAUSES CONTROL TO BE PASSED TO THE INDICATED
*           LABEL IN THE PROGRAM SECTION.
*
*      1.3  BSW  X,VAL,PLBL  BRANCH ON SWITCH VALUE
*      1.4  IFF  VAL,PLBL    PROVIDE BRANCH FOR SWITCH
*           IFF  VAL,PLBL     ...
*           ...
*           ...
*      1.5  ESW              END OF BRANCH SWITCH TABLE
*
*           BSW,IFF,ESW PROVIDE A CAPABILITY FOR A SWITCHED
*           BRANCH SIMILAR TO A FORTRAN COMPUTED GOTO. THE
*           VAL ON THE BSW INSTRUCTION IS THE MAXIMUM NUMBER
*           OF BRANCHES. THE VALUE IN X RANGES FROM ZERO UP TO
*           BUT NOT INCLUDING THIS MAXIMUM. EACH IFF PROVIDES A
*           BRANCH. VAL MUST BE LESS THAN THAT GIVEN ON THE BSW
*           AND CONTROL GOES TO PLBL IF THE VALUE IN X MATCHES.
*           IF THE VALUE IN X DOES NOT CORRESPOND TO ANY OF THE
*           IFF ENTRIES, THEN CONTROL PASSES TO THE PLBL ON THE
*           BSW. THIS PLBL OPERAND MAY BE OMITTED IF THERE ARE
*           NO VALUES MISSING FROM THE LIST.
*
*           IFF AND ESW MAY ONLY BE USED IN THIS CONTEXT.
*           EXECUTION OF BSW MAY DESTROY THE CONTENTS OF X.
*           THE IFF ENTRIES MAY BE IN ANY ORDER AND SINCE
*           A TRANSLATOR MAY THUS NEED TO STORE AND SORT THEM,
*           THE COMMENT FIELD IS RESTRICTED IN LENGTH (SEC 11).
       EJC
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.6  ENT  VAL         DEFINE PROGRAM ENTRY POINT
*
*           THE SYMBOL APPEARING IN THE LABEL FIELD IS DEFINED
*           TO BE A PROGRAM ENTRY POINT WHICH CAN SUBSEQUENTLY
*           BE USED IN CONJUNCTION WITH THE BRI INSTRUCTION,
*           WHICH PROVIDES THE ONLY MEANS OF ENTERING THE
*           CODE. IT IS ILLEGAL TO FALL INTO CODE
*           IDENTIFIED BY AN ENTRY POINT. THE
*           ENTRY SYMBOL IS ASSIGNED AN ADDRESS WHICH NEED NOT
*           BE A MULTIPLE OF CFP$B BUT WHICH MUST BE IN THE
*           RANGE 0 LE CFP$L AND THE ADDRESS MUST NOT LIE WITHIN
*           THE ADDRESS RANGE OF THE ALLOCATED DATA AREA.
*           FURTHERMORE, ADDRESSES OF SUCCESSIVE ENTRY POINTS
*           MUST BE ASSIGNED IN SOME ASCENDING SEQUENCE SO
*           THAT THE ADDRESS COMPARISON INSTRUCTIONS CAN BE
*           USED TO TEST THE ORDER IN WHICH TWO ENTRY POINTS
*           OCCUR. THE SYMBOL VAL GIVES AN IDENTIFYING VALUE
*           TO THE ENTRY POINT WHICH CAN BE ACCESSED WITH THE
*           LEI INSTRUCTION.
*
*           NOTE - SUBJECT TO THE RESTRICTION BELOW, VAL MAY
*           BE OMITTED IF NO SUCH IDENTIFICATION IS NEEDED I.E.
*           IF NO LEI REFERENCES THE ENTRY POINT. FOR THIS
*           CASE, A TRANSLATION OPTIMISATION IS POSSIBLE IN
*           WHICH NO MEMORY NEED BE RESERVED FOR A NULL
*           IDENTIFICATION WHICH IS NEVER TO BE REFERENCED, BUT
*           ONLY PROVIDED THIS IS DONE SO AS NOT TO INTERFERE
*           WITH THE STRICTLY ASCENDING SEQUENCE OF ENTRY POINT
*           ADDRESSES. TO SIMPLIFY THIS OPTIMISATION FOR ALL
*           IMPLEMENTORS, THE FOLLOWING RESTRICTION IS OBSERVED
*                VAL MAY ONLY BE OMITTED IF THE ENTRY POINT IS
*                SEPARATED FROM A FOLLOWING ENTRY POINT BY A
*                NON-NULL MINIMAL CODE SEQUENCE.
*           ENTRY POINT ADDRESSES ARE ACCESSIBLE ONLY BY USE OF
*           LITERALS (=ELBL, SECTION 7) OR DAC CONSTANTS
*           (SECTION 8-11.1).
*
*      1.7  BRI  OPN         BRANCH INDIRECT
*
*           OPN CONTAINS THE ADDRESS OF A PROGRAM ENTRY POINT
*           (SEE ENT). CONTROL IS PASSED TO THE EXECUTABLE
*           CODE STARTING AT THE ENTRY POINT ADDRESS. OPN IS
*           LEFT UNCHANGED.
*
*      1.8  LEI  X           LOAD ENTRY POINT IDENTIFICATION
*
*           X CONTAINS THE ADDRESS OF AN ENTRY POINT FOR WHICH
*           AN IDENTIFYING VALUE WAS GIVEN ON THE THE ENT LINE.
*           LEI REPLACES THE CONTENTS OF X BY THIS VALUE.
       EJC
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.9  JSR  PNAM        CALL PROCEDURE PNAM
*      1.10 PPM  PLBL        PROVIDE EXIT PARAMETER
*           PPM  PLBL         ...
*           ...
*           PPM  PLBL         ...
*
*           JSR CAUSES CONTROL TO BE PASSED TO THE NAMED
*           PROCEDURE. PNAM IS THE LABEL ON A PRC STATEMENT
*           ELSEWHERE IN THE PROGRAM SECTION (SEE PRC)
*           OR HAS BEEN DEFINED USING AN EXP INSTRUCTION.
*           THE PPM EXIT PARAMETERS FOLLOWING THE CALL GIVE
*           NAMES OF PROGRAM LOCATIONS (PLBL-S) TO WHICH
*           ALTERNATIVE EXI RETURNS OF THE CALLED PROCEDURE MAY
*           PASS CONTROL. THEY MAY OPTIONALLY BE REPLACED BY
*           ERROR RETURNS (SEE ERR). THE NUMBER OF EXIT
*           PARAMETERS FOLLOWING A JSR MUST EQUAL THE INT IN THE
*           PROCEDURE DEFINITION. THE OPERAND OF PPM MAY BE
*           OMITTED IF THE CORRESPONDING EXI RETURN IS CERTAIN
*           NOT TO BE TAKEN.
*
*      1.11 PRC  PTYP,INT    DEFINE START OF PROCEDURE
*
*           THE SYMBOL APPEARING IN THE LABEL FIELD IS DEFINED
*           TO BE THE NAME OF A PROCEDURE FOR USE WITH JSR.
*           A PROCEDURE IS A CONTIGUOUS SECTION OF INSTRUCTIONS
*           TO WHICH CONTROL MAY BE PASSED WITH A JSR
*           INSTRUCTION. THIS IS THE ONLY WAY IN WHICH THE
*           INSTRUCTIONS IN A PROCEDURE MAY BE EXECUTED. IT IS
*           NOT PERMITTED TO FALL INTO A PROCEDURE.
*           ALL PROCEDURES SHOULD BE NAMED IN SECTION 0
*           INP  STATEMENTS.
*
*           INT IS THE NUMBER OF EXIT PARAMETERS (PPM-S) TO
*           BE USED IN JSR CALLS.
*
*           THERE ARE THREE POSSIBILITIES FOR PTYP, EACH
*           CONSISTING OF A SINGLE LETTER AS FOLLOWS.
*
*           R                RECURSIVE
*
*           THE RETURN POINT (ONE OR MORE WORDS) IS STORED ON
*           THE STACK AS THOUGH ONE OR MORE MOV ...,-(XS)
*           INSTRUCTIONS WERE EXECUTED.
       EJC
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*           N                NON-RECURSIVE
*
*           THE RETURN POINT IS TO BE STORED EITHER
*           (1) IN A LOCAL STORAGE WORD ASSOCIATED
*           WITH THE PROCEDURE AND NOT DIRECTLY
*           AVAILABLE TO THE PROGRAM IN ANY OTHER MANNER OR
*           (2) ON A SUBROUTINE LINK STACK QUITE DISTINCT FROM
*           THE MINIMAL STACK ADDRESSED BY XS.
*           IT IS AN ERROR TO USE THE STACK FOR N-LINKS, SINCE
*           PROCEDURE PARAMETERS OR RESULTS MAY BE PASSED VIA
*           THE STACK.
*           IF METHOD (2) IS USED FOR LINKS, ERROR EXITS
*           (ERB,ERR) FROM A PROCEDURE WILL NECESSITATE LINK
*           STACK RESETTING. THE SSL AND SSS ORDERS PROVIDED
*           FOR THIS MAY BE REGARDED AS NO-OPS FOR
*           IMPLEMENTATIONS USING METHOD (1).
*
*           E                EITHER
*
*           THE RETURN POINT MAY BE STORED IN EITHER MANNER
*           ACCORDING TO EFFICIENCY REQUIREMENTS OF THE ACTUAL
*           PHYSICAL MACHINE USED FOR THE IMPLEMENTATION. NOTE
*           THAT PROGRAMMING OF E TYPE PROCEDURES MUST BE
*           INDEPENDENT OF THE ACTUAL IMPLEMENTATION.
*
*           THE ACTUAL FORM OF THE RETURN POINT IS UNDEFINED.
*           HOWEVER, EACH WORD STORED ON THE STACK FOR AN
*           R-TYPE CALL MUST MEET THE FOLLOWING REQUIREMENTS.
*
*           1)               IT CAN BE HANDLED AS AN ADDRESS
*                            AND PLACED IN AN INDEX REGISTER.
*
*           2)               WHEN USED AS AN OPERAND IN AN
*                            ADDRESS COMPARISON INSTRUCTION, IT
*                            MUST NOT APPEAR TO LIE WITHIN
*                            THE ALLOCATED DATA AREA.
*
*           3)               IT IS NOT REQUIRED TO APPEAR
*                            TO LIE WITHIN THE PROGRAM SECTION.
       EJC
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.12 EXI  INT         EXIT FROM PROCEDURE
*
*           THE PPM AND ERR PARAMETERS FOLLOWING A JSR ARE
*           NUMBERED STARTING FROM 1.  EXI  INT CAUSES CONTROL
*           TO BE RETURNED TO THE INT-TH SUCH PARAM. EXI 1 GIVES
*           CONTROL TO THE PLBL OF THE FIRST PPM AFTER THE JSR.
*           IF INT IS OMITTED, CONTROL IS PASSED BACK PAST THE
*           LAST EXIT PARAMETER (OR PAST THE JSR IF THERE ARE
*           NONE). FOR R AND E TYPE PROCEDURES, THE
*           STACK POINTER XS MUST BE SET TO ITS APPROPRIATE
*           ENTRY VALUE BEFORE EXECUTING AN EXI INSTRUCTION.
*           IN THIS CASE, EXI REMOVES RETURN POINTS FROM THE
*           STACK IF ANY ARE STORED THERE SO THAT THE STACK
*           POINTER IS RESTORED TO ITS CALLING VALUE.
*
*      1.13 ENP              DEFINE END OF PROCEDURE BODY
*
*           ENP DELIMITS A PROCEDURE BODY AND MAY NOT ACTUALLY
*           BE EXECUTED, HENCE IT MUST HAVE NO LABEL.
*
*      1.14 ERR  INT,TEXT    PROVIDE ERROR RETURN
*
*           ERR MAY REPLACE AN EXIT PARAMETER (PPM) IN
*           ANY PROCEDURE CALL. THE INT ARGUMENT IS A UNIQUE
*           ERROR CODE IN 0 TO 899.
*           THE TEXT SUPPLIED AS THE OTHER OPERAND IS
*           ARBITRARY TEXT IN THE FORTRAN CHARACTER SET AND
*           MAY BE USED IN CONSTRUCTING A FILE OF ERROR
*           MESSAGES FOR DOCUMENTING PURPOSES OR FOR BUILDING
*           A DIRECT ACCESS OR OTHER FILE OF MESSAGES TO BE
*           USED BY THE ERROR HANDLING CODE.
*           IN THE EVENT THAT AN EXI ATTEMPTS
*           TO RETURN CONTROL VIA AN EXIT PARAMETER TO
*           AN ERR, CONTROL IS INSTEAD PASSED TO THE FIRST
*           INSTRUCTION IN THE ERROR SECTION (WHICH FOLLOWS THE
*           PROGRAM SECTION) WITH THE ERROR CODE IN WA.
*
*      1.15 ERB  INT,TEXT    ERROR BRANCH
*
*           THIS INSTRUCTION RESEMBLES ERR EXCEPT THAT IT MAY
*           OCCUR AT ANY POINT WHERE A BRANCH IS PERMITTED.
*           IT EFFECTS A TRANSFER OF CONTROL TO THE ERROR
*           SECTION WITH THE ERROR CODE IN WA.
*
*      1.16 ICV  OPN         INCREMENT VALUE BY ONE
*
*           ICV INCREMENTS THE VALUE OF THE OPERAND BY UNITY.
*           IT IS EQUIVALENT TO   ADD  =UNITY,OPN
*
*      1.17 DCV  OPN         DECREMENT VALUE BY ONE
*
*           DCV DECREMENTS THE VALUE OF THE OPERAND BY UNITY.
*           IT IS EQUIVALENT TO   SUB  =UNITY,OPN
       EJC
*
*      BASIC INSTRUCTIONS (CONTINUED)
*
*      1.18 ZER  OPN         ZEROISE OPN
*
*           ZER IS EQUIVALENT TO  MOV  =ZEROE,OPN
*
*      1.19 MNZ  OPN         MOVE NON-ZERO TO OPN
*
*           ANY NON-ZERO COLLECTABLE VALUE MAY USED, FOR WHICH
*           THE OPCODES BNZ/BZE WILL BRANCH/FAIL TO BRANCH.
*
*      1.20 SSL  OPW         SUBROUTINE STACK LOAD
*
*      1.21 SSS  OPW         SUBROUTINE STACK STORE
*
*           THIS PAIR OF OPERATIONS IS PROVIDED TO MAKE POSSIBLE
*           THE USE OF A LOCAL STACK TO HOLD SUBROUTINE (S-R)
*           RETURN LINKS FOR N-TYPE PROCEDURES. SSS STORES THE
*           S-R STACK POINTER IN OPW AND SSL LOADS THE S-R
*           STACK POINTER FROM OPW. BY USING SSS IN THE MAIN
*           PROGRAM OR ON ENTRY TO A PROCEDURE WHICH SHOULD
*           REGAIN CONTROL ON OCCURRENCE OF AN ERR OR ERB AND BY
*           USE OF SSL IN THE ERROR PROCESSING SECTIONS THE
*           S-R STACK POINTER CAN BE RESTORED GIVING A LINK
*           STACK CLEANED UP READY FOR RESUMED EXECUTION.
*           THE FORM OF THE LINK STACK POINTER IS UNDEFINED IN
*           MINIMAL (IT IS LIKELY TO BE A PRIVATE REGISTER
*           KNOWN TO THE TRANSLATOR) AND THE ONLY REQUIREMENT
*           IS THAT IT SHOULD FIT INTO A SINGLE FULL WORD.
*           SSL AND SSS ARE NO-OPS IF A PRIVATE LINK STACK IS
*           NOT USED.
*
*      1.22 RTN              DEFINE START OF ROUTINE
*
*           A ROUTINE IS A CODE CHUNK USED FOR SIMILAR PURPOSES
*           TO A PROCEDURE. HOWEVER IT IS ENTERED BY ANY TYPE OF
*           CONDITIONAL OR UNCONDITIONAL BRANCH (NOT BY JSR). ON
*           TERMINATION IT PASSES CONTROL BY A BRANCH (OFTEN
*           BRI THROUGH A CODE WORD) OR EVEN PERMITS CONTROL
*           TO DROP THROUGH TO ANOTHER ROUTINE. NO RETURN LINK
*           EXISTS AND THE END OF A ROUTINE IS NOT MARKED BY
*           AN EXPLICIT OPCODE (COMPARE ENP).
*           ALL ROUTINES SHOULD BE NAMED IN SECTION 0
*           INR  STATEMENTS.
       EJC
*
*      -2-  OPERATIONS ON ONE WORD INTEGER VALUES (ADDRESSES)
*
*      2.1  ADD  OPV,OPN     ADDS OPV TO THE VALUE IN OPN AND
*                            STORES THE RESULT IN OPN. UNDEFINED
*                            IF THE RESULT EXCEEDS CFP$L.
*
*      2.2  SUB  OPV,OPN     SUBTRACTS OPV FROM OPN. STORES THE
*                            RESULT IN OPN. UNDEFINED IF THE
*                            RESULT IS NEGATIVE.
*
*      2.3  ICA  OPN         INCREMENT ADDRESS IN OPN
*                            EQUIVALENT TO ADD *UNITY,OPN
*
*      2.4  DCA  OPN         DECREMENT ADDRESS IN OPN
*                            EQUIVALENT TO SUB *UNITY,OPN
*
*      2.5  BEQ  OPN,OPV,PLBL BRANCH TO PLBL IF OPN EQ OPV
*      2.6  BNE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN NE OPV
*      2.7  BGT  OPN,OPV,PLBL BRANCH TO PLBL IF OPN GT OPV
*      2.8  BGE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN GE OPV
*      2.9  BLT  OPN,OPV,PLBL BRANCH TO PLBL IF OPN LT OPV
*      2.10 BLE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN LE OPV
*      2.11 BLO  OPN,OPV,PLBL EQUIVALENT TO BLT OR BLE
*      2.12 BHI  OPN,OPV,PLBL EQUIVALENT TO BGT OR BGE
*
*           THE ABOVE INSTRUCTIONS COMPARE TWO ADDRESS
*           VALUES AS UNSIGNED INTEGER VALUES.
*           THE BLO AND BHI INSTRUCTIONS ARE USED IN CASES WHERE
*           THE EQUAL CONDITION EITHER DOES NOT OCCUR OR CAN
*           RESULT EITHER IN A BRANCH OR NO BRANCH. THIS AVOIDS
*           INEFFICIENT TRANSLATIONS IN SOME IMPLEMENTATIONS.
*
*      2.13 BNZ  OPN,PLBL    EQUIVALENT TO BNE OPN,=ZEROE,PLBL
*
*      2.14 BZE  OPN,PLBL    EQUIVALENT TO BEQ OPN,=ZEROE,PLBL
*
*
*      2.15 LCT  W,OPV       LOAD COUNTER FOR BCT
*
*           LCT LOADS A COUNTER VALUE FOR USE WITH THE BCT
*           INSTRUCTION. THE VALUE IN OPV IS THE NUMBER OF LOOPS
*           TO BE EXECUTED. THE VALUE IN W AFTER THIS OPERATION
*           IS AN UNDEFINED ONE WORD INTEGER QUANTITY.
*
*      2.16 BCT  W,PLBL      BRANCH AND COUNT
*
*           BCT USES THE COUNTER VALUE IN W TO BRANCH THE
*           REQUIRED NUMBER OF TIMES AND THEN FINALLY TO FALL
*           THROUGH TO THE NEXT INSTRUCTION. BCT CAN ONLY BE
*           USED FOLLOWING AN APPROPRIATE LCT INSTRUCTION.
*           THE VALUE IN W AFTER EXECUTION OF BCT IS UNDEFINED.
*
*      2.17 AOV  OPV,OPN,PLBL ADD WITH CARRY TEST
*
*           ADDS OPV TO THE VALUE IN OPN AND STORES RESULT IN
*           OPN. BRANCHES TO PLBL IF RESULT EXCEEDS CFP$L
*           WITH RESULT IN OPN UNDEFINED. CF. ADD.
*
*      2.18 BEV  OPN,PLBL     BRANCH IF EVEN
*      2.19 BOD  OPN,PLBL     BRANCH IF ODD
*
*           THESE OPERATIONS ARE USED ONLY IF .CEPP OR .CRPP IS
*           DEFINED.  ON SOME IMPLEMENTATIONS, A MORE EFFICIENT
*           IMPLEMENTATION IS POSSIBLE BY NOTING THAT ADDRESS OF
*           BLOCKS MUST ALWAYS BE A MULTIPLE OF CFP$B. WE CALL
*           SUCH ADDRESSES EVEN.  THUS RETURN ADDRESS ON THE
*           STACK (.CRPP) AND ENTRY POINT ADDRESSES (.CEPP) CAN
*           BE DISTINGUISHED FROM BLOCK ADDRESSES IF THEY ARE
*           FORCED TO BE ODD (NOT A MULTIPLE OF CFP$B).
*           BEV AND BOD BRANCH ACCORDING AS OPERAND IS EVEN
*           OR ODD, RESPECTIVELY.
       EJC
*
*      -3-  OPERATIONS ON THE CODE POINTER REGISTER (CP)
*
*           THE CODE POINTER REGISTER PROVIDES A PSUEDO
*           INSTRUCTION COUNTER FOR USE IN AN INTERPRETOR. IT
*           MAY BE IMPLEMENTED AS A REAL REGISTER OR AS A
*           MEMORY LOCATION, BUT IN EITHER CASE IT IS SEPARATE
*           FROM ANY OTHER REGISTER. THE VALUE IN THE CODE
*           POINTER REGISTER IS ALWAYS A WORD ADDRESS (I.E.
*           A ONE WORD INTEGER WHICH IS A MULTIPLE OF CFP$B).
*
*      3.1  LCP  REG         LOAD CODE POINTER REGISTER
*                            THIS INSTRUCTION CAUSES THE CODE
*                            POINTER REGISTER TO BE SET FROM
*                            THE VALUE IN REG WHICH IS UNCHANGED
*
*      3.2  SCP  REG         STORE CODE POINTER REGISTER
*                            THIS INSTRUCTION LOADS THE CURRENT
*                            VALUE IN THE CODE POINTER REGISTER
*                            INTO REG. (CP) IS UNCHANGED.
*
*      3.3  LCW  REG         LOAD NEXT CODE WORD
*                            THIS INSTRUCTION CAUSES THE WORD
*                            POINTED TO BY CP TO BE LOADED INTO
*                            THE INDICATED REG. THE VALUE IN CP
*                            IS THEN INCREMENTED BY ONE WORD.
*                            EXECUTION OF LCW MAY DESTROY XL.
*
*      3.4  ICP              INCREMENT CP BY ONE WORD
*
*           ON MACHINES WITH MORE THAN THREE INDEX REGISTERS,
*           CP CAN BE TREATED SIMPLY AS AN INDEX REGISTER.
*           IN THIS CASE, THE FOLLOWING EQUIVALENCES APPLY.
*
*           LCP REG IS LIKE MOV REG,CP
*           SCP REG IS LIKE MOV CP,REG
*           LCW REG IS LIKE MOV (CP)+,REG
*           ICP     IS LIKE ICA CP
*
*           SINCE LCW IS ALLOWED TO DESTROY XL, THE FOLLOWING
*           IMPLEMENTATION USING A WORK LOCATION CP$$$ CAN
*           ALSO BE USED.
*
*           LCP  REG         MOV  REG,CP$$$
*
*           SCP  REG         MOV  CP$$$,REG
*
*           LCW  REG         MOV  CP$$$,XL
*                            MOV  (XL)+,REG
*                            MOV  XL,CP$$$
*
*           ICP              ICA  CP$$$
       EJC
*
*      -4-  OPERATIONS ON SIGNED INTEGER VALUES
*
*      4.1  LDI  OPS         LOAD INTEGER ACCUMULATOR FROM OPS
*      4.2  ADI  OPS         ADD OPS TO INTEGER ACCUMULATOR
*      4.3  MLI  OPS         MULTIPLY INTEGER ACCUMULATOR BY OPS
*      4.4  SBI  OPS         SUBTRACT OPS FROM INT ACCUMULATOR
*      4.5  DVI  OPS         DIVIDE INTEGER ACCUMULATOR BY OPS
*      4.6  RMI  OPS         SET INT ACCUM TO MOD(INTACC,OPS)
*      4.7  STI  OPS         STORE INTEGER ACCUMULATOR AT OPS
*      4.8  NGI              NEGATE THE VALUE IN THE INTEGER
*                            ACCUMULATOR (CHANGE ITS SIGN)
*
*           THE EQUATION SATISFIED BY OPERANDS AND RESULTS OF
*           DVI AND RMI IS
*                  DIV = QOT * OPS + REM          WHERE
*           DIV = DIVIDEND IN INTEGER ACCUMULATOR
*           QOT = QUOTIENT LEFT IN IA BY DIV
*           OPS = THE DIVISOR
*           REM = REMAINDER LEFT IN IA BY RMI
*           THE SIGN OF THE RESULT OF DVI IS + IF (IA) AND (OPS)
*           HAVE THE SAME SIGN AND IS - IF THEY HAVE OPPOSITE
*           SIGNS. THE SIGN OF (IA) IS ALWAYS USED AS THE SIGN
*           OF THE RESULT OF REM.
*           ASSUMING IN EACH CASE THAT IA CONTAINS THE NUMBER
*           SPECIFIED IN PARENTHESES AND THAT SEVEN AND MSEVN
*           HOLD +7 AND -7 RESP. THE ALGORITHM IS ILLUSTRATED
*           BELOW.
*           (IA = 13)
*           DVI  SEVEN       IA = 1
*           RMI  SEVEN       IA = 6
*           DVI  MSEVN       IA = -1
*           RMI  MSEVN       IA = 6
*           (IA = -13)
*           DVI  SEVEN       IA = -1
*           RMI  SEVEN       IA = -6
*           DVI  MSEVN       IA = 1
*           RMI  MSEVN       IA = -6
       EJC
*
*           THE ABOVE INSTRUCTIONS OPERATE ON A FULL RANGE OF
*           SIGNED INTEGER VALUES. WITH THE EXCEPTION OF LDI AND
*           STI, THESE INSTRUCTIONS MAY CAUSE INTEGER OVERFLOW
*           BY ATTEMPTING TO PRODUCE AN UNDEFINED OR OUT OF
*           RANGE RESULT IN WHICH CASE INTEGER OVERFLOW IS SET,
*           THE RESULT IN (IA) IS UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE IOV OR INO.
*           PARTICULAR CARE MAY BE NEEDED ON TARGET MACHINES
*           HAVING DISTINCT OVERFLOW AND DIVIDE BY ZERO
*           CONDITIONS.
*
*      4.9  INO  PLBL        JUMP TO PLBL IF NO INTEGER OVERFLOW
*      4.10 IOV  PLBL        JUMP TO PLBL IF INTEGER OVERFLOW
*
*           THESE INSTRUCTIONS CAN ONLY OCCUR IMMEDIATELY
*           FOLLOWING AN INSTRUCTION WHICH CAN CAUSE INTEGER
*           OVERFLOW (ADI, SBI, MLI, DVI, RMI, NGI) AND
*           TEST THE RESULT OF THE PRECEDING INSTRUCTION.
*           IOV AND INO MAY NOT HAVE LABELS.
*
*      4.11 IEQ  PLBL        JUMP TO PLBL IF (IA) EQ 0
*      4.12 IGE  PLBL        JUMP TO PLBL IF (IA) GE 0
*      4.13 IGT  PLBL        JUMP TO PLBL IF (IA) GT 0
*      4.14 ILE  PLBL        JUMP TO PLBL IF (IA) LE 0
*      4.15 ILT  PLBL        JUMP TO PLBL IF (IA) LT 0
*      4.16 INE  PLBL        JUMP TO PLBL IF (IA) NE 0
*
*           THE ABOVE CONDITIONAL JUMP INSTRUCTIONS DO
*           NOT CHANGE THE CONTENTS OF THE ACCUMULATOR.
*           ON A ONES COMPLEMENT MACHINE, IT IS PERMISSIBLE TO
*           PRODUCE NEGATIVE ZERO IN IA PROVIDED THESE
*           INSTRUCTIONS OPERATE CORRECTLY WITH SUCH A VALUE.
       EJC
*
*      -5-  OPERATIONS ON REAL VALUES
*
*      5.1  LDR  OPS         LOAD REAL ACCUMULATOR FROM OPS
*      5.2  STR  OPS         STORE REAL ACCUMULATOR AT OPS
*      5.3  ADR  OPS         ADD OPS TO REAL ACCUMULATOR
*      5.4  SBR  OPS         SUBTRACT OPS FROM REAL ACCUMULATOR
*      5.5  MLR  OPS         MULTIPLY REAL ACCUMULATOR BY OPS
*      5.6  DVR  OPS         DIVIDE REAL ACCUMULATOR BY OPS
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS CAUSES
*           UNDERFLOW, THE RESULT YIELDED IS 0.0.
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS IS
*           UNDEFINED OR OUT OF RANGE, REAL OVERFLOW IS SET,
*           THE CONTENTS OF (RA) ARE UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE EITHER ROV OR RNO.
*           PARTICULAR CARE MAY BE NEEDED ON TARGET MACHINES
*           HAVING DISTINCT OVERFLOW AND DIVIDE BY ZERO
*           CONDITIONS.
*
*      5.7  ROV  PLBL        JUMP TO PLBL IF REAL OVERFLOW
*      5.8  RNO  PLBL        JUMP TO PLBL IF NO REAL OVERFLOW
*
*           THESE INSTRUCTIONS CAN ONLY OCCUR IMMEDIATELY
*           FOLLOWING AN INSTRUCTION WHICH CAN CAUSE REAL
*           OVERFLOW (ADR,SBR,MLR,DVR).
*
*      5.9  NGR              NEGATE REAL ACCUM (CHANGE SIGN)
*
*      5.10 REQ  PLBL        JUMP TO PLBL IF (RA) EQ 0.0
*      5.11 RGE  PLBL        JUMP TO PLBL IF (RA) GE 0.0
*      5.12 RGT  PLBL        JUMP TO PLBL IF (RA) GT 0.0
*      5.13 RLE  PLBL        JUMP TO PLBL IF (RA) LE 0.0
*      5.14 RLT  PLBL        JUMP TO PLBL IF (RA) LT 0.0
*      5.15 RNE  PLBL        JUMP TO PLBL IF (RA) NE 0.0
*
*           THE ABOVE CONDITIONAL INSTRUCTIONS DO NOT AFFECT
*           THE VALUE STORED IN THE REAL ACCUMULATOR.
*           ON A ONES COMPLEMENT MACHINE, IT IS PERMISSIBLE TO
*           PRODUCE NEGATIVE ZERO IN RA PROVIDED THESE
*           INSTRUCTIONS OPERATE CORRECTLY WITH SUCH A VALUE.
.IF    .CMTH
*
*      5.16 ATN              ARCTANGENT OF REAL ACCUM
*      5.17 CHP              INTEGER PORTION OF REAL ACCUM
*      5.18 COS              COSINE OF REAL ACCUM
*      5.19 ETX              E TO THE POWER IN THE REAL ACCUM
*      5.20 LNF              NATURAL LOGORITHM OF REAL ACCUM
*      5.21 SIN              SINE OF REAL ACCUM
*      5.22 SQR              SQUARE ROOT OF REAL ACCUM
*      5.23 TAN              TANGENT OF REAL ACCUM
*
*           THE ABOVE ORDERS OPERATE UPON THE REAL ACCUMULATOR,
*           AND REPLACE THE CONTENTS OF THE ACCUMULATOR WITH THE
*           RESULT.
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS IS
*           UNDEFINED OR OUT OF RANGE, REAL OVERFLOW IS SET,
*           THE CONTENTS OF (RA) ARE UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE EITHER ROV OR RNO.
.FI
       EJC
*
*      -6-  OPERATIONS ON CHARACTER VALUES
*
*           CHARACTER OPERATIONS EMPLOY THE CONCEPT OF A
*           CHARACTER POINTER WHICH USES EITHER
*           INDEX REGISTER XR OR XL (NOT XS).
*
*           A CHARACTER POINTER POINTS TO A SPECIFIC CHARACTER
*           IN A STRING OF CHARACTERS STORED CFP$C CHARS TO A
*           WORD. THE ONLY OPERATIONS PERMITTED ON A CHARACTER
*           POINTER ARE LCH AND SCH. IN PARTICULAR, A CHARACTER
*           POINTER MAY NOT EVEN BE MOVED WITH MOV.
*
*              RESTRICTION 1.
*              --------------
*           IT IS IMPORTANT WHEN CODING IN MINIMAL TO ENSURE
*           THAT NO ACTION OCCURRING BETWEEN THE INITIAL USE OF
*           PLC OR PSC AND THE EVENTUAL CLEARING OF XL OR XR ON
*           COMPLETION OF CHARACTER OPERATIONS CAN INITIATE A
*           GARBAGE COLLECTION. THE LATTER OF COURSE COULD CAUSE
*           THE ADDRESSED CHARACTERS TO BE MOVED LEAVING THE
*           CHARACTER POINTERS POINTING TO RUBBISH.
*
*              RESTRICTION 2.
*              --------------
*           A FURTHER RESTRICTION TO BE OBSERVED IN CODE
*           HANDLING CHARACTER STRINGS, IS THAT STRINGS BUILT
*           DYNAMICALLY SHOULD BE RIGHT PADDED WITH ZERO
*           CHARACTERS TO A FULL WORD BOUNDARY TO PERMIT EASY
*           HASHING AND USE OF CEQ OR CNE IN TESTING STRINGS
*           FOR EQUALITY.
*
*      6.1  PLC  X,OPV       PREPARE CH PTR FOR LCH,CMC,MVC,TRC,
*                            MCB.
*
*      6.2  PSC  X,OPV       PREPARE CHAR. PTR FOR SCH,MVC,MCB.
*
*           OPV CAN BE OMITTED IF IT IS ZERO.
*           THE CHAR. INITIALLY ADDRESSED IS DETERMINED BY THE
*           WORD ADDRESS IN X AND THE INTEGER OFFSET OPV.
*           THERE IS AN AUTOMATIC IMPLIED OFFSET OF CFP$F BYTES.
*           CFP$F IS USED TO FORMALLY INTRODUCE INTO MINIMAL A
*           VALUE NEEDED IN TRANSLATING THESE OPCODES WHICH,
*           SINCE MINIMAL ITSELF DOES NOT PRESCRIBE A STRING
*           STRUCTURE IN DETAIL, DEPENDS ON THE CHOICE OF A DATA
*           STRUCTURE FOR STRINGS IN THE MINIMAL PROGRAM.
*           E.G. IF CFP$B = CFP$C = 3, CFP$F = 6, NUM01 = 1, XL
*           POINTS TO A SERIES OF 4 WORDS, ABC/DEF/GHI/JKL, THEN
*               PLC  XL,=NUM01
*           POINTS TO H.
       EJC
*
*      -6- OPERATIONS ON CHARACTER VALUES (CONTINUED)
*
*      6.3  LCH  REG,OPC     LOAD CHARACTER INTO REG
*
*      6.4  SCH  REG,OPC     STORE CHARACTER FROM REG
*
*           THESE OPERATIONS ARE DEFINED SUCH THAT THE CHARACTER
*           IS RIGHT JUSTIFIED IN REGISTER REG WITH ZERO BITS TO
*           THE LEFT. AFTER LCH FOR EXAMPLE, IT IS LEGITIMATE
*           TO REGARD REG AS CONTAINING THE ORDINAL INTEGER
*           CORRESPONDING TO THE CHARACTER.
*
*           OPC IS ONE OF THE FOLLOWING THREE POSSIBILITIES.
*
*           (X)              THE CHARACTER POINTED TO BY THE
*                            CHARACTER POINTER IN X. THE
*                            CHARACTER POINTER IS NOT CHANGED.
*
*           (X)+             SAME CHARACTER AS (X) BUT THE
*                            CHARACTER POINTER IS INCREMENTED
*                            TO POINT TO THE NEXT CHARACTER
*                            FOLLOWING EXECUTION.
*
*           -(X)             THE CHARACTER POINTER IS DECRE-
*                            MENTED BEFORE ACCESSING THE
*                            CHARACTER SO THAT THE PREVIOUS
*                            CHARACTER IS REFERENCED.
*
*      6.5  CSC  X           COMPLETE STORE CHARACTERS
*
*           THIS INSTRUCTION MARKS COMPLETION OF A
*           PSC,SCH,SCH,...,SCH SEQUENCE INITIATED BY
*           A  PSC  X INSTRUCTION. NO MORE SCH INSTRUCTIONS
*           USING  X  SHOULD BE OBEYED UNTIL ANOTHER PSC IS
*           OBEYED. IT IS PROVIDED SOLELY AS AN EFFICIENCY AID
*           ON MACHINES WITHOUT CHARACTER ORDERS SINCE IT
*           PERMITS USE OF REGISTER BUFFERING OF CHARS IN SCH
*           SEQUENCES. WHERE CSC IS NOT A NO-OP, IT MUST OBSERVE
*           RESTRICTION 2. (E.G. IN SPITBOL, ALOCS ZEROISES THE
*           LAST WORD OF A STRING FRAME PRIOR TO SCH SEQUENCE
*           BEING STARTED SO CSC MUST NOT NULLIFY THIS ACTION.)
*
*           THE FOLLOWING INSTRUCTIONS ARE USED TO COMPARE
*           TWO WORDS CONTAINING CFP$C CHARACTERS.
*           COMPARISONS DISTINCT FROM BEQ,BNE ARE PROVIDED AS
*           ON SOME TARGET MACHINES, THE POSSIBILITY OF THE SIGN
*           BIT BEING SET MAY REQUIRE SPECIAL ACTION.
*           NOTE THAT RESTRICTION 2 ABOVE, EASES USE OF THESE
*           ORDERS IN TESTING COMPLETE STRINGS FOR EQUALITY,
*           SINCE WHOLE WORD TESTS ARE POSSIBLE.
*
*      6.6  CEQ  OPW,OPW,PLBL JUMP TO PLBL IF OPW EQ OPW
*      6.7  CNE  OPW,OPW,PLBL JUMP TO PLBL IF OPW NE OPW
       EJC
*
*      -6- OPERATIONS ON CHARACTER VALUES (CONTINUED)
*
*      6.8  CMC  PLBL,PLBL   COMPARE CHARACTERS
*
*           CMC IS USED TO COMPARE TWO CHARACTER STRINGS. BEFORE
*           EXECUTING CMC, REGISTERS ARE SET UP AS FOLLOWS.
*           (XL)             CHARACTER PTR FOR FIRST STRING
*           (XR)             CHARACTER POINTER FOR SECOND STRING
*           (WA)             CHARACTER COUNT (MUST BE .GT. ZERO)
*           XL AND XR SHOULD HAVE BEEN PREPARED BY PLC.
*           CONTROL PASSES TO FIRST PLBL IF THE FIRST STRING
*           IS LEXICALLY LESS THAN THE SECOND STRING, AND TO
*           THE SECOND PLBL IF THE FIRST STRING IS LEXICALLY
*           GREATER. CONTROL PASSES TO THE FOLLOWING INSTRUCTION
*           IF THE STRINGS ARE IDENTICAL. AFTER EXECUTING THIS
*           INSTRUCTION, THE VALUES OF XR AND XL ARE SET TO
*           ZERO AND THE VALUE IN (WA) IS UNDEFINED.
*           ARGUMENTS TO CMC MAY BE COMPLETE OR PARTIAL
*           STRINGS, SO MAKING OPTIMISATION TO USE WHOLE WORD
*           COMPARISONS DIFFICULT (DEPENDENT IN GENERAL ON
*           SHIFTS AND MASKING).
*
*      6.9  TRC              TRANSLATE CHARACTERS
*
*           TRC IS USED TO TRANSLATE A CHARACTER STRING USING A
*           SUPPLIED TRANSLATION TABLE. BEFORE EXECUTING TRC THE
*           REGISTERS ARE SET AS FOLLOWS.
*           (XL)             CHAR PTR TO STRING TO BE TRANSLATED
*           (XR)             CHAR PTR TO TRANSLATE TABLE
*           (WA)             LENGTH OF STRING TO BE TRANSLATED
*           XL AND XR SHOULD HAVE BEEN PREPARED BY PLC.
*           THE TRANSLATE TABLE CONSISTS OF CFP$A CONTIGUOUS
*           CHARACTERS GIVING THE TRANSLATIONS OF THE CFP$A
*           CHARACTERS IN THE ALPHABET. ON COMPLETION, (XR) AND
*           (XL) ARE SET TO ZERO AND (WA) IS UNDEFINED.
*
*      6.10 FLC  W           FOLD CHARACTER TO UPPER CASE
*           FLC IS USED ONLY IF .CULC IS DEFINED. THE CHARACTER
*           CODE VALUE IN W IS TRANSLATED TO UPPER CASE IF IT
*           CORRESPONDS TO A LOWER CASE CHARACTER.
       EJC
*
*      -7-  OPERATIONS ON BIT STRING VALUES
*
*      7.1  ANB  OPW,W       AND BIT STRING VALUES
*      7.2  ORB  OPW,W       OR BIT STRING VALUES
*      7.3  XOB  OPW,W       EXCLUSIVE OR BIT STRING VALUES
*
*           IN THE ABOVE OPERATIONS, THE LOGICAL CONNECTIVE IS
*           APPLIED SEPARATELY TO EACH OF THE CFP$N BITS.
*           THE RESULT IS STORED IN THE SECOND OPERAND LOCATION.
*
*      7.4  CMB  W           COMPLEMENT ALL BITS IN OPW
*
*      7.5  RSH  W,VAL       RIGHT SHIFT BY VAL BITS
*      7.6  LSH  W,VAL       LEFT SHIFT BY VAL BITS
*      7.7  RSX  W,(X)       RIGHT SHIFT W NUMBER OF BITS IN X
*      7.8  LSX  W,(X)       LEFT SHIFT W NUMBER OF BITS IN X
*
*           THE ABOVE SHIFTS ARE LOGICAL SHIFTS IN WHICH BITS
*           SHIFTED OUT ARE LOST AND ZERO BITS SUPPLIED AS
*           REQUIRED. THE SHIFT COUNT IS IN THE RANGE 0-CFP$N.
*
*      7.9  NZB  W,PLBL      JUMP TO PLBL IF W IS NOT
*                            ALL ZERO BITS.
*
*      7.10 ZRB  W,PLBL      JUMP TO PLBL IF W IS ALL ZERO BITS
*
*      7.11 ZGB  OPN         ZEROISE GARBAGE BITS
*
*           OPN CONTAINS A BIT STRING REPRESENTING A WORD
*           OF CHARACTERS FROM A STRING OR SOME FUNCTION
*           FORMED FROM SUCH CHARACTERS (E.G. AS A RESULT OF
*           HASHING). ON A MACHINE WHERE THE WORD SIZE IS NOT A
*           MULTIPLE OF THE CHARACTER SIZE, SOME BITS IN REG MAY
*           BE UNDEFINED. THIS OPCODE REPLACES SUCH BITS BY THE
*           ZERO BIT. ZGB IS A NO-OP IF THE WORD SIZE IS A
*           MULTIPLE OF THE CHARACTER SIZE.
       EJC
*
*      -8-  CONVERSION INSTRUCTIONS
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           BETWEEN LENGTHS IN BYTES AND LENGTHS IN WORDS.
*
*      8.1  WTB  REG         CONVERT REG FROM WORDS TO BYTES.
*                            THAT IS, MULTIPLY BY CFP$B. THIS IS
*                            A NO-OP IF CFP$B IS ONE.
*
*      8.2  BTW  REG         CONVERT REG FROM BYTES TO WORDS
*                            BY DIVIDING REG BY CFP$B DISCARDING
*                            THE FRACTION. NO-OP IF CFP$B IS ONE
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           OF ONE WORD INTEGER VALUES (ADDRESSES) TO AND
*           FROM THE FULL SIGNED INTEGER FORMAT.
*
*      8.3  MTI  OPN         THE VALUE OF OPN (AN ADDRESS)
*                            IS MOVED AS A POSITIVE INTEGER
*                            TO THE INTEGER ACCUMULATOR.
*
*      8.4  MFI  OPN,PLBL    THE VALUE CURRENTLY STORED IN THE
*                            INTEGER ACCUMULATOR IS MOVED
*                            TO OPN AS AN ADDRESS IF IT IS IN
*                            THE RANGE 0 TO CFP$M INCLUSIVE.
*                            IF THE ACCUMULATOR VALUE IS
*                            OUTSIDE THIS RANGE, THEN THE RESULT
*                            IN OPN IS UNDEFINED AND CONTROL IS
*                            PASSED TO PLBL. MFI DESTROYS THE
*                            VALUE OF (IA) WHETHER OR NOT
*                            INTEGER OVERFLOW IS SIGNALLED.
*                            PLBL MAY BE OMITTED IF OVERFLOW
*                            IS IMPOSSIBLE.
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           BETWEEN REAL VALUES AND INTEGER VALUES.
*
*      8.5  ITR              CONVERT INTEGER VALUE IN INTEGER
*                            ACCUMULATOR TO REAL AND STORE IN
*                            REAL ACCUMULATOR (MAY LOSE
*                            PRECISION IN SOME CASES)
*
*      8.6  RTI  PLBL        CONVERT THE REAL VALUE IN RA TO
*                            AN INTEGER AND PLACE RESULT IN IA.
*                            CONVERSION IS BY TRUNCATION OF THE
*                            FRACTION - NO ROUNDING OCCURS.
*                            JUMP TO PLBL IF OUT OF RANGE. (RA)
*                            IS NOT CHANGED IN EITHER CASE.
*                            PLBL MAY BE OMITTED IF OVERFLOW
*                            IS IMPOSSIBLE.
       EJC
*
*      -8-  CONVERSION INSTRUCTIONS (CONTINUED)
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR COMPUTING
*           THE LENGTH OF STORAGE REQUIRED FOR A TEXT STRING.
*
*      8.7  CTW  W,VAL       THIS INSTRUCTION COMPUTES THE SUM
*                            (NUMBER OF WORDS REQUIRED TO STORE
*                            W CHARACTERS) + (VAL). THE SUM
*                            IS STORED IN W.
*                            FOR EXAMPLE, IF CFP$C IS 5, AND WA
*                            CONTAINS 32, THEN CTW WA,2
*                            GIVES A RESULT OF 9 IN WA.
*
*      8.8  CTB  W,VAL       CTB IS EXACTLY LIKE CTW EXCEPT THAT
*                            THE RESULT IS IN BYTES. IT HAS THE
*                            SAME EFFECT AS CTW W,VAL  WTB W
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           FROM INTEGERS TO AND FROM NUMERIC DIGIT CHARACTERS
*           FOR USE IN NUMERIC CONVERSION ROUTINES. THEY EMPLOY
*           NEGATIVE INTEGER VALUES TO ALLOW FOR PROPER
*           CONVERSION OF NUMBERS WHICH CANNOT BE COMPLEMENTED.
*
*      8.9  CVM  PLBL        CONVERT BY MULTIPLICATION
*
*           THE INTEGER ACCUMULATOR, WHICH IS ZERO OR NEGATIVE,
*           IS MULTIPLIED BY 10. WB CONTAINS THE CHARACTER
*           CODE FOR A DIGIT. THE VALUE OF THIS DIGIT IS THEN
*           SUBTRACTED FROM THE RESULT. IF THE RESULT IS OUT OF
*           RANGE, THEN CONTROL IS PASSED TO PLBL WITH THE
*           RESULT IN (IA) UNDEFINED. EXECUTION OF CVM LEAVES
*           THE RESULT IN (WB) UNDEFINED.
*
*      8.10 CVD              CONVERT BY DIVISION
*
*           THE INTEGER ACCUMULATOR, WHICH IS ZERO OR NEGATIVE,
*           IS DIVIDED BY 10. THE QUOTIENT (ZERO OR NEGATIVE)
*           IS REPLACED IN THE ACCUMULATOR. THE REMAINDER IS
*           CONVERTED TO THE CHARACTER CODE OF A DIGIT AND
*           PLACED IN WA. FOR EXAMPLE, AN OPERAND OF -523 GIVES
*           A QUOTIENT OF -52 AND A REMAINDER IN WA OF CH$D3.
       EJC
*
*      -9-  BLOCK MOVE INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTIONS ARE USED FOR TRANSFERRING
*      DATA FROM ONE AREA OF MEMORY TO ANOTHER IN BLOCKS.
*      THEY CAN BE IMPLEMENTED WITH THE INDICATED SERIES OF
*      OTHER MACRO-INSTRUCTIONS, BUT MORE EFFICIENT IMPLE-
*      MENTATIONS WILL BE POSSIBLE ON MOST MACHINES.
*
*      NOTE THAT IN THE EQUIVALENT CODE SEQUENCE SHOWN BELOW, A
*      ZERO VALUE IN WA WILL MOVE AT LEAST ONE ITEM, AND MAY
*      MAY WRAP THE COUNTER CAUSING A CORE DUMP IN SOME IMPLE-
*      MENTATIONS.  THUS WA SHOULD BE .GT. 0 PRIOR TO INVOKING
*      ANY OF THESE BLOCK MOVE INSTRUCTIONS.
*
*      9.1  MVC              MOVE CHARACTERS
*
*           BEFORE OBEYING THIS ORDER WA,XL,XR SHOULD HAVE BEEN
*           SET UP, THE LATTER TWO BY PLC, PSC RESP.
*           MVC IS EQUIVALENT TO THE SEQUENCE
*
*                  MOV  WB,DUMPB
*                  LCT  WA,WA
*           LOOPC  LCH  WB,(XL)+
*                  SCH  WB,(XR)+
*                  BCT  WA,LOOPC
*                  CSC  XR
*                  MOV  DUMPB,WB
*
*           THE CHARACTER POINTERS ARE BUMPED AS INDICATED
*           AND THE FINAL VALUE OF WA IS UNDEFINED.
*
*
*      9.2  MVW              MOVE WORDS
*
*           MVW IS EQUIVALENT TO THE SEQUENCE
*
*           LOOPW  MOV  (XL)+,(XR)+
*                  DCA  WA               WA = BYTES TO MOVE
*                  BNZ  WA,LOOPW
*
*           NOTE THAT THIS IMPLIES THAT THE VALUE IN WA IS THE
*           LENGTH IN BYTES WHICH IS A MULTIPLE OF CFP$B.
*           THE INITIAL ADDRESSES IN XR,XL ARE WORD ADDRESSES.
*           AS INDICATED, THE FINAL XR,XL VALUES POINT PAST THE
*           NEW AND OLD REGIONS OF MEMORY RESPECTIVELY.
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MVW.
*
*      9.3  MWB              MOVE WORDS BACKWARDS
*
*           MWB IS EQUIVALENT TO THE SEQUENCE
*
*           LOOPB  MOV  -(XL),-(XR)
*                  DCA  WA               WA = BYTES TO MOVE
*                  BNZ  WA,LOOPB
*
*           THERE IS A REQUIREMENT THAT THE INITIAL VALUE IN XL
*           BE AT LEAST 256 LESS THAN THE VALUE IN XR. THIS
*           ALLOWS AN IMPLEMENTATION IN WHICH CHUNKS OF 256
*           BYTES ARE MOVED FORWARD (IBM 360, ICL 1900).
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MWB.
*
*      9.4  MCB              MOVE CHARACTERS BACKWARDS
*
*           MCB IS EQUIVALENT TO THE SEQUENCE
*
*                  MOV  WB,DUMPB
*                  LCT  WA,WA
*           LOOPC  LCH  WB,-(XL)
*                  SCH  WB,-(XR)
*                  BCT  WA,LOOPC
*                  CSC  XR
*                  MOV  DUMPB,WB
*
*           THERE IS A REQUIREMENT THAT THE INITIAL VALUE IN XL
*           BE AT LEAST 256 LESS THAN THE VALUE IN XR. THIS
*           ALLOWS AN IMPLEMENTATION IN WHICH CHUNKS OF 256
*           BYTES ARE MOVED FORWARD (IBM 360, ICL 1900).
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MCB.
       EJC
*
*      -10- OPERATIONS CONNECTED WITH THE STACK
*
*      THE STACK IS AN AREA IN MEMORY WHICH IS DEDICATED FOR USE
*      IN CONJUNCTION WITH THE STACK POINTER REGISTER (XS). AS
*      PREVIOUSLY DESCRIBED, IT IS USED BY THE JSR AND EXI
*      INSTRUCTIONS AND MAY BE USED FOR STORAGE OF ANY OTHER
*      DATA AS REQUIRED.
*
*      THE STACK BUILDS EITHER WAY IN MEMORY AND AN IMPORTANT
*      RESTRICTION IS THAT THE VALUE IN (XS) MUST BE THE ADDRESS
*      OF THE STACK FRONT AT ALL TIMES SINCE
*      SOME IMPLEMENTATIONS MAY RANDOMLY DESTROY STACK LOCATIONS
*      BEYOND (XS).
*
*      THE STARTING STACK BASE ADDRESS IS PASSED
*      IN (XS) AT THE START OF EXECUTION. DURING EXECUTION IT
*      IS NECESSARY TO MAKE SURE THAT THE STACK DOES NOT
*      OVERFLOW. THIS IS ACHIEVED BY EXECUTING THE FOLLOWING
*      INSTRUCTION PERIODICALLY.
*
*      10.1 CHK              CHECK STACK OVERFLOW
*
*      AFTER SUCCESSFULLY EXECUTING CHK, IT IS PERMISSIBLE TO
*      USE UP TO 100 ADDITIONAL WORDS BEFORE ISSUING ANOTHER CHK
*      THUS CHK NEED NOT BE ISSUED EVERY TIME THE STACK IS
*      EXPANDED. IN SOME IMPLEMENTATIONS, THE CHECKING MAY BE
*      AUTOMATIC AND CHK WILL HAVE NO EFFECT. FOLLOWING THE
*      ABOVE RULE MAKES SURE THAT THE PROGRAM WILL OPERATE
*      CORRECTLY IN IMPLEMENTATIONS WITH NO AUTOMATIC CHECK.
*
*      IF STACK OVERFLOW OCCURS (DETECTED EITHER AUTOMATICALLY
*      OR BY A CHK INSTRUCTION), THEN CONTROL IS PASSED TO THE
*      STACK OVERFLOW SECTION (SEE PROGRAM FORM). NOTE THAT THIS
*      TRANSFER MAY TAKE PLACE FOLLOWING ANY INSTRUCTION WHICH
*      STORES DATA AT A NEW LOCATION ON THE STACK.
*      AFTER STACK OVERFLOW, STACK IS ARBITRARILY POPPED
*      TO GIVE SOME SPACE IN WHICH THE ERROR PROCEDURE MAY
*      OPERATE. OTHERWISE A LOOP OF STACK OVERFLOWS MAY OCCUR.
       EJC
*
*      -11- DATA GENERATION INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTIONS ARE USED TO GENERATE CONSTANT
*      VALUES IN THE CONSTANT SECTION AND ALSO TO ASSEMBLE
*      INITIAL VALUES IN THE WORKING STORAGE SECTION. THEY
*      MAY NOT APPEAR EXCEPT IN THESE TWO SECTIONS.
*
*      11.1 DAC  ADDR        ASSEMBLE ADDRESS CONSTANT.
*                            GENERATES ONE WORD CONTAINING THE
*                            SPECIFIED ONE WORD INTEGER
*                            VALUE (ADDRESS).
*
*      11.2 DIC  INTEGER     GENERATES AN INTEGER VALUE WHICH
*                            OCCUPIES CFP$I CONSECUTIVE WORDS.
*                            THE OPERAND IS A DIGIT STRING WITH
*                            A REQUIRED LEADING SIGN.
*
*      11.3 DRC  REAL        ASSEMBLES A REAL CONSTANT WHICH
*                            OCCUPIES CFP$R CONSECUTIVE WORDS.
*                            THE OPERAND FORM MUST OBEY THE
*                            RULES FOR A FORTRAN REAL CONSTANT
*                            WITH THE EXTRA REQUIREMENT THAT A
*                            LEADING SIGN BE PRESENT.
*
*      11.4 DTC  DTEXT       DEFINE TEXT CONSTANT. DTEXT
*                            IS STARTED AND ENDED WITH ANY
*                            CHARACTER NOT CONTAINED IN THE
*                            CHARACTERS TO BE ASSEMBLED. THE
*                            CONSTANT OCCUPIES CONSECUTIVE WORDS
*                            AS DICTATED BY THE CONFIGURATION
*                            PARAMETER CFP$C. ANY UNUSED CHARS
*                            IN THE LAST WORD ARE RIGHT FILLED
*                            WITH ZEROS (I.E. THE CHARACTER
*                            WHOSE INTERNAL CODE IS ZERO).
*                            THE STRING CONTAINS A SEQUENCE OF
*                            LETTERS, DIGITS, BLANKS AND ANY OF
*                            THE FOLLOWING SPECIAL CHARACTERS.
*                            =,$.(*)/+-
*                            NO OTHER CHARACTERS
*                            MAY BE USED IN A DTEXT OPERAND.
*
*      11.5 DBC  VAL         ASSEMBLE BIT STRING CONSTANT. THE
*                            OPERAND IS A POSITIVE INTEGER
*                            VALUE WHICH IS INTERPRETED IN
*                            BINARY, RIGHT JUSTIFIED AND LEFT
*                            FILLED WITH ZERO BITS. THUS 5 WOULD
*                            IMPLY THE BIT STRING VALUE 00...101.
       EJC
*
*      -12- SYMBOL DEFINITION INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTION IS USED TO DEFINE SYMBOLS
*      IN THE DEFINITIONS SECTION. IT MAY NOT BE USED ELSEWHERE.
*
*      12.1 EQU  EQOP        DEFINE SYMBOL
*
*           THE SYMBOL WHICH APPEARS IN THE LABEL FIELD IS
*           DEFINED TO HAVE THE ABSOLUTE VALUE GIVEN
*           BY THE EQOP OPERAND. A GIVEN SYMBOL MAY BE DEFINED
*           ONLY ONCE IN THIS MANNER, AND ANY SYMBOLS OCCURING
*           IN EQOP MUST BE PREVIOUSLY DEFINED.
*
*           THE FOLLOWING ARE THE POSSIBILITIES FOR EQOP
*
*           VAL              THE INDICATED VALUE IS USED
*
*           VAL+VAL          THE SUM OF THE TWO VALUES IS USED.
*                            THIS SUM MUST NOT EXCEED CFP$M
*
*           VAL-VAL          THE DIFFERENCE BETWEEN THE TWO
*                            VALUES (MUST BE POSITIVE) IS USED.
*
*           *                THIS FORMAT DEFINES THE LABEL BY
*                            USING A VALUE SUPPLIED BY THE
*                            MINIMAL TRANSLATOR. VALUES ARE
*                            REQUIRED FOR THE
*           CFP$X            (CONFIGURATION PARAMETERS)
*           E$XXX            (ENVIRONMENT PARAMETERS)
*           CH$XX            (CHARACTER CODES).
*                            IN ORDER FOR A TRANSLATOR TO
*                            HANDLE THIS FORMAT CORRECTLY THE
*                            DEFINITIONS SECTION MUST BE
*                            CONSULTED FOR DETAILS OF REQUIRED
*                            SYMBOLS AS LISTED AT THE FRONT OF
*                            THE SECTION.
       EJC
*
*      SYMBOL DEFINITION INSTRUCTIONS (CONTINUED)
*
*      THE FOLLOWING INSTRUCTIONS MAY BE USED TO DEFINE SYMBOLS
*      IN THE PROCEDURE SECTION. THEY MAY NOT BE USED IN
*      ANY OTHER PART OF THE PROGRAM.
*
*      12.2 EXP              DEFINE EXTERNAL PROCEDURE
*
*           EXP DEFINES THE SYMBOL APPEARING IN THE LABEL FIELD
*           TO BE THE NAME OF AN EXTERNAL PROCEDURE WHICH CAN BE
*           REFERENCED IN A SUBSEQUENT JSR INSTRUCTION. THE
*           CODING FOR THE PROCEDURE IS EXTERNAL TO THE
*           CODING OF THE SOURCE PROGRAM IN THIS LANGUAGE.
*           THE CODE FOR EXTERNAL PROCEDURES MAY BE
*           REFERRED TO COLLECTIVELY AS THE OPERATING SYSTEM
*           INTERFACE, OR MORE BRIEFLY, OSINT, AND WILL
*           FREQUENTLY BE A SEPARATELY COMPILED SEGMENT OF CODE
*           LOADED WITH SPITBOL TO PRODUCE A COMPLETE SYSTEM.
*
*      12.3 INP  PTYP,INT    DEFINE INTERNAL PROCEDURE
*
*           INP DEFINES THE SYMBOL APPEARING IN THE LABEL FIELD
*           TO BE THE NAME OF AN INTERNAL PROCEDURE AND GIVES
*           ITS TYPE AND NUMBER OF EXIT PARAMETERS. THE LABEL
*           CAN BE REFERENCED IN JSR INSTRUCTIONS AND
*           IT MUST APPEAR LABELLING A PRC INSTRUCTION IN THE
*           PROGRAM SECTION.
*
*      12.4 INR              DEFINE INTERNAL ROUTINE
*
*           INR DEFINES THE SYMBOL APPEARING IN THE LABEL
*           FIELD TO BE THE NAME OF AN INTERNAL ROUTINE. THE
*           LABEL MAY BE REFERENCED IN ANY TYPE OF BRANCH ORDER
*           AND IT MUST APPEAR LABELLING A RTN INSTRUCTION IN
*           THE PROGRAM SECTION.
       EJC
*
*      -13- ASSEMBLY LISTING LAYOUT INSTRUCTIONS
*
*      13.1 EJC              EJECT TO NEXT PAGE
*
*      13.2 TTL  TEXT        SET NEW ASSEMBLY TITLE
*
*           TTL IMPLIES AN IMMEDIATE EJECT OF THE
*           ASSEMBLY LISTING TO PRINT THE NEW TITLE.
*
*           THE USE OF TTL AND EJC CARDS IS SUCH THAT THE
*           PROGRAM WILL LIST NEATLY IF THE PRINTER PRINTS
*           AS MANY AS 58 LINES PER PAGE. IN THE EVENT THAT
*           THE PRINTER DEPTH IS LESS THAN THIS, OR IF THE
*           LISTING CONTAINS INTERSPERSED LINES (SUCH AS ACTUAL
*           GENERATED CODE), THEN THE FORMAT MAY BE UPSET.
*
*           LINES STARTING WITH AN ASTERISK ARE COMMENT LINES
*           WHICH CAUSE NO CODE TO BE GENERATED AND MAY OCCUR
*           FREELY ANYWHERE IN THE PROGRAM. THE FORMAT FOR
*           COMMENT LINES IS GIVEN IN SECTION -15-.
       EJC
*
*      -14- PROGRAM FORM
*
*           THE PROGRAM CONSISTS OF SEPARATE SECTIONS SEPARATED
*           BY SEC OPERATIONS. THE SECTIONS MUST APPEAR IN THE
*           FOLLOWING SPECIFIED ORDER.
*
*      14.1 SEC              START OF PROCEDURE SECTION
*
*           (PROCEDURE SECTION)
*
*           SEC               START OF DEFINITIONS SECTION
*
*           (DEFINITIONS SECTION)
*
*           SEC               START OF CONSTANT STORAGE SECTION
*
*           (CONSTANT STORAGE SECTION)
*
*           SEC               START OF WORKING STORAGE SECTION
*
*           (WORKING STORAGE SECTION)
*
*           SEC               START OF PROGRAM SECTION
*
*           (PROGRAM SECTION)
*
*           SEC               START OF STACK OVERFLOW SECTION
*
*           (STACK OVERFLOW SECTION)
*
*           SEC               START OF ERROR SECTION
*
*           (ERROR SECTION)
*
*      14.2 END              END OF ASSEMBLY
       EJC
*
*      SECTION 10 - PROGRAM FORM
*
*      PROCEDURE SECTION
*
*           THE PROCEDURE SECTION CONTAINS ALL THE EXP
*           INSTRUCTIONS FOR EXTERNALLY AVAILABLE PROCEDURES
*           AND INP,INR OPCODES FOR INTERNAL PROCEDURES,ROUTINES
*           SO THAT A SINGLE PASS MINIMAL TRANSLATOR HAS ADVANCE
*           KNOWLEDGE OF PROCEDURE TYPES WHEN TRANSLATING CALLS.
*
*      DEFINITIONS SECTION
*
*           THE DEFINITIONS SECTION CONTAINS EQU INSTRUCTIONS
*           WHICH DEFINE SYMBOLS REFERENCED LATER ON IN THE
*           PROGRAM, CONSTANT AND WORK SECTIONS.
*
*      CONSTANT STORAGE SECTION
*
*           THE CONSTANT STORAGE SECTION CONSISTS ENTIRELY
*           OF CONSTANTS ASSEMBLED WITH THE DAC,DIC,DRC,DTC,DBC
*           ASSEMBLY OPERATIONS. THESE CONSTANTS CAN BE FREELY
*           REFERENCED BY THE PROGRAM INSTRUCTIONS.
*
*      WORKING STORAGE SECTION
*
*           THE WORKING STORAGE SECTION CONSISTS ENTIRELY OF
*           DAC,DIC,DRC,DBC,DTC INSTRUCTIONS TO DEFINE A FIXED
*           LENGTH WORK AREA. THE WORK LOCATIONS IN THIS AREA
*           CAN BE DIRECTLY REFERENCED IN PROGRAM INSTRUCTIONS.
*           THE AREA IS INITIALIZED IN ACCORDANCE WITH THE
*           VALUES ASSEMBLED IN THE INSTRUCTIONS.
*
*      PROGRAM SECTION
*
*           THE PROGRAM SECTION CONTAINS PROGRAM INSTRUCTIONS
*           AND ASSOCIATED OPERATIONS (SUCH AS PRC, ENP, ENT).
*           CONTROL IS PASSED TO THE FIRST INSTRUCTION IN THIS
*           SECTION WHEN EXECUTION IS INITIATED.
*
*      STACK OVERFLOW SECTION
*
*           THE STACK OVERFLOW SECTION CONTAINS INSTRUCTIONS
*           LIKE THE PROGRAM SECTION. CONTROL IS PASSED TO THE
*           FIRST INSTRUCTION IN THIS SECTION FOLLOWING THE
*           OCCURRENCE OF STACK OVERFLOW, SEE CHK INSTRUCTION.
*
*      ERROR SECTION
*
*           THE ERROR SECTION CONTAINS INSTRUCTIONS LIKE THE
*           PROGRAM SECTION. CONTROL IS PASSED TO THE FIRST
*           INSTRUCTION IN THIS SECTION WHEN A PROCEDURE EXIT
*           CORRESPONDS TO AN ERROR PARAMETER (SEE ERR)
*           OR WHEN AN ERB OPCODE IS OBEYED. THE ERROR CODE
*           MUST CLEAN UP THE MAIN STACK AND CATER FOR THE
*           POSSIBILITY THAT A SUBROUTINE STACK MAY NEED CLEAN
*           UP.
       EJC
*      OSINT
*
*           THOUGH NOT PART OF THE MINIMAL SOURCE, IT IS USEFUL
*           TO REFER TO THE COLLECTION OF INITIALISATION AND
*           EXP ROUTINES AS OSINT (OPERATING SYSTEM INTERFACE).
*           ERRORS OCCURRING WITHIN OSINT PROCEDURES ARE
*           USUALLY HANDLED BY MAKING AN ERROR RETURN. IF THIS
*           IS NOT FEASIBLE OR APPROPRIATE, OSINT MAY USE THE
*           MINIMAL ERROR SECTION TO REPORT ERRORS DIRECTLY BY
*           BRANCHING TO IT WITH A SUITABLE NUMERIC ERROR
*           CODE IN WA.
       EJC
*
*      SECTION 11 - STATEMENT FORMAT
*
*      ALL LABELS ARE EXACTLY FIVE CHARACTERS LONG AND START
*      WITH THREE LETTERS (ABCDEFGHIJKLMNOPQRSTUVWXY$) FOLLOWED
*      BY TWO LETTERS OR DIGITS.
*      THE LETTER Z MAY NOT BE USED IN MINIMAL SYMBOLS BUT $ IS
*      PERMITTED.
*      FOR IMPLEMENTATIONS WHERE $ MAY NOT APPEAR IN THE
*      TARGET CODE , A SIMPLE SUBSTITUTION OF Z FOR $
*      MAY THUS BE MADE WITHOUT RISK OF PRODUCING NON-UNIQUE
*      SYMBOLS.
*      THE LETTER Z IS HOWEVER PERMITTED IN OPCODE MNEMONICS AND
*      IN COMMENTS.
*
*      MINIMAL STATEMENTS ARE IN A FIXED FORMAT AS FOLLOWS.
*
*      COLS 1-5              LABEL IF ANY (ELSE BLANK)
*
*      COLS 6-7              ALWAYS BLANK
*
*      COLS 8-10             OPERATION MNEMONIC
*
*      COLS 11-12            BLANKS
*
*      COLS 13-28            OPERAND FIELD, TERMINATED BY A
*                            BLANK. MAY OCCASIONALLY
*                            EXTEND PAST COLUMN 28.
*
*      COLS 30-64            COMMENT. ALWAYS SEPARATED FROM THE
*                            OPERAND FIELD BY AT LEAST ONE BLANK
*                            MAY OCCASIONALLY START AFTER COLUMN
*                            30 IF THE OPERAND EXTENDS PAST 28.
*                            A SPECIAL EXCEPTION OCCURS FOR THE
*                            IFF INSTRUCTION, WHOSE COMMENT MAY
*                            BE ONLY 20 CHARACTERS LONG (30-49).
*
*      COLS 65 ON            UNUSED
*
*
*      COMMENT LINES HAVE THE FOLLOWING FORMAT
*
*      COL 1                 ASTERISK
*
*      COLS 2-7              BLANK
*
*      COLS 8-64             ARBITRARY TEXT, RESTRICTED TO THE
*                            FORTRAN CHARACTER SET.
*
*
*      THE FORTRAN CHARACTER SET IS A-Z 0-9 =,$.(*)-/+
       EJC
*
*      SECTION 12 - PROGRAM EXECUTION
*
*      EXECUTION OF THE PROGRAM BEGINS WITH THE FIRST
*      INSTRUCTION IN THE PROGRAM SECTION.
*
*      IN ADDITION TO THE FIXED LENGTH MEMORY REGIONS DEFINED
*      BY THE ASSEMBLY, THERE ARE TWO DYNAMICALLY ALLOCATED
*      MEMORY REGIONS AS FOLLOWS.
*
*      DATA AREA             THIS IS AN AREA AVAILABLE TO THE
*                            PROGRAM FOR GENERAL STORAGE OF DATA
*                            ANY DATA VALUE MAY BE STORED IN
*                            THIS AREA EXCEPT INSTRUCTIONS.
*                            IN SOME IMPLEMENTATIONS, IT MAY BE
*                            POSSIBLE TO INCREASE THE SIZE OF
*                            THIS AREA DYNAMICALLY BY ADDING
*                            WORDS AT THE TOP END WITH A CALL
*                            TO A SYSTEM PROCEDURE.
*
*      STACK AREA            THIS REGION OF MEMORY HOLDS
*                            THE STACK USED FOR SUBROUTINE CALLS
*                            AND OTHER STORAGE OF ONE WORD
*                            INTEGER VALUES (ADDRESSES). THIS
*                            IS THE STACK ASSOCIATED WITH
*                            INDEX REGISTER XS.
*
*      THE LOCATIONS AND SIZES OF THESE AREAS ARE SPECIFIED
*      BY THE VALUES IN THE REGISTERS AT THE START OF PROGRAM
*      EXECUTION AS FOLLOWS.
*
*      (XS)                  ADDRESS ONE PAST THE STACK BASE.
*                            E.G. IF XS IS 23456, A D-STACK WILL
*                            OCCUPY WORDS 23455,23454,...
*                            WHEREAS A U-STACK WILL OCCUPY
*                            23457,23458,...
*
*      (XR)                  ADDRESS OF THE FIRST WORD
*                            IN THE DATA AREA
*
*      (XL)                  ADDRESS OF THE LAST WORD IN THE
*                            DATA AREA.
*
*      (WA)                  INITIAL STACK POINTER
*
*      (WB,WC,IA,RA,CP)      ZERO
*
*      THERE IS NO EXPLICIT WAY TO TERMINATE THE EXECUTION OF A
*      PROGRAM. THIS FUNCTION IS PERFORMED BY AN APPROPRIATE
*      SYSTEM PROCEDURE REFERENCED WITH THE SYSEJ INSTRUCTION.
